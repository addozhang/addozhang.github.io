<!DOCTYPE html>
<html>
<head>
    <title>Kafka的消息可靠传递 // 乱世浮生</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    <meta name="description" content="知我者谓我何忧 不知我者谓我何求.">
    <meta name="keywords" content="Java,Spring Cloud,Architecture,">

        <meta property="og:title" content="Kafka的消息可靠传递" />
    <meta property="og:description" content="知我者谓我何忧 不知我者谓我何求." />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="zh-cn" />
    <meta property="og:url" content="https://atbug.com/kafka-reliable-data-delivery/" />
    

    <link rel="shortcut icon" href="../favicon.ico">

    <link href="https://atbug.com/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="https://atbug.com/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="https://atbug.com/css/style.css">
    

    <meta name="generator" content="Hugo 0.65.1" />
</head>


<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="https://atbug.com/">乱世浮生</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="../">Home</a>
                
                <a class="main-nav-link" href="../post/">Archives</a>
                
                <a class="main-nav-link" href="../tags/">Tags</a>
                
                <a class="main-nav-link" href="../categories/">Categories</a>
                
                <a class="main-nav-link" href="../about/">About</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        <article class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            <h1 class="article-title" itemprop="name">Kafka的消息可靠传递</h1>
        </header>
        
        <div class="article-meta">
            <a href="../kafka-reliable-data-delivery/" class="article-date">
                <time datetime='2017-11-18T14:01:46.000&#43;00:00' itemprop="datePublished">2017-11-18</time>
            </a>
            
            
            <div class="post-categories">
                <div class="article-category">
                    
                    
                    <a class="article-category-link" href="https://atbug.com//categories/%E7%AC%94%E8%AE%B0">笔记</a>
                    
                </div>
            </div>
            
            
            <div class="article-comment-link-wrap">
                <a href="../kafka-reliable-data-delivery/#disqus_thread" class="article-comment-link">Comments</a>
            </div>
            
        </div>
        <div class="article-entry" itemprop="articleBody">
            <p>Kafka提供的基础保障可以用来构建可靠的系统, 却无法保证完全可靠. 需要在可靠性和吞吐之间做取舍.</p>
<ul>
<li>Kafka在分区上提供了消息的顺序保证.</li>
<li>生产的消息在写入到所有的同步分区上后被认为是<strong>已提交</strong> (不需要刷到硬盘). 生产者可以选择在消息提交完成后接收broker的确认, 是写入leader之后, 或者所有的副本</li>
<li>只要有一个副本存在, 提交的消息就不会丢失</li>
<li>消费者只能读取到已提交的消息</li>
</ul>
<h2 id="复制">复制</h2>
<p>Kafka的复制机制保证每个分区有多个副本, 每个副本可以作为leader或者follower的角色存在. 为了保证副本的同步, 需要做到:</p>
<ul>
<li>保持到zk的连接会话: 每隔6s向zk发送心跳, 时间可配置</li>
<li>每隔10s向leader拉取消息, 时间可配置</li>
<li>从leader拉取最近10s的写入的消息. 保持不间断的从leader获取消息是不够的, 必须保证几乎没有延迟</li>
</ul>
<h2 id="broker配置">Broker配置</h2>
<h3 id="复制因子">复制因子</h3>
<p><code>default.replication.factor</code> broker级别的副本数设置, 通过这个配置来控制<strong>自动创建</strong>的topic的副本数. 为N的时候, 可以容忍失去N-1个副本, 保证topic的可读写.</p>
<h3 id="脏副本的leader选举">脏副本的leader选举</h3>
<p><code>unclean.leader.election.enable</code> 0.11.0.0之前的版本, 默认为true; 之后的版本默认为false. 这个设置控制不同步的副本能否参与leader的选举. 如果设置为true, 当没有同步副本可用的时候, 不同步的副本会成为leader, 意味着有数据丢失. 如果设置为false, 则意味着系统会处于不可用的状态, 该部分没有leader提供服务. 需要在<strong>可用性</strong>和<strong>一致性</strong>之间做取舍.</p>
<h3 id="最小同步副本数">最小同步副本数</h3>
<p><code>min.insync.replicas</code> 这个设置可以作用于broker和topic级别. 假如broker数为3, 最小同步副本数为2. 当2个同步副本中的一个出现问题, 集群便不会再接受生产者的发送消息请求. 同事客户端会收到<code>NotEnoughReplicasException</code>. 此时, 消费者还可以继续读取存在的数据.  唯一的同步副本变成只读.</p>
<h2 id="可靠系统中使用生产者">可靠系统中使用生产者</h2>
<h3 id="发送确认">发送确认</h3>
<p><code>acks</code> 可选0, 1或者all. 设置影响吞吐和一致性.</p>
<ul>
<li><code>acks=0</code> 意味着消息发送出去后就认为是成功写入topic.</li>
<li><code>acks=1</code> 发送后等待leader写入后确认</li>
<li><code>acks=all</code> 发送后等待所有副本写入后确认</li>
</ul>
<h3 id="重试">重试</h3>
<p><code>retries</code> 消息发送后会收到成功或者错误码. 错误有两种, 可重试的和不可重试的. 对于可重试的错误, 生产者会重复发送, 而<code>reties</code>控制重试的次数. 比如borker返回<code>LEADER_NOT_AVAILABLE</code>错误, 生产者会自动进行重试(retries不等于0), 因为broker之后会选择新的leader. 如果返回<code>INVALID_CONFIG</code>, 重试也不会解决问题.
同时<code>retries</code>有可能导致消息重复, 这就是Kafka消息的<code>at least once</code>保证. 在0.11.0.0之后, 提供了幂等的特性, 保证消息的<code>exactly one</code>. 对于跨数据中心的复制(比如MirrorMaker), 默认设置为<code>Integer.MAX_VALUE</code></p>
<h3 id="额外的错误处理">额外的错误处理</h3>
<p>使用生产者内置的重试是一个正确处理多种错误而不丢失消息的简单途径. 但是开发者还需要处理其他的错误, 比如:</p>
<ul>
<li>不可重试错误</li>
<li>发送之前的错误</li>
<li>场试完所有的重试次数后还是未成功发送.</li>
</ul>
<h2 id="可靠系统中使用消费者">可靠系统中使用消费者</h2>
<p><strong>已提交消息</strong>和<strong>已提交偏移量</strong>
完全不同的两个概念, 前者是对生产者有效, 后者是对消费者有效.</p>
<h3 id="重要设置">重要设置</h3>
<ul>
<li><code>group.id</code> 两个有相同<code>group.id</code>并且订阅同一个topic的消费者, 会分配到topic下分区的一个子集, 并且是独立的子集.</li>
<li><code>auto.offset.reset</code> 这个参数控制当broker端没有发现任何提交的偏移量的时候, 消费者应该从什么位置开始读取消息. 接受<code>earliest</code>和<code>latest</code>两种设置. <code>earliest</code>意思是会从0开始读取, 而<code>latest</code>意思是从最末尾开始.</li>
<li><code>enable.auto.commit</code> 按照时间计划提交偏移量或者代码中手动提交. 对consumer来说这是一个<strong>重大</strong>的决定. 自动提交会保证只提交循环中已经处理的数据, 但是有可能会在下次提交始前系统崩溃. 这就导致已经被处理的消息的偏移量没有提交到broker. 下次拉取的时候(consumer重新上线或者rebalance时候由其他消费者处理该分区)会重新拉取已经处理过的消息, <strong>重复消费</strong>. 假如你是将拉取的消息交由其他的线程处理, 那自动提交可能会到时消息被拉取, 却没有被处理. 自动提交的好处是吞吐量大.</li>
<li><code>auto.commit.interval.ms</code> 当<code>enable.auto.commit</code>设置为<strong>true</strong>的时候, 通过这个配置控制自动提交的时间间隔. 越大吞吐就越大, 一致性就越低. 越小, 则会增加提交的次数, 影响吞吐, 但是会提高一致性.</li>
</ul>
<h3 id="准确提交偏移量">准确提交偏移量</h3>
<h4 id="总是提交已经处理过得消息">总是提交已经处理过得消息</h4>
<p>假如你是在循环中处理所有的消息, 并且不需要维护跨多次轮询的状态, 会比较容易实现. 可以使用自动提交, 或者在轮询循环的末尾进行偏移量提交.</p>
<h4 id="提交频率是性能和系统崩溃时重复的消息数量间的取舍">提交频率是性能和系统崩溃时重复的消息数量间的取舍</h4>
<p>一次轮询循环中可以进行多次偏移量提交, 甚至每处理一条提交一次. 或者几个轮询提交一次. 提交会有性能上的开销, 类似生产者的<code>acks=all</code></p>
<h4 id="保证你清楚的了解将要提交什么偏移量">保证你清楚的了解将要提交什么偏移量</h4>
<p>常见的一个陷阱就是一次轮询循环中的偏移量提交了读到的最大偏移量, 而不是已经处理过得最大偏移量. 会导致消息丢失.</p>
<h3 id="再平衡">再平衡</h3>
<p>准确处理consumer的再平衡(consumer上线或者下线). 再平衡会引起先从消费者上摘取某些分区, 然后在分配某些分区. 通过实现RebalanceListener接口来实现控制.</p>
<h3 id="消费者可能需要重试">消费者可能需要重试</h3>
<p>某些场景下, 暂时不提交偏移量, 下次轮询的时候会重复拉取消息. 比如数据库连接暂时不可用的情况下.</p>
<h3 id="消费者可能需要维护状态">消费者可能需要维护状态</h3>
<p>某些场景下, 需要在多个轮询间存在聚合运算.</p>
<h3 id="处理长时间的处理">处理长时间的处理</h3>
<p>有些时候, 消息的处理耗时较长, 比如与其他系统交互或者进行比较复杂的运算.
某些Kafka版本的消费者, 两次轮询的间隔不能太长 (0.10.0.0之前版本的消费者没有单独的心跳进程, 是通过轮询同时达到心跳目的). 太长, 消费者则会被认为是下线, 会发生再平衡.</p>
<h3 id="有且只有一次的消息投递">有且只有一次的消息投递</h3>
<p>有些场景需要至少一次的语义(没有消息丢失); 而某些场景则需要有些只有一次的语义. 但是当前Kafka没有提供完美的有且只有一次的支持. 需要与其他系统结合一起实现, 比如使用唯一的key写入数据库或者redis等存储中.</p>

        </div>

        
        
        <div class="article-toc" >
            <h3></h3>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#复制">复制</a></li>
    <li><a href="#broker配置">Broker配置</a>
      <ul>
        <li><a href="#复制因子">复制因子</a></li>
        <li><a href="#脏副本的leader选举">脏副本的leader选举</a></li>
        <li><a href="#最小同步副本数">最小同步副本数</a></li>
      </ul>
    </li>
    <li><a href="#可靠系统中使用生产者">可靠系统中使用生产者</a>
      <ul>
        <li><a href="#发送确认">发送确认</a></li>
        <li><a href="#重试">重试</a></li>
        <li><a href="#额外的错误处理">额外的错误处理</a></li>
      </ul>
    </li>
    <li><a href="#可靠系统中使用消费者">可靠系统中使用消费者</a>
      <ul>
        <li><a href="#重要设置">重要设置</a></li>
        <li><a href="#准确提交偏移量">准确提交偏移量</a></li>
        <li><a href="#再平衡">再平衡</a></li>
        <li><a href="#消费者可能需要重试">消费者可能需要重试</a></li>
        <li><a href="#消费者可能需要维护状态">消费者可能需要维护状态</a></li>
        <li><a href="#处理长时间的处理">处理长时间的处理</a></li>
        <li><a href="#有且只有一次的消息投递">有且只有一次的消息投递</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
        
        

        


        
        <footer class="article-footer">
            <ul class="article-tag-list">
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="https://atbug.com//tags/kafka">Kafka
                    </a>
                </li>
                
            </ul>
        </footer>
        <div class="article-entry">
            <hr>
            <p>文章同步发送到公众号：云编码 (微信号：sevenfeet)。</p>
            <p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/23/qrcode.jpg" alt="qrcode"></p>
        </div>
        
    </div>
    
<nav id="article-nav">
    
    <a href="../java-serval-serializer-benchmark/" id="article-nav-newer" class="article-nav-link-wrap">
        <div class="article-nav-title"><span>&lt;</span>&nbsp;
            Java序列化工具性能对比
        </div>
    </a>
    
    
    <a href="../spring-cloud-eureka-client-source-code-analysis/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">Spring Cloud - Eureka Client源码分析&nbsp;<span>&gt;</span></div>
    </a>
    
</nav>


</article>

        
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "addozhang" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 Addo Zhang
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-47966140-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css" integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>
