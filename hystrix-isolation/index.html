<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.57.2" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Hystrix工作原理二 &middot; 乱世浮生</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://localhost:1313/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://localhost:1313/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://localhost:1313/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://localhost:1313/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://localhost:1313/"><h1>乱世浮生</h1></a>
      <p class="lead">
       知我者谓我何忧 不知我者谓我何求. 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://localhost:1313/">Home</a> </li>
        <li><a href="/"> Home </a></li><li><a href="/post/"> Archives </a></li><li><a href="/tags/"> Tags </a></li><li><a href="/categories/"> Categories </a></li><li><a href="/about/"> About </a></li>
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Hystrix工作原理二</h1>
  <time datetime=2018-06-24T16:18:52Z class="post-date">Sun, Jun 24, 2018</time>
  

<h2 id="隔离策略">隔离策略</h2>

<h3 id="线程和线程池">线程和线程池</h3>

<p>客户端(库, 网络调用等)在各自的线程上运行. 这种做法将他们与调用线程隔开, 因此调用者可以从一个耗时的依赖调用&rdquo;离开(walk away)&rdquo;</p>

<p>Hystrix使用单独的, 每个依赖的线程池作为约束任何给定依赖的一种方式, 因此潜在执行的延迟将仅在该池中使可用线程饱和.</p>

<p><img src="http://7xvxng.com1.z0.glb.clouddn.com/15280741661560.png" alt="" /></p>

<p>如果不试用线程池可以保护你免受故障的影响, 但是这需要客户端可信任地快速失败(网络连接/读取超时, 重试的配置)并始终表现良好.</p>

<p>在Hystrix的设计中, Netflix选择试用线程和线程池来达到隔离的目的, 原因有:</p>

<ul>
<li>很多应用程序调用了由很多不同的团队开发的许多(有时超过1000)不同的后端服务</li>
<li>每个服务都各自提供了其客户端库</li>
<li>客户端库不断地在更新</li>
<li>客户端库可能被添加使用新的网络调用</li>
<li>客户端库的逻辑中可能包含重试, 数据解析, 缓存(内存或者跨网络)和其他类似的行为</li>
<li>客户端库更类似于一个黑盒, 其实现细节, 网络访问模式, 默认配置等是对使用者不透明的</li>
<li>在实际的生产问题中, 根源经常是 &ldquo;有些东西改变了, 配置应该被修改&rdquo; 或者 &ldquo;客户端库修改了逻辑&rdquo;</li>
<li>即使客户端没有改变, 服务端自身发生了变会员. 这种变化会是客户端设置无效而影响性能特性</li>
<li>传递依赖会引入其他客户端, 这些客户端不是可预期的, 也可能没有被正确地配置</li>
<li>大多数网络访问是同步的</li>
<li>失败和延迟也可能发生在客户端, 不只是网络调用</li>
</ul>

<p><img src="http://7xvxng.com1.z0.glb.clouddn.com/15274259800386.png" alt="" /></p>

<h4 id="线程池的优势">线程池的优势</h4>

<ul>
<li>该应用程序完全免受失控客户端库的保护. 给定依赖库的线程池可以填满而不会影响应用程序的其余部分.</li>
<li>应用程序可以接受风险低得多的新客户端库. 如果发生问题, 它会与其他依赖库隔离, 不会影响其他的依赖库</li>
<li>当发生故障的客户端再次健康时, 线程池将进行清理, 应用程序会立即恢复健康的性能, 而不是整个Tomcat容器不堪重负的长时间恢复.</li>
<li>如果客户端库配置错误, 线程池的运行状况将很快证明这一点(通过增加错误, 延迟, 超时, 拒绝等), 并且你可以在不影响应用程序功能的情况下处理它(通常通过动态属性进行实时修改).</li>
<li>如果客户端服务改变了性能特征(经常发生会以成为一个问题), 从而导致需要调整属性(增加/减少超时, 更改重试等), 这通过线程池指标(错误, 延迟, 超时, 拒绝), 并且可以在不影响其他客户端, 请求或用户的情况下进行处理.</li>
<li>除了隔离优势外, 拥有专用线程池还提供了内置并发性, 可用于在同步客户端库之上构建异步特性(类似于Netflix API在Hystrix命令之上构建反应式, 完全异步的Java API).</li>
</ul>

<p>简而言之, 由线程池提供的隔离功能可以使客户端库和子系统性能特性的不断变化和动态组合得到适度处理, 而不会造成中断.</p>

<p><strong>注意</strong>: 尽管单独的线程提供了隔离, 但你的底层客户端代码也应该有超时 和/或 响应线程中断, 以便它不会无限制地阻塞并使Hystrix线程池饱和.</p>

<p><img src="http://7xvxng.com1.z0.glb.clouddn.com/15274259098702.png" alt="" /></p>

<p><strong>线程池的缺点</strong></p>

<p>线程池的主要缺点是增加了计算开销, 每个Command的执行设计到队列, 调度和Command单独运行的线程的上下文的切换.</p>

<p>在设计这个系统时, Netflix决定接受这种开销, 以换取其提供的好处, 并认为它足够小, 不会对成本或性能产生重大影响,.</p>

<p><strong>线程成本</strong></p>

<p>Hystrix在子线程上执行construct()或run()方法时测量延迟, 以及父线程上的总端到端时间.  通过这种方式, 你可以看到Hystrix开销的成本(线程, 指标, 日志记录, 断路器等).</p>

<p>Netflix API每天使用线程隔离处理10亿多Hystrix Command执行.  每个API实例都有40多个线程池, 每个线程池中有5-20个线程(大多数设置为10).</p>

<h3 id="信号量">信号量</h3>

<p>你可以使用信号量(或计数器)来限制对任何给定依赖项的并发调用数量, 而不是使用线程池/队列大小. 这允许Hystrix在不使用线程池的情况下卸载负载. 如果你信任下客户端, 而你只想要卸载, 你可以使用这种方法.</p>

<p><code>HystrixCommand</code>和<code>HystrixObservableCommand</code>支持2个地方的信号量:</p>

<p><strong>回退:</strong> 当Hystrix执行回退时, 它总是在调用Tomcat线程上执行回退
<strong>执行:</strong> 如果将属性<code>execution.isolation.strategy</code>设置为<code>SEMAPHORE</code>, 则Hystrix将使用信号而不是线程来限制调用该命令的并发父线程的数量.</p>

<p>你可以通过动态属性来配置这两种信号量的使用, 这些动态属性定义了可以执行多少个并发线程. 在调整线程池大小时, 你应该使用类似的计算来调整它们的大小(内存调用返回的次毫秒时间可以在信号量仅为1或2的情况下执行超过5000rps, 但默认值为10).</p>

<p>一旦达到限制, 信号量拒绝将开始, 但填充信号量的线程不能离开.</p>

<p>翻译自<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">How it Works</a></p>

</div>

<h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "addozhang" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-47966140-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
