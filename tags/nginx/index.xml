<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nginx on 乱世浮生</title><link>https://atbug.com/tags/nginx/</link><description>Recent content in nginx on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 06 Nov 2018 09:24:24 +0000</lastBuildDate><atom:link href="https://atbug.com/tags/nginx/index.xml" rel="self" type="application/rss+xml"/><item><title>Nginx实现Elasticsearch的HTTP基本认证</title><link>https://atbug.com/elasticsearch-http-basic-authentication-via-nginx/</link><pubDate>Tue, 06 Nov 2018 09:24:24 +0000</pubDate><guid>https://atbug.com/elasticsearch-http-basic-authentication-via-nginx/</guid><description>
Elasticssearch的HTTP基本认证实现有两种方案: x-pack和nginx反向代理. 前者收费, 后者不太适合生产使用. 如果仅仅是开发测试, 第二种完全足够. 创建密码 htpasswd -bc ./passwd [username] [password] Docker compose version:&amp;#39;3&amp;#39;services:elasticsearch:image:elasticsearch:5.5.2container_name:elasticsearchrestart:unless-stoppedvolumes:- /tmp/elasticsearch:/usr/share/elasticsearch/datanginx:image:nginx:latestcontainer_name:elasticsearch-proxyports:- 9200:9200links:- elasticsearchvolumes:- ./passwd:/etc/nginx/.passwd- ./default.conf:/etc/nginx/conf.d/default.confnginx配置文件 upstream es { server elasticsearch:9200; keepalive 15; } server { listen 9200; server_name localhost; access_log /dev/stdout; error_log /dev/stdout; location / { auth_basic &amp;#34;Administrator’s Area&amp;#34;; auth_basic_user_file /etc/nginx/.passwd; proxy_http_version 1.1; proxy_set_header Connection &amp;#34;Keep-Alive&amp;#34;; proxy_set_header Proxy-Connection &amp;#34;Keep-Alive&amp;#34;; proxy_pass http://es; } location /health { access_log off; return 200 &amp;#34;healthy\n&amp;#34;; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to</description></item><item><title>Kubernetes中的Nginx动态解析</title><link>https://atbug.com/nginx-dynamic-domain-parse-in-kubernetes/</link><pubDate>Wed, 30 May 2018 12:10:32 +0000</pubDate><guid>https://atbug.com/nginx-dynamic-domain-parse-in-kubernetes/</guid><description>
背景 Nginx运行在kubernets中, 反向代理service提供服务. kubernetes版本v1.9.1+a0ce1bc657. 问题: 配置如下: location ^~/info { proxy_pass: http://serviceName:port; } 删除并重建Service的时候, nginx会出现下面的问题: connect() failed (113: No route to host) &amp;hellip; upstream: &amp;ldquo;xxxxx&amp;rdquo; 分析 通过google发现, 是nginx的dns解析方案的问题. nginx官方的说明: If the domain name can’t be resolved, NGINX fails to start or reload its configuration. NGINX caches the DNS records until the next restart or configuration reload, ignoring the records’ TTL values. We can’t specify another load‑balancing algorithm, nor can we configure passive health checks or other features defined by parameters to the server directive, which we’ll describe in the next section. 意思是说, nginx在启动的时候就会解析proxy_pass后的域名, 并把ip缓存下来</description></item></channel></rss>