<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CNI on 乱世浮生</title><link>https://atbug.com/tags/cni/</link><description>Recent content in CNI on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 18 Mar 2023 02:25:17 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/cni/index.xml" rel="self" type="application/rss+xml"/><item><title>追踪 Kubernetes 中的数据包</title><link>https://atbug.com/tracing-network-packets-in-kubernetes/</link><pubDate>Sat, 18 Mar 2023 02:25:17 +0800</pubDate><guid>https://atbug.com/tracing-network-packets-in-kubernetes/</guid><description>网络和操作系统内核，对我来说是既陌生又满是吸引，希望能够拨开层层迷雾找到背后的真相。
在 上一篇文章 中我深入探讨了 Kubernetes 网络模型，这次我想更深入一点：了解数据包在 Kubernetes 中的传输，为学习 Kubernetes 的 eBPF 网络加速做准备，加深对网络和操作系统内核的理解。 文中可能有疏漏之处，还望大家赐教。
在开始之前，我可以用一句话来总结我的学习成果：数据包的流转其实就是一个网络套接字描述符（Socket File Descriptor，中文有点冗长，以下简称 socket fd）的寻址过程。 它不是简单的指 socket fd 的内存地址，还包括它的网络地址。
在 Unix 和类 Unix 系统中，一切皆文件，也可以通过文件描述符来操作 socket。
基础知识 数据包 既然要讨论数据包的流转，先看看什么是数据包。
网络数据包（network packet），也称为网络数据报（network datagram）或网络帧（Network frame），是通过计算机网络传输的数据单位。拿最常见的 TCP 数据包来看包含如下几个部分：
Ethernet header：链路层信息，主要包括目的 MAC 地址和源 MAC 地址，以及报文的格式，这里是 IP 包。 IP header：网络层信息，主要包括长度、源 IP 地址和目的 IP 地址以及报文的格式，当然这里必须是 TCP 包。 TCP header：传输层信息，包括源端口和目的端口。 数据：一般是第 7 层的数据，比如 HTTP 等。 这里没有介绍的 checksum 和 FCS 通常是用来检查数据包在传输过程中是否被篡改或者发生了错误。</description></item><item><title>从 Flannel 学习 Kubernetes overlay 网络</title><link>https://atbug.com/cross-node-traffic-on-flannel-vxlan-network/</link><pubDate>Thu, 15 Dec 2022 07:00:13 +0800</pubDate><guid>https://atbug.com/cross-node-traffic-on-flannel-vxlan-network/</guid><description>这是 Kubernetes 网络学习的第四篇笔记。
深入探索 Kubernetes 网络模型和网络通信 认识一下容器网络接口 CNI 源码分析：从 kubelet、容器运行时看 CNI 的使用 从 Flannel 学习 Kubernetes VXLAN 网络（本篇） Kubernetes 网络学习之 Cilium 与 eBPF &amp;hellip; Flannel 介绍 Flannel 是一个非常简单的 overlay 网络（VXLAN），是 Kubernetes 网络 CNI 的解决方案之一。Flannel 在每台主机上运行一个简单的轻量级 agent flanneld 来监听集群中节点的变更，并对地址空间进行预配置。Flannel 还会在每台主机上安装 vtep flannel.</description></item><item><title>源码解析：从 kubelet、容器运行时看 CNI 的使用</title><link>https://atbug.com/how-kubelete-container-runtime-work-with-cni/</link><pubDate>Thu, 08 Dec 2022 22:32:25 +0800</pubDate><guid>https://atbug.com/how-kubelete-container-runtime-work-with-cni/</guid><description>这是 Kubernetes 网络学习的第三篇笔记。
深入探索 Kubernetes 网络模型和网络通信 认识一下容器网络接口 CNI 源码分析：从 kubelet、容器运行时看 CNI 的使用（本篇） 从 Flannel 学习 Kubernetes VXLAN 网络 Kubernetes 网络学习之 Cilium 与 eBPF &amp;hellip; 在上一篇中，通过对 CNI 规范的解读了解了网络配置的操作和相关的流程。在网络的几个操作中除了 CNI_COMMAND 外，有另外三个参数几乎每次都要提供 CNI_CONTAINERID、CNI_IFNAME 和 CNI_NETNS，这些参数无外乎都来自容器运行时。这篇将结合 Kubernetes 和 Containerd 源码，来分析一下 CNI 的使用。
Kubernetes 的源码来自分支 release-1.</description></item><item><title>认识一下容器网络接口 CNI</title><link>https://atbug.com/deep-dive-cni-spec/</link><pubDate>Tue, 06 Dec 2022 19:53:46 +0800</pubDate><guid>https://atbug.com/deep-dive-cni-spec/</guid><description>写在最前，周末写到这篇的时候我就发现可能是给自己挖了很大的坑，整个 Kubernetes 网关相关的内容会非常复杂且庞大。
深入探索 Kubernetes 网络模型和网络通信 认识一下容器网络接口 CNI（本篇） 源码分析：从 kubelet、容器运行时看 CNI 的使用 从 Flannel 学习 Kubernetes VXLAN 网络 Kubernetes 网络学习之 Cilium 与 eBPF &amp;hellip; 看自己能学到哪一步~
在 《深入探索 Kubernetes 网络模型和网络通信》 文章中，我们介绍了网络命名空间（network namespace） 如何在 Kubernetes 网络模型中工作，通过示例分析 pod 间的流量传输路径。整个传输过程需要各种不同组件的参与才完成，而这些组件与 pod 相同的生命周期，跟随 pod 的创建和销毁。容器的维护由 kubelet 委托给容器运行时（container runtime）来完成，而容器的网络命名空间则是由容器运行时委托网络插件共同完成。</description></item><item><title>深入探索 Kubernetes 网络模型和网络通信</title><link>https://atbug.com/deep-dive-k8s-network-mode-and-communication/</link><pubDate>Sun, 04 Dec 2022 08:48:11 +0800</pubDate><guid>https://atbug.com/deep-dive-k8s-network-mode-and-communication/</guid><description>这是 Kubernetes 网络学习的第一篇笔记。
深入探索 Kubernetes 网络模型和网络通信（本篇） 认识一下容器网络接口 CNI 源码分析：从 kubelet、容器运行时看 CNI 的使用 从 Flannel 学习 Kubernetes VXLAN 网络 Kubernetes 网络学习之 Cilium 与 eBPF Kubernetes 定义了一种简单、一致的网络模型，基于扁平网络结构的设计，无需将主机端口与网络端口进行映射便可以进行高效地通讯，也无需其他组件进行转发。该模型也使应用程序很容易从虚拟机或者主机物理机迁移到 Kubernetes 管理的 pod 中。
这篇文章主要深入探索 Kubernetes 网络模型，并了解容器、pod 间如何进行通讯。对于网络模型的实现将会在后面的文章介绍。
Kubernetes 网络模型 该模型定义了：
每个 pod 都有自己的 IP 地址，这个 IP 在集群范围内可达 Pod 中的所有容器共享 pod IP 地址（包括 MAC 地址），并且容器之前可以相互通信（使用 localhost） Pod 可以使用 pod IP 地址与集群中任一节点上的其他 pod 通信，无需 NAT Kubernetes 的组件之间可以相互通信，也可以与 pod 通信 网络隔离可以通过网络策略实现 上面的定义中提到了几个相关的组件：</description></item></channel></rss>