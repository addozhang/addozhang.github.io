<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Netflix on 乱世浮生</title><link>https://atbug.com/tags/netflix/</link><description>Recent content in Netflix on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 05 Jan 2020 14:14:03 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/netflix/index.xml" rel="self" type="application/rss+xml"/><item><title>神秘的Eureka自我保护</title><link>https://atbug.com/translation-the-mystery-of-eurekas-self-preservation/</link><pubDate>Sun, 05 Jan 2020 14:14:03 +0800</pubDate><guid>https://atbug.com/translation-the-mystery-of-eurekas-self-preservation/</guid><description>
&lt;p>本文翻译自&lt;a href="https://dzone.com/articles/the-mystery-of-eurekas-self-preservation">The Mystery of Eureka Self-Preservation&lt;/a>&lt;/p>
&lt;p>根据CAP定理, Eureka是一个AP系统, 这就导致了在网络分区期间多个注册表中的信息不一致. 自我保护功能则是为了尽可能降低这种不一致.&lt;/p>
&lt;h2 id="自我保护的定义">自我保护的定义&lt;/h2>
&lt;p>自我保护(self preservation)是Eureka的一项功能, Eureka注册表在未收到实例的心跳情况超过一定阈值时停止驱逐过期的实例.&lt;/p>
&lt;h3 id="从一个健康的系统开始">从一个健康的系统开始&lt;/h3>
&lt;p>把下面看成一个健康的系统&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/n5wZMX.jpg" alt="The healthy system — before encountering network partition">&lt;/p>
&lt;p>假设所有的微服务都处于健康的状态并成功注册到Eureka注册表中.&lt;/p>
&lt;p>多个注册表间会同步注册表记录, 所有的微服务实例都处于UP状态. 假设实例2从注册中心发现里实例4, 并调用实例4上的服务.&lt;/p>
&lt;h3 id="突发网络分区">突发网络分区&lt;/h3>
&lt;p>假设出现了网络分区, 系统变成下面的状态.&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/MznWWr.jpg" alt="During network partition  -  enters self-preservation">&lt;/p>
&lt;p>由于网络分区, 实例4和5丢失了注册中心的连接, 但是实例2仍然可以连接到实例4. Eureka服务端因为没有收到实例4和5的心跳(超过一定时间后), 将他们驱逐. 然后Eureka服务端意识到突然丢失了超过15%(2/5)的心跳, 因此其进入&lt;em>自我保护&lt;/em>模式&lt;/p>
&lt;p>从此时开始, Eureka服务端不在驱逐任何实例, 即使实例真正的下线了.&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/7c9eHt.jpg" alt="During self-preservation  -  stops expiring instances">&lt;/p>
&lt;p>实例3下线, 但其始终存在注册表中.&lt;/p>
&lt;p>但此时注册表还会接受新实例的注册.&lt;/p>
&lt;h2 id="自我保护的基本原理">自我保护的基本原理&lt;/h2>
&lt;p>自我保护功能在下面两种情况下是合理的:&lt;/p>
&lt;ul>
&lt;li>Eureka服务端因为弱网分区问题没有收到心跳(这并不意味着客户端下线), 但是这种问题可能会很快被修复.&lt;/li>
&lt;li>即使Eureka服务端和客户端的连接断开, 客户端间还可以继续保持连接. (比如上面实例2仍然可以连接到实例4)&lt;/li>
&lt;/ul>
&lt;h3 id="配置-默认">配置 (默认)&lt;/h3>
&lt;p>下面的配置会直接或间接影响到自我保护的行为.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.instance.lease-renewal-interval-in-seconds = 30
&lt;/code>&lt;/pre>&lt;/div>&lt;p>客户端发送心跳的频率. 服务端会以此在计算期望收到心跳数, 默认30秒&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.instance.lease-expiration-duration-in-seconds = 90
&lt;/code>&lt;/pre>&lt;/div>&lt;p>多长时间未收到心跳后, 实例才可以被驱逐, 默认90秒&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.eviction-interval-timer-in-ms = 60 * 1000
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Eureka服务端驱逐操作的执行频率, 默认60秒&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.renewal-percent-threshold = 0.85
&lt;/code>&lt;/pre>&lt;/div>&lt;p>期望心跳数达到该阈值后, 就会进入自我保护模式, 默认0.85&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.renewal-threshold-update-interval-ms = 15 * 60 * 1000
&lt;/code>&lt;/pre>&lt;/div>&lt;p>期望心跳数的计算间隔, 默认15分钟&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.enable-self-preservation = true
&lt;/code>&lt;/pre>&lt;/div>&lt;p>是否允许Eureka服务端进入自我保护模式, 默认开启&lt;/p>
&lt;h2 id="理解配置">理解配置&lt;/h2>
&lt;p>Eureka服务端在&amp;quot;上一分钟实际收到的心跳数&amp;quot;小于&amp;quot;每分钟期望的心跳数&amp;quot;时就会进入自我保护模式&lt;/p>
&lt;h3 id="期望的每分钟心跳数">期望的每分钟心跳数&lt;/h3>
&lt;p>假设&lt;code>renewal-percent-threshold&lt;/code>设置为&lt;code>0.85&lt;/code>&lt;/p>
&lt;p>计算方式:&lt;/p>
&lt;ul>
&lt;li>单个实例每分钟期望的心跳数是: 2&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>N个实例的每分钟期望的心跳数: 2 * N&lt;/li>
&lt;li>期望的上一分钟最小心跳数: 2 * N * 0.85&lt;/li>
&lt;/ul>
&lt;h3 id="实际的每分钟心跳数">实际的每分钟心跳数&lt;/h3>
&lt;p>正如上面所述, 两个定时调度器独立地运行计算&lt;em>实际&lt;/em>和&lt;em>期望&lt;/em>的心跳数. 此外还有另一个调度任务&lt;code>EvictionTask&lt;/code>进行结果比较, 并识别当前系统是否在自我保护状态.&lt;/p>
&lt;p>这个调度任务每个&lt;code>eviction-interval-timer-in-ms&lt;/code>时间执行一次, 并决定是否驱逐实例.&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;ul>
&lt;li>基于使用的经验, 大多数情况下自我保护模式都是错误的, 它错误地认为一些下线的微服务实例是不良的网络分区&lt;/li>
&lt;li>自我保护永远不会过期, 除非下线的实例重新上线&lt;/li>
&lt;li>如果启用了自我保留, 则无法对实例的心跳间隔进行微调, 因为自我保护在计算期望心跳数是按照30s间隔来计算的&lt;/li>
&lt;li>除非环境中经常出现类似的网络分区故障, 否则建议关闭&lt;/li>
&lt;/ul>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>这个值是固定的, 源于默认的心跳间隔是30s, 故每分钟2次. 见eureka-core-1.7.2的&lt;code>AbstractInstanceRegistryL226&lt;/code> &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Hystrix工作原理三</title><link>https://atbug.com/hystrix-exception-handling/</link><pubDate>Sun, 24 Jun 2018 16:20:16 +0000</pubDate><guid>https://atbug.com/hystrix-exception-handling/</guid><description>
&lt;h2 id="异常处理">异常处理&lt;/h2>
&lt;h3 id="hystrix异常类型">Hystrix异常类型&lt;/h3>
&lt;ul>
&lt;li>HystrixRuntimeException&lt;/li>
&lt;li>HystrixBadRequestException&lt;/li>
&lt;li>HystrixTimeoutException&lt;/li>
&lt;li>RejectedExecutionException&lt;/li>
&lt;/ul>
&lt;h4 id="hystrixruntimeexception">HystrixRuntimeException&lt;/h4>
&lt;p>&lt;code>HystrixCommand&lt;/code>失败时抛出, 不会触发fallback.&lt;/p>
&lt;h4 id="hystrixbadrequestexception">HystrixBadRequestException&lt;/h4>
&lt;p>用提供的参数或状态表示错误的异常, 而不是执行失败. 与其他&lt;code>HystrixCommand&lt;/code>抛出的异常不同, 这个异常不会触发&lt;code>fallback&lt;/code>, 也不会记录进&lt;code>failure&lt;/code>的指标, 因而也不会触发断路器,&lt;/p>
&lt;p>应该在用户输入引起的错误是抛出, 否则会它与容错和后退行为的目的相悖.&lt;/p>
&lt;p>&lt;strong>不会触发fallback, 也不会记录到错误的指标中, 也不会触发断路器&lt;/strong>.&lt;/p>
&lt;h4 id="rejectedexecutionexception">RejectedExecutionException&lt;/h4>
&lt;p>线程池发生&lt;code>reject&lt;/code>时抛出&lt;/p>
&lt;h4 id="hystrixtimeoutexception">HystrixTimeoutException&lt;/h4>
&lt;p>在&lt;code>HystrixCommand.run()&lt;/code>或者&lt;code>HystrixObservableCommand.construct()&lt;/code>时抛出, 会记录&lt;code>timeout&lt;/code>的次数. 如果希望某些类型的失败被记录为&lt;code>timeout&lt;/code>, 应该将这些类型的失败包装为&lt;code>HystrixTimeoutException&lt;/code>&lt;/p>
&lt;h3 id="异常处理-1">异常处理&lt;/h3>
&lt;p>&lt;code>ignoreExceptions&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">final&lt;/span> &lt;span class="n">Func1&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">handleFallback&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Func1&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">call&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Throwable&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">circuitBreaker&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">markNonSuccess&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">Exception&lt;/span> &lt;span class="n">e&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getExceptionFromThrowable&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">executionResult&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">executionResult&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setExecutionException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">RejectedExecutionException&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">handleThreadPoolRejectionViaFallback&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">HystrixTimeoutException&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">handleTimeoutViaFallback&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">HystrixBadRequestException&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">handleBadRequestByEmittingError&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">HystrixBadRequestException&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">eventNotifier&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">markEvent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HystrixEventType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">BAD_REQUEST&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">commandKey&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">handleFailureViaFallback&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="feign中响应状态码处理">Feign中响应状态码处理&lt;/h4>
&lt;p>Feign使用&lt;code>SynchronousMethodHandler&lt;/code>做请求的执行和响应的处理. 响应处理的部分, 对&lt;code>[200, 300)&lt;/code>区间的状态, 会将response返回; 如果是&lt;code>404&lt;/code>, 根据&lt;code>@FeignClient&lt;/code>中&lt;code>decode404&lt;/code>(默认为false)和方法返回值判断是否熔断, 如果响应返回&lt;code>404&lt;/code>, &lt;code>decode&lt;/code>为&lt;code>false&lt;/code>, 同时方法返回值不是&lt;code>void&lt;/code>, 会包装成&lt;code>FeignException&lt;/code>抛出; 其他的状态, 通过包装成&lt;code>FeignException&lt;/code>抛出.&lt;/p>
&lt;p>&lt;code>FeignException&lt;/code>是&lt;code>RuntimeException&lt;/code>的实现, 如果没有ignore的话, 会计入熔断器的计算中.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">final&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SynchronousMethodHandler&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">MethodHandler&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Object&lt;/span> &lt;span class="nf">executeAndDecode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RequestTemplate&lt;/span> &lt;span class="n">template&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">Throwable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">status&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">200&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">status&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">300&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">metadata&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">returnType&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">decode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">decode404&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">status&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">404&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="kt">void&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">metadata&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">returnType&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">decode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="n">errorDecoder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">decode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">metadata&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">configKey&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="ribbon中响应状态码处理">Ribbon中响应状态码处理&lt;/h4>
&lt;p>在Zuul中, 路由使用&lt;code>Ribbon&lt;/code>做负载均衡, 同时使用&lt;code>Hystrix&lt;/code>做断路器, 使用&lt;code>RibbonCommand&lt;/code>接口的实现. &lt;code>RibbonCommand&lt;/code>的实现&lt;strong>并没有对响应编码封装异常, 因此也不会触发熔断器&lt;/strong>.&lt;/p>
&lt;p>&lt;code>AbstractRibbonCommand&lt;/code>是&lt;code>RibbonCommand&lt;/code>的抽象实现, 所有其他实现的父类. 核心&lt;code>run()&lt;/code>方法并没有针对响应编码重新封装异常.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">AbstractRibbonCommand&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">LBC&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">AbstractLoadBalancerAwareClient&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">RQ&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">RS&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">RQ&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">ClientRequest&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">RS&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">HttpResponse&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="kd">extends&lt;/span> &lt;span class="n">HystrixCommand&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">ClientHttpResponse&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">RibbonCommand&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="n">ClientHttpResponse&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">Exception&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">RequestContext&lt;/span> &lt;span class="n">context&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">RequestContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getCurrentContext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">RQ&lt;/span> &lt;span class="n">request&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">createRequest&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">RS&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">boolean&lt;/span> &lt;span class="n">retryableClient&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">client&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">AbstractLoadBalancingClient&lt;/span>
&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">AbstractLoadBalancingClient&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">client&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">isClientRetryable&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="n">ContextAwareRequest&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">retryableClient&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">response&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">execute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">config&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">response&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">executeWithLoadBalancer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">config&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ribbonResponse&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// Explicitly close the HttpResponse if the Hystrix command timed out to
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// release the underlying HTTP connection held by the response.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isResponseTimedOut&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">close&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RibbonHttpResponse&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Observable.error(ex)&lt;/code>会捕获&lt;code>run()&lt;/code>方法抛出的异常.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">HystrixCommand&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">AbstractCommand&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">HystrixExecutable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">HystrixInvokableInfo&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">HystrixObservable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">getExecutionObservable&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">defer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Func0&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">call&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">just&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Throwable&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ex&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}).&lt;/span>&lt;span class="na">doOnSubscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Action0&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">call&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// Save thread on which we get subscribed so that we can interrupt it later if needed
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">executionThread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">});&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="hystrix-超时处理">Hystrix 超时处理&lt;/h2>
&lt;p>在Hystrix版本1.4之前, Seamphore策略是不支持超时的. 目前&lt;code>spring-cloud-netflix&lt;/code>的1.4.4中使用的是1.5.12&lt;/p>
&lt;p>如果开启了timeout, HystrixCommand会&lt;code>lift&lt;/code>一个&lt;code>HystrixObservableTimeoutOperator&lt;/code>到&lt;code>Observable&lt;/code>中.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">AbstractCommand&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">HystrixInvokableInfo&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">HystrixObservable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">executeCommandAndObserve&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kd">final&lt;/span> &lt;span class="n">AbstractCommand&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">_cmd&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="n">Observable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">execution&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">executionTimeoutEnabled&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">execution&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">executeCommandWithSpecifiedIsolation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">_cmd&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">lift&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">HystrixObservableTimeoutOperator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;(&lt;/span>&lt;span class="n">_cmd&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">execution&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">executeCommandWithSpecifiedIsolation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">_cmd&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">execution&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">doOnNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">markEmits&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">doOnCompleted&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">markOnCompleted&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">onErrorResumeNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">handleFallback&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">doOnEach&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">setRequestContext&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个&lt;code>HystrixObservableTimeoutOperator&lt;/code>会添加注册&lt;code>TimeListener&lt;/code>. &lt;code>TimeListener&lt;/code>是以&lt;code>tick&lt;/code>的方式运行, 即启动一个线程延迟&lt;code>executionTimeoutInMilliseconds&lt;/code>运行, 然后每次在&lt;code>executionTimeoutInMilliseconds + n * executionTimeoutInMilliseconds&lt;/code>时运行.&lt;/p>
&lt;p>如果判断操作超时? 看&lt;code>tick&lt;/code>方法的实现, 线程每次运行时, 尝试修改Command的状态从&lt;code>NOT_EXECUTED&lt;/code>到&lt;code>TIMED_OUT&lt;/code>. 如果成功, 说明运行超时. 最后抛出&lt;code>HystrixTimeoutException&lt;/code>异常, 被&lt;code>handleFallback&lt;/code>处理.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath
&lt;/span>&lt;span class="c1">// otherwise it means we lost a race and the run() execution completed or did not start
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">originalCommand&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isCommandTimedOut&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">compareAndSet&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TimedOutStatus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">NOT_EXECUTED&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TimedOutStatus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">TIMED_OUT&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// report timeout failure
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">originalCommand&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">eventNotifier&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">markEvent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HystrixEventType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">TIMEOUT&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">originalCommand&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">commandKey&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// shut down the original request
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">unsubscribe&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">HystrixContextRunnable&lt;/span> &lt;span class="n">timeoutRunnable&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HystrixContextRunnable&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">originalCommand&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">concurrencyStrategy&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">hystrixRequestContext&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Runnable&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">child&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">onError&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">HystrixTimeoutException&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">});&lt;/span>
&lt;span class="n">timeoutRunnable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">run&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">//if it did not start, then we need to mark a command start for concurrency metrics, and then issue the timeout
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Hystrix工作原理二</title><link>https://atbug.com/hystrix-isolation/</link><pubDate>Sun, 24 Jun 2018 16:18:52 +0000</pubDate><guid>https://atbug.com/hystrix-isolation/</guid><description>
&lt;h2 id="隔离策略">隔离策略&lt;/h2>
&lt;h3 id="线程和线程池">线程和线程池&lt;/h3>
&lt;p>客户端(库, 网络调用等)在各自的线程上运行. 这种做法将他们与调用线程隔开, 因此调用者可以从一个耗时的依赖调用&amp;quot;离开(walk away)&amp;quot;&lt;/p>
&lt;p>Hystrix使用单独的, 每个依赖的线程池作为约束任何给定依赖的一种方式, 因此潜在执行的延迟将仅在该池中使可用线程饱和.&lt;/p>
&lt;p>&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15280741661560.png" alt="">&lt;/p>
&lt;p>如果不试用线程池可以保护你免受故障的影响, 但是这需要客户端可信任地快速失败(网络连接/读取超时, 重试的配置)并始终表现良好.&lt;/p>
&lt;p>在Hystrix的设计中, Netflix选择试用线程和线程池来达到隔离的目的, 原因有:&lt;/p>
&lt;ul>
&lt;li>很多应用程序调用了由很多不同的团队开发的许多(有时超过1000)不同的后端服务&lt;/li>
&lt;li>每个服务都各自提供了其客户端库&lt;/li>
&lt;li>客户端库不断地在更新&lt;/li>
&lt;li>客户端库可能被添加使用新的网络调用&lt;/li>
&lt;li>客户端库的逻辑中可能包含重试, 数据解析, 缓存(内存或者跨网络)和其他类似的行为&lt;/li>
&lt;li>客户端库更类似于一个黑盒, 其实现细节, 网络访问模式, 默认配置等是对使用者不透明的&lt;/li>
&lt;li>在实际的生产问题中, 根源经常是 &amp;ldquo;有些东西改变了, 配置应该被修改&amp;rdquo; 或者 &amp;ldquo;客户端库修改了逻辑&amp;rdquo;&lt;/li>
&lt;li>即使客户端没有改变, 服务端自身发生了变会员. 这种变化会是客户端设置无效而影响性能特性&lt;/li>
&lt;li>传递依赖会引入其他客户端, 这些客户端不是可预期的, 也可能没有被正确地配置&lt;/li>
&lt;li>大多数网络访问是同步的&lt;/li>
&lt;li>失败和延迟也可能发生在客户端, 不只是网络调用&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15274259800386.png" alt="">&lt;/p>
&lt;h4 id="线程池的优势">线程池的优势&lt;/h4>
&lt;ul>
&lt;li>该应用程序完全免受失控客户端库的保护. 给定依赖库的线程池可以填满而不会影响应用程序的其余部分.&lt;/li>
&lt;li>应用程序可以接受风险低得多的新客户端库. 如果发生问题, 它会与其他依赖库隔离, 不会影响其他的依赖库&lt;/li>
&lt;li>当发生故障的客户端再次健康时, 线程池将进行清理, 应用程序会立即恢复健康的性能, 而不是整个Tomcat容器不堪重负的长时间恢复.&lt;/li>
&lt;li>如果客户端库配置错误, 线程池的运行状况将很快证明这一点(通过增加错误, 延迟, 超时, 拒绝等), 并且你可以在不影响应用程序功能的情况下处理它(通常通过动态属性进行实时修改).&lt;/li>
&lt;li>如果客户端服务改变了性能特征(经常发生会以成为一个问题), 从而导致需要调整属性(增加/减少超时, 更改重试等), 这通过线程池指标(错误, 延迟, 超时, 拒绝), 并且可以在不影响其他客户端, 请求或用户的情况下进行处理.&lt;/li>
&lt;li>除了隔离优势外, 拥有专用线程池还提供了内置并发性, 可用于在同步客户端库之上构建异步特性(类似于Netflix API在Hystrix命令之上构建反应式, 完全异步的Java API).&lt;/li>
&lt;/ul>
&lt;p>简而言之, 由线程池提供的隔离功能可以使客户端库和子系统性能特性的不断变化和动态组合得到适度处理, 而不会造成中断.&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>: 尽管单独的线程提供了隔离, 但你的底层客户端代码也应该有超时 和/或 响应线程中断, 以便它不会无限制地阻塞并使Hystrix线程池饱和.&lt;/p>
&lt;p>&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15274259098702.png" alt="">&lt;/p>
&lt;p>&lt;strong>线程池的缺点&lt;/strong>&lt;/p>
&lt;p>线程池的主要缺点是增加了计算开销, 每个Command的执行设计到队列, 调度和Command单独运行的线程的上下文的切换.&lt;/p>
&lt;p>在设计这个系统时, Netflix决定接受这种开销, 以换取其提供的好处, 并认为它足够小, 不会对成本或性能产生重大影响,.&lt;/p>
&lt;p>&lt;strong>线程成本&lt;/strong>&lt;/p>
&lt;p>Hystrix在子线程上执行construct()或run()方法时测量延迟, 以及父线程上的总端到端时间. 通过这种方式, 你可以看到Hystrix开销的成本(线程, 指标, 日志记录, 断路器等).&lt;/p>
&lt;p>Netflix API每天使用线程隔离处理10亿多Hystrix Command执行. 每个API实例都有40多个线程池, 每个线程池中有5-20个线程(大多数设置为10).&lt;/p>
&lt;h3 id="信号量">信号量&lt;/h3>
&lt;p>你可以使用信号量(或计数器)来限制对任何给定依赖项的并发调用数量, 而不是使用线程池/队列大小. 这允许Hystrix在不使用线程池的情况下卸载负载. 如果你信任下客户端, 而你只想要卸载, 你可以使用这种方法.&lt;/p>
&lt;p>&lt;code>HystrixCommand&lt;/code>和&lt;code>HystrixObservableCommand&lt;/code>支持2个地方的信号量:&lt;/p>
&lt;p>&lt;strong>回退:&lt;/strong> 当Hystrix执行回退时, 它总是在调用Tomcat线程上执行回退
&lt;strong>执行:&lt;/strong> 如果将属性&lt;code>execution.isolation.strategy&lt;/code>设置为&lt;code>SEMAPHORE&lt;/code>, 则Hystrix将使用信号而不是线程来限制调用该命令的并发父线程的数量.&lt;/p>
&lt;p>你可以通过动态属性来配置这两种信号量的使用, 这些动态属性定义了可以执行多少个并发线程. 在调整线程池大小时, 你应该使用类似的计算来调整它们的大小(内存调用返回的次毫秒时间可以在信号量仅为1或2的情况下执行超过5000rps, 但默认值为10).&lt;/p>
&lt;p>一旦达到限制, 信号量拒绝将开始, 但填充信号量的线程不能离开.&lt;/p>
&lt;p>翻译自&lt;a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">How it Works&lt;/a>&lt;/p></description></item><item><title>初识Netflix Zuul</title><link>https://atbug.com/learn-netflix-zuul/</link><pubDate>Sun, 11 Feb 2018 10:07:18 +0000</pubDate><guid>https://atbug.com/learn-netflix-zuul/</guid><description>
&lt;p>嵌入式的zuul代理&lt;/p>
&lt;p>使用了Netfilx OSS的其他组件:&lt;/p>
&lt;ul>
&lt;li>Hystrix 熔断&lt;/li>
&lt;li>Ribbon 负责发送外出请求的客户端, 提供软件负载均衡功能&lt;/li>
&lt;li>Trubine 实时地聚合细粒度的metrics数据&lt;/li>
&lt;li>Archaius 动态配置&lt;/li>
&lt;/ul>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>由于2.0停止开发且会有bug, 故下面的分析基于1.x版本.&lt;/p>
&lt;h3 id="特性">特性&lt;/h3>
&lt;ul>
&lt;li>Authentication 认证&lt;/li>
&lt;li>Insights 洞察&lt;/li>
&lt;li>Stress Testing 压力测试&lt;/li>
&lt;li>Canary Testing 金丝雀测试&lt;/li>
&lt;li>Dynamic Routing 动态路由&lt;/li>
&lt;li>Multi-Region Resiliency 多区域弹性&lt;/li>
&lt;li>Load Shedding 负载脱落&lt;/li>
&lt;li>Security 安全&lt;/li>
&lt;li>Static Response handling 静态响应处理&lt;/li>
&lt;li>Multi-Region Resiliency 主动/主动流量管理&lt;/li>
&lt;/ul>
&lt;h3 id="zuul核心架构">Zuul核心架构&lt;/h3>
&lt;h4 id="过滤器加载器">过滤器加载器&lt;/h4>
&lt;p>从文件目录定时的监控文件, 编译成Class并加载到过滤器链中.&lt;/p>
&lt;h4 id="贯穿整个请求的requestcontext">贯穿整个请求的RequestContext&lt;/h4>
&lt;p>将Servlet的请求和响应初始化成&lt;code>RequestContext&lt;/code>, 保存在ThreadLocal中贯穿整个请求.&lt;/p>
&lt;p>以及添加Netfix库的指定概念和数据的扩展对象&lt;code>NFRequestContext&lt;/code>, 如&lt;code>Eureka&lt;/code>&lt;/p>
&lt;h4 id="四种过滤器">四种过滤器:&lt;/h4>
&lt;ul>
&lt;li>preRoute&lt;/li>
&lt;li>route&lt;/li>
&lt;li>postRoute&lt;/li>
&lt;li>error&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn-images-1.medium.com/max/1000/1*j9iGkeQ7bPK2nC1a7BgFOw.png" alt="Zuul Core Architecture">&lt;/p>
&lt;h3 id="zuul请求生命周期">Zuul请求生命周期&lt;/h3>
&lt;p>&lt;img src="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" alt="Request Lifecycle">&lt;/p>
&lt;h3 id="zuul-netflix">Zuul Netflix&lt;/h3>
&lt;p>使用Netflix的其他组件&lt;/p>
&lt;p>&lt;img src="https://cdn-images-1.medium.com/max/800/1*pz6sv69la9ek6yWNTPqymQ.png" alt="Netflix OSS libraries in Zuul">&lt;/p>
&lt;h3 id="zull在netfilx的应用">zull在Netfilx的应用&lt;/h3>
&lt;h4 id="精确路由">精确路由&lt;/h4>
&lt;p>创建一个过滤器是特定的用户或者设备的请求重定向到独立的API集群达到调试的目的.&lt;/p>
&lt;h4 id="多区域弹">多区域弹&lt;/h4>
&lt;p>Zuul是我们称为地峡(Isthmus)的多地区ELB弹性项目的核心. 作为Isthmus的一部分, Zuul被用来将请求从西海岸数据中心传送到东海岸, 以帮助我们在我们的关键领域的ELB中实现多区域冗余.&lt;/p>
&lt;h4 id="压力测试">压力测试&lt;/h4>
&lt;p>在&lt;code>Zuul&lt;/code>过滤器中使用动态&lt;code>Archaius&lt;/code>配置逐步提升进入一部分服务器的流量, 自动实现压力测试.&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;h3 id="如何工作">如何工作&lt;/h3>
&lt;h4 id="startserver初始化">StartServer初始化&lt;/h4>
&lt;p>实现了ServletContextListener接口, 如果需要与netflix oss其他组件集成(如Eureka, Archaius)实例化的时候启动一个Karyon服务器.&lt;/p>
&lt;p>在ServletContext初始化完成后调用&lt;code>initGroovyFilterManager&lt;/code>和&lt;code>initJavaFilters&lt;/code>.&lt;/p>
&lt;h5 id="initgroovyfiltermanager">initGroovyFilterManager&lt;/h5>
&lt;p>向过滤器注册表中添加Groovy过滤器.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">initGroovyFilterManager&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//设置GroovyCompiler
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//GroovyCompiler是DynamicCompiler的实现类
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">FilterLoader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getInstance&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">setCompiler&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">GroovyCompiler&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="c1">//从配置中是获取过滤器源文件的根目录
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">scriptRoot&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getProperty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;zuul.filter.root&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">scriptRoot&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">scriptRoot&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">scriptRoot&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">separator&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//设置文件名过滤器, 这里只过滤`.groovy`类型文件.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">FilterFileManager&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setFilenameFilter&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">GroovyFileFilter&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="c1">//初始化过滤器文件管理器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//第一个参数是扫描目录的间隔时间, 单位为秒
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//后面跟要扫描的子目录
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//1. 初始化的时候会扫描各个子目录, 使用文件名过滤器获取到所有的过滤器源文件.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//2. 遍历这些文件, 使用`FilterLoader.getInstance().putFilter(file)`, compiler编译之后使用FilterFactory进行实例化, 并添加到过滤器注册表中. 是否实例化的逻辑判断是否在上次修改且文件最后修改时间是否相同. 如果是上次修改之后又有改动, 要重建改类型过滤器的列表. 如果没有修改, 对改文件不做任何处理.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//3. 启动线程, 每个5秒执行一个1和2的操作.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">FilterFileManager&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">init&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">scriptRoot&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;pre&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">scriptRoot&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;route&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">scriptRoot&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Exception&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="initjavafilters">initJavaFilters&lt;/h5>
&lt;p>向过滤器注册表中添加Java过滤器.&lt;/p>
&lt;p>*官方没有提供从java源代码到classs的编译器.&lt;/p>
&lt;h4 id="zuulservlet">ZuulServlet&lt;/h4>
&lt;p>核心zuul servlet, 初始化和卸掉zullFilter的运行.
使用ZuulRunner将Servlet的请求和响应初始化成&lt;code>RequestContext&lt;/code>, 并将&lt;code>FilterProcessor&lt;/code>的调用包装成&lt;code>preRoute()&lt;/code>, &lt;code>route()&lt;/code>, &lt;code>postRoute()&lt;/code>和&lt;code>error()&lt;/code>方法. 初始化时可以选择将请求包装成&lt;code>HttpServletRequestWrapper&lt;/code>并缓冲请求消息体.&lt;/p>
&lt;p>初始化后的&lt;code>RequestContext&lt;/code>会放在&lt;code>ThreadLocal&lt;/code>中, 供后续的filter访问.&lt;/p>
&lt;p>&lt;strong>Service方法&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">service&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">javax&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">servlet&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">ServletRequest&lt;/span> &lt;span class="n">servletRequest&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">javax&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">servlet&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">ServletResponse&lt;/span> &lt;span class="n">servletResponse&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">ServletException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">init&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="n">HttpServletRequest&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">servletRequest&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">HttpServletResponse&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">servletResponse&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// Marks this request as having passed through the &amp;#34;Zuul engine&amp;#34;, as opposed to servlets
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// explicitly bound in web.xml, for which requests will not have the same data attached
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">RequestContext&lt;/span> &lt;span class="n">context&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">RequestContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getCurrentContext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setZuulEngineRan&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">preRoute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ZuulException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">error&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">postRoute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">route&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ZuulException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">error&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">postRoute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">postRoute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ZuulException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">error&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Throwable&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">error&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">ZuulException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">500&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;UNHANDLED_EXCEPTION_&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()));&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">RequestContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getCurrentContext&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">unset&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过&lt;code>FilterProcessor.getInstnace()&lt;/code>调用&lt;code>FilterProcessor&lt;/code>的&lt;code>preRoute()&lt;/code>, &lt;code>route()&lt;/code>, &lt;code>postRoute()&lt;/code>和&lt;code>error()&lt;/code>方法.&lt;/p>
&lt;p>四个方法都是通过&lt;code>FilterLoader.getInstance()&lt;/code>获取对应类型的filter列表.&lt;/p>
&lt;p>遍历filter列表, 调用filter的&lt;code>runFilter()&lt;/code>方法.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * runFilter checks !isFilterDisabled() and shouldFilter(). The run() method is invoked if both are true.
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @return the return from ZuulFilterResult
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ZuulFilterResult&lt;/span> &lt;span class="nf">runFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ZuulFilterResult&lt;/span> &lt;span class="n">zr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulFilterResult&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">//动态获取`zuul.filerClassName.filterType.disable`的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//动态获取使用Archaius的DynamicPropertyFactory获取*, 通过这个可实现动态配置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">isFilterDisabled&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//调用filter类的校验逻辑
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">shouldFilter&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Tracer&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TracerFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">instance&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">startMicroTracer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ZUUL::&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getSimpleName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//执行filter的逻辑处理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">run&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">//执行成功
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">zr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulFilterResult&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">res&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ExecutionStatus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SUCCESS&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Throwable&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ZUUL::&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getSimpleName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; failed&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">//执行失败
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">zr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulFilterResult&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ExecutionStatus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">FAILED&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">zr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">stopAndLog&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//filter不适用, 直接跳过
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">zr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulFilterResult&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ExecutionStatus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SKIPPED&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">zr&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="contextlifecyclefilter">ContextLifecycleFilter&lt;/h4>
&lt;p>清空&lt;code>ThreadLocal&lt;/code>中的&lt;code>RequestContext&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">doFilter&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ServletRequest&lt;/span> &lt;span class="n">req&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ServletResponse&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">FilterChain&lt;/span> &lt;span class="n">chain&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ServletException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">chain&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">doFilter&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">req&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">RequestContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getCurrentContext&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">unset&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="调试">调试&lt;/h3>
&lt;p>调试信息中的名词&lt;/p>
&lt;ul>
&lt;li>ZUUL_DEBUG 输出zuul的诊断信息&lt;/li>
&lt;li>REQUEST_DUBG 输出Http请求的信息. REQUEST -&amp;gt; ZUUL -&amp;gt; ORIGIN_RESPONSE -&amp;gt; OUTBOUND
&lt;ul>
&lt;li>REQUEST 进入zuul的请求&lt;/li>
&lt;li>ZUUL zuul转发给原目标的请求&lt;/li>
&lt;li>ORIGIN_RESPONSE 原目标返回的原始响应&lt;/li>
&lt;li>OUTBOND zuul返回给客户端的响应&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="接口和类">接口和类&lt;/h2>
&lt;h3 id="接口">接口&lt;/h3>
&lt;h4 id="dynamiccodecompiler">DynamicCodeCompiler&lt;/h4>
&lt;p>从源代码编译成Classes的接口, 目前只有一个&lt;code>GroovyCompiler&lt;/code>实现类&lt;/p>
&lt;h4 id="filterfactory">FilterFactory&lt;/h4>
&lt;p>生成给定的过滤器类实例的接口, 实现类&lt;code>DefaultFilterFactory&lt;/code>&lt;/p>
&lt;h4 id="filterusagenotifier">FilterUsageNotifier&lt;/h4>
&lt;p>注册过滤器使用时的回调的接口&lt;/p>
&lt;h3 id="类">类&lt;/h3>
&lt;h4 id="defaultfilterfactory">DefaultFilterFactory&lt;/h4>
&lt;p>使用反射实现&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="n">ZuulFilter&lt;/span> &lt;span class="nf">newInstance&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Class&lt;/span> &lt;span class="n">clazz&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InstantiationException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IllegalAccessException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ZuulFilter&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">clazz&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">newInstance&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="filterfilemanager">FilterFileManager&lt;/h4>
&lt;p>从过滤器目录中获取修改和新增的Groovy过滤器文件.&lt;/p>
&lt;h4 id="filterloader">FilterLoader&lt;/h4>
&lt;p>持有过滤器注册表, 加载过滤器.&lt;/p></description></item></channel></rss>