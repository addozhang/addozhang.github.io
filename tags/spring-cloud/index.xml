<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring Cloud on 乱世浮生</title><link>https://atbug.com/tags/spring-cloud/</link><description>Recent content in Spring Cloud on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 09 Jun 2020 19:35:53 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/spring-cloud/index.xml" rel="self" type="application/rss+xml"/><item><title>带你了解 Ribbon 负载均衡器的实现</title><link>https://atbug.com/how-loadbalancer-works-in-ribbon/</link><pubDate>Tue, 09 Jun 2020 19:35:53 +0800</pubDate><guid>https://atbug.com/how-loadbalancer-works-in-ribbon/</guid><description>
&lt;p>Spring Cloud 中 &lt;code>Ribbon&lt;/code>有在 &lt;code>Zuul&lt;/code> 和 &lt;code>Feign&lt;/code> 中使用，当然也可以通过在&lt;code>RestTemplate&lt;/code>的 bean 定义上添加&lt;code>@LoadBalanced&lt;/code>注解方式获得一个带有负载均衡更能的&lt;code>RestTemplate&lt;/code>。&lt;/p>
&lt;p>不过实现的方法都大同小异：对&lt;code>HttpClient&lt;/code>进行封装，加上实例的”选择“（这个选择的逻辑就是我们所说的负载均衡）。&lt;/p>
&lt;p>要学习某个框架的时候，最简单的方案就是：&lt;strong>Running+Debugging&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>跑就是了。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>debug 不一定是为了 bug&lt;/p>
&lt;p>debug 出真知&lt;/p>
&lt;p>Debugging = Learning&lt;/p>
&lt;/blockquote>
&lt;p>选用 &lt;a href="https://www.alispit.tel">Ali Spittel&lt;/a> 的一条推文：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/06/09/screenshot-20200609-at-165236.png" alt="screenshot 2020-06-09 at 16.52.36">&lt;/p>
&lt;h3 id="以-zuul-路由的线程栈为例">以 Zuul 路由的线程栈为例&lt;/h3>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/06/09/screenshot-20200609-at-151421.png" alt="screenshot 2020-06-09 at 15.14.21">&lt;/p>
&lt;p>调整下顺序：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">RetryableRibbonLoadBalancingHttpClient&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">execute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RibbonApacheHttpRequest&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IClientConfig&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">RetryableRibbonLoadBalancingHttpClient&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">executeWithRetry&lt;/span>&lt;span class="o">(...)&lt;/span>
&lt;span class="n">RetryTemplate&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">execute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RetryCallback&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">E&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">RecoveryCallback&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;)&lt;/span>
&lt;span class="n">RetryTemplate&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">doExecute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RetryCallback&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">E&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">RecoveryCallback&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">RetryState&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">RetryTemplate&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">canRetry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RetryPolicy&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">RetryContext&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">InterceptorRetryPolicy&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">canRetry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RetryContext&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">AbstractLoadBalancingClient&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">choose&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">serviceId&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">ZoneAwareLoadBalancer&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">chooseServer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1">//key as serviceId
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">BaseLoadBalancer&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">chooseServer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">PredicateBasedRule&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">choose&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">AbstractServerPredicate&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">chooseRoundRobinAfterFiltering&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Server&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">servers&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">loadBalancerKey&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">AbstractServerPredicate&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">apply&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Predicate&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="分析">分析&lt;/h3>
&lt;p>Zuul 收到请求经过一系列 Filter 的处理，来到 &lt;code>RibbonRoutingFilter&lt;/code>；将请求封装成 &lt;code>RibbonCommandContext&lt;/code>，然后使用 context 构建 &lt;code>RibbonCommand&lt;/code>。最终调用&lt;code>RibbonCommand#execute()&lt;/code>方法，将请求路由到下游。&lt;/p>
&lt;p>&lt;code>RibbonCommand&lt;/code>持有&lt;code>AbstractLoadBalancerAwareClient&lt;/code>的对象，通过该 client 在处理请求和响应。&lt;/p>
&lt;p>对于 &lt;strong>retryable&lt;/strong> 的 client（比如此处的&lt;code>RetryableRibbonLoadBalancingHttpClient&lt;/code>）， &lt;em>&lt;em>每次处理请求的时候都会创建一个&lt;/em>&lt;/em> &lt;code>RetryTemplate&lt;/code>对象来处理请求；同时根据&lt;code>RetryPolicy&lt;/code>来创建&lt;code>RetryContext&lt;/code>对象，用来保存重试的上下文，并 &lt;em>检查实例是否可以进行重试&lt;/em> 。&lt;/p>
&lt;p>注意重点就在这里：检查的时候&lt;strong>如果重试次数为 0 且要检查的实例为空&lt;/strong>（说明是第一次请求），这时便会通过&lt;strong>负载均衡器客户端&lt;/strong>（基本都是&lt;code>AbstractLoadBalancingClient&lt;/code>的子类）从后端列表择出一个实例，保存在&lt;code>RetryContext&lt;/code>中。&lt;/p>
&lt;p>负载均衡器客户端使用&lt;strong>负载均衡器&lt;/strong>（&lt;code>ILoadBalancer&lt;/code>的实现）来选择实例。每个负载均衡器都有自己的规则（&lt;code>IRule&lt;/code>的实现类），通过规则来选择实例。&lt;/p>
&lt;p>&lt;code>IRule&lt;/code>的实现不是很多，&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/06/09/screenshot-20200609-at-163309.png" alt="screenshot 2020-06-09 at 16.33.09">&lt;/p>
&lt;p>其中的&lt;code>ClientConfigEnabledRoundRobinRule&lt;/code>在&lt;code>RoundRobinRule&lt;/code>的基础上，增加了配置的接口（因为其实现了&lt;code>IClientConfigAware&lt;/code>接口）可以对规则进行配置。&lt;/p>
&lt;p>某些&lt;code>ClientConfigEnabledRoundRobinRule&lt;/code>的子类了，增加了&lt;code>Predicate&lt;/code>逻辑：使用&lt;code>Predicate&lt;/code>（&lt;code>AbstractServerPredicate&lt;/code>的子类）的逻辑进行选择；而&lt;code>ClientConfigEnabledRoundRobinRule&lt;/code>只是简单的使用&lt;code>RoundRobinRule&lt;/code>进行选择。&lt;/p>
&lt;p>因此选择的逻辑都是在&lt;code>AbstractServerPredicate&lt;/code>子类中，其有个特别的子类&lt;code>CompositePredicate&lt;/code>，顾名思义就是将多个逻辑整合在一起（使用&lt;code>Predicate#and()&lt;/code>将所有逻辑串联起来，达到&lt;code>&amp;amp;&amp;amp;&lt;/code>的效果），所有的逻辑检查都通过（返回&lt;code>true&lt;/code>）时，这个实例就会被选中。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/06/09/screenshot-20200609-at-165642.png" alt="screenshot 2020-06-09 at 16.56.42">&lt;/p>
&lt;hr>
&lt;p>那么现在要你写个自己负载均衡规则，应该知道从哪里入手了吧？:D&lt;/p></description></item><item><title>神秘的Eureka自我保护</title><link>https://atbug.com/translation-the-mystery-of-eurekas-self-preservation/</link><pubDate>Sun, 05 Jan 2020 14:14:03 +0800</pubDate><guid>https://atbug.com/translation-the-mystery-of-eurekas-self-preservation/</guid><description>
&lt;p>本文翻译自&lt;a href="https://dzone.com/articles/the-mystery-of-eurekas-self-preservation">The Mystery of Eureka Self-Preservation&lt;/a>&lt;/p>
&lt;p>根据CAP定理, Eureka是一个AP系统, 这就导致了在网络分区期间多个注册表中的信息不一致. 自我保护功能则是为了尽可能降低这种不一致.&lt;/p>
&lt;h2 id="自我保护的定义">自我保护的定义&lt;/h2>
&lt;p>自我保护(self preservation)是Eureka的一项功能, Eureka注册表在未收到实例的心跳情况超过一定阈值时停止驱逐过期的实例.&lt;/p>
&lt;h3 id="从一个健康的系统开始">从一个健康的系统开始&lt;/h3>
&lt;p>把下面看成一个健康的系统&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/n5wZMX.jpg" alt="The healthy system — before encountering network partition">&lt;/p>
&lt;p>假设所有的微服务都处于健康的状态并成功注册到Eureka注册表中.&lt;/p>
&lt;p>多个注册表间会同步注册表记录, 所有的微服务实例都处于UP状态. 假设实例2从注册中心发现里实例4, 并调用实例4上的服务.&lt;/p>
&lt;h3 id="突发网络分区">突发网络分区&lt;/h3>
&lt;p>假设出现了网络分区, 系统变成下面的状态.&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/MznWWr.jpg" alt="During network partition  -  enters self-preservation">&lt;/p>
&lt;p>由于网络分区, 实例4和5丢失了注册中心的连接, 但是实例2仍然可以连接到实例4. Eureka服务端因为没有收到实例4和5的心跳(超过一定时间后), 将他们驱逐. 然后Eureka服务端意识到突然丢失了超过15%(2/5)的心跳, 因此其进入&lt;em>自我保护&lt;/em>模式&lt;/p>
&lt;p>从此时开始, Eureka服务端不在驱逐任何实例, 即使实例真正的下线了.&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/7c9eHt.jpg" alt="During self-preservation  -  stops expiring instances">&lt;/p>
&lt;p>实例3下线, 但其始终存在注册表中.&lt;/p>
&lt;p>但此时注册表还会接受新实例的注册.&lt;/p>
&lt;h2 id="自我保护的基本原理">自我保护的基本原理&lt;/h2>
&lt;p>自我保护功能在下面两种情况下是合理的:&lt;/p>
&lt;ul>
&lt;li>Eureka服务端因为弱网分区问题没有收到心跳(这并不意味着客户端下线), 但是这种问题可能会很快被修复.&lt;/li>
&lt;li>即使Eureka服务端和客户端的连接断开, 客户端间还可以继续保持连接. (比如上面实例2仍然可以连接到实例4)&lt;/li>
&lt;/ul>
&lt;h3 id="配置-默认">配置 (默认)&lt;/h3>
&lt;p>下面的配置会直接或间接影响到自我保护的行为.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.instance.lease-renewal-interval-in-seconds = 30
&lt;/code>&lt;/pre>&lt;/div>&lt;p>客户端发送心跳的频率. 服务端会以此在计算期望收到心跳数, 默认30秒&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.instance.lease-expiration-duration-in-seconds = 90
&lt;/code>&lt;/pre>&lt;/div>&lt;p>多长时间未收到心跳后, 实例才可以被驱逐, 默认90秒&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.eviction-interval-timer-in-ms = 60 * 1000
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Eureka服务端驱逐操作的执行频率, 默认60秒&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.renewal-percent-threshold = 0.85
&lt;/code>&lt;/pre>&lt;/div>&lt;p>期望心跳数达到该阈值后, 就会进入自我保护模式, 默认0.85&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.renewal-threshold-update-interval-ms = 15 * 60 * 1000
&lt;/code>&lt;/pre>&lt;/div>&lt;p>期望心跳数的计算间隔, 默认15分钟&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">eureka.server.enable-self-preservation = true
&lt;/code>&lt;/pre>&lt;/div>&lt;p>是否允许Eureka服务端进入自我保护模式, 默认开启&lt;/p>
&lt;h2 id="理解配置">理解配置&lt;/h2>
&lt;p>Eureka服务端在&amp;quot;上一分钟实际收到的心跳数&amp;quot;小于&amp;quot;每分钟期望的心跳数&amp;quot;时就会进入自我保护模式&lt;/p>
&lt;h3 id="期望的每分钟心跳数">期望的每分钟心跳数&lt;/h3>
&lt;p>假设&lt;code>renewal-percent-threshold&lt;/code>设置为&lt;code>0.85&lt;/code>&lt;/p>
&lt;p>计算方式:&lt;/p>
&lt;ul>
&lt;li>单个实例每分钟期望的心跳数是: 2&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>N个实例的每分钟期望的心跳数: 2 * N&lt;/li>
&lt;li>期望的上一分钟最小心跳数: 2 * N * 0.85&lt;/li>
&lt;/ul>
&lt;h3 id="实际的每分钟心跳数">实际的每分钟心跳数&lt;/h3>
&lt;p>正如上面所述, 两个定时调度器独立地运行计算&lt;em>实际&lt;/em>和&lt;em>期望&lt;/em>的心跳数. 此外还有另一个调度任务&lt;code>EvictionTask&lt;/code>进行结果比较, 并识别当前系统是否在自我保护状态.&lt;/p>
&lt;p>这个调度任务每个&lt;code>eviction-interval-timer-in-ms&lt;/code>时间执行一次, 并决定是否驱逐实例.&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;ul>
&lt;li>基于使用的经验, 大多数情况下自我保护模式都是错误的, 它错误地认为一些下线的微服务实例是不良的网络分区&lt;/li>
&lt;li>自我保护永远不会过期, 除非下线的实例重新上线&lt;/li>
&lt;li>如果启用了自我保留, 则无法对实例的心跳间隔进行微调, 因为自我保护在计算期望心跳数是按照30s间隔来计算的&lt;/li>
&lt;li>除非环境中经常出现类似的网络分区故障, 否则建议关闭&lt;/li>
&lt;/ul>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>这个值是固定的, 源于默认的心跳间隔是30s, 故每分钟2次. 见eureka-core-1.7.2的&lt;code>AbstractInstanceRegistryL226&lt;/code> &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Spring Cloud Hoxton发布</title><link>https://atbug.com/spring-cloud-hoxton-release/</link><pubDate>Wed, 04 Dec 2019 11:09:07 +0800</pubDate><guid>https://atbug.com/spring-cloud-hoxton-release/</guid><description>
&lt;p>&lt;a href="https://spring.io/blog/2019/11/28/spring-cloud-hoxton-released">原文&lt;/a>&lt;/p>
&lt;p>Spring Cloud Hoxton.RELEASE基于Spring Boot 2.2.1.RELEASE&lt;/p>
&lt;h3 id="文档变化">文档变化&lt;/h3>
&lt;p>Hoxton.RELEASE使用了新的&lt;a href="https://cloud.spring.io/spring-cloud-static/Hoxton.RELEASE/reference/html/spring-cloud.html">首页&lt;/a>, 新的样式以及单页面, 多页面和PDF版本.&lt;/p>
&lt;h3 id="新的负载均衡器实现">新的负载均衡器实现&lt;/h3>
&lt;p>Hoxton.RELEASE是第一个包含阻塞和非阻塞客户端负载均衡器实现的版本, 替代进入维护状态的Netflix Ribbon.&lt;/p>
&lt;p>搭配&lt;code>BlockingLoadBalancerClient&lt;/code>使用&lt;code>RestTemplate&lt;/code>, 需要在classpath中引入&lt;code>org.springframework.cloud:spring-cloud-loadbalancer&lt;/code>. 这个依赖同样用于使用了&lt;code>@LoadBalanced WebClient.Builder&lt;/code>的响应式应用中. 唯一的区别是Spring Cloud会自动配置&lt;code>ReactorLoadBalancerExchangeFilterFunction&lt;/code>实例. 更多内容查看&lt;a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-commons/2.2.0.M2/reference/html/#_spring_resttemplate_as_a_load_balancer_client">文档&lt;/a>. 新的&lt;code>ReactorLoadBalancerExchangeFilterFunction&lt;/code>可用于自动装配并自动传递给&lt;code>WebClient.Builder&lt;/code>(&lt;a href="https://cloud.spring.io/spring-cloud-commons/reference/html/#webflux-with-reactive-loadbalancer">文档&lt;/a>).&lt;/p>
&lt;h3 id="spring-cloud-netflix">Spring Cloud Netflix&lt;/h3>
&lt;ul>
&lt;li>增加了新的&lt;code>ReactiveDiscoveryClient&lt;/code>, 同时增加了新的Spring Cloud Circuit Breaker API的Hystrix实现.&lt;/li>
&lt;li>增加&lt;a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.2.0.RC2/reference/html/#disabling-spring-cloud-circuit-breaker-hystrix">配置项&lt;/a>&lt;code>spring.cloud.circuitbreaker.hystrix.enabled&lt;/code>来禁用Spring Cloud CircuitBreaker Hystrix的自动配置.&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-cloudfoundry">Spring Cloud Cloudfoundry&lt;/h3>
&lt;p>支持新的&lt;code>ReactiveDiscoveryClient&lt;/code>&lt;/p>
&lt;h3 id="spring-cloud-bus">Spring Cloud Bus&lt;/h3>
&lt;p>文档更新&lt;/p>
&lt;h3 id="spring-cloud-vault">Spring Cloud Vault&lt;/h3>
&lt;ul>
&lt;li>在Pivotal应用程序服务)以前的PCF)中运行的应用程序可以利用容器的身份来使用保险柜的PCF身份验证支持进行身份验证&lt;/li>
&lt;li>使用X-Vault-Namespace标头支持Vault名称空间(Vault Enterprise功能)&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-kubernetes">Spring Cloud Kubernetes&lt;/h3>
&lt;p>支持新的&lt;code>ReactiveDiscoveryClient&lt;/code>&lt;/p>
&lt;h3 id="spring-cloud-contract">Spring Cloud Contract&lt;/h3>
&lt;ul>
&lt;li>完整的文档重写&lt;/li>
&lt;li>主要测试类生成重构&lt;/li>
&lt;li>从Groovy到Java的大量重写&lt;/li>
&lt;li>添加了对使用Kotlin和Java编写合同的支持&lt;/li>
&lt;li>在合同DSL和运行时存根生成中添加了inProgress标志&lt;/li>
&lt;li>增加了对生成测试的TestNG支持&lt;/li>
&lt;li>许多库版本增量(包括Groovy, WireMock和Pact)&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-consul">Spring Cloud Consul&lt;/h3>
&lt;p>支持新的&lt;code>ReactiveDiscoveryClient&lt;/code>以及Consul的一致性模型&lt;/p>
&lt;h3 id="spring-cloud-config">Spring Cloud Config&lt;/h3>
&lt;ul>
&lt;li>新的环境仓库支持AWS S3&lt;/li>
&lt;li>添加了解密纯文本属性的功能&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-gcp">Spring Cloud Gcp&lt;/h3>
&lt;ul>
&lt;li>添加BigQuery模块&lt;/li>
&lt;li>为Cloud Foundry创建了一个单独的启动器：&lt;code>spring-cloud-gcp-starter-cloudfoundry&lt;/code>&lt;/li>
&lt;li>可以浏览&lt;a href="https://github.com/spring-cloud/spring-cloud-gcp/blob/master/CHANGELOG.adoc#120release-2019-11-26">变更日志&lt;/a>文档以获取更多信息&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-stream">Spring Cloud Stream&lt;/h3>
&lt;p>从annotation-driven过度到了更加简单的函数式.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://spring.io/blog/2019/10/14/spring-cloud-stream-demystified-and-simplified">Spring Cloud Stream - demystified and simplified&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://spring.io/blog/2019/10/17/spring-cloud-stream-functional-and-reactive">Spring Cloud Stream - functional and reactive&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://spring.io/blog/2019/10/25/spring-cloud-stream-and-spring-integration">Spring Cloud Stream - and Spring Integration&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://spring.io/blog/2019/10/31/spring-cloud-stream-event-routing">Spring Cloud Stream - Event Routing&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-commons">Spring Cloud Commons&lt;/h3>
&lt;p>引入阻塞和非阻塞客户端负载均衡器实现, 来替代进入维护状态的Netflix Ribbon.&lt;/p>
&lt;h3 id="spring-cloud-openfeign">Spring Cloud Openfeign&lt;/h3>
&lt;ul>
&lt;li>Openfeign升级到10.4.0&lt;/li>
&lt;li>支持Spring Cloud LoadBalancer&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-task">Spring Cloud Task&lt;/h3>
&lt;ul>
&lt;li>支持Micrometer&lt;/li>
&lt;li>更新文档&lt;/li>
&lt;li>使用Spring Batch分区时启动的任务应用现在加入了external-execution-id&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-sleuth">Spring Cloud Sleuth&lt;/h3>
&lt;ul>
&lt;li>加入对最新的Brave(包括消息采样)的支持&lt;/li>
&lt;li>添加了onLastOperator Reactor跟踪选项，以提高性能&lt;/li>
&lt;li>添加了Redis跟踪&lt;/li>
&lt;li>将默认采样器设置为限速采样器&lt;/li>
&lt;li>添加了对AWS SQS跟踪的支持&lt;/li>
&lt;li>增加了对Quartz跟踪的支持&lt;/li>
&lt;li>添加了进程内传播机制&lt;/li>
&lt;li>默认为Zipkin报告的Micrometer指标&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-aws">Spring Cloud AWS&lt;/h3>
&lt;p>Bug修复&lt;/p>
&lt;h3 id="spring-cloud-zookeeper">Spring Cloud Zookeeper&lt;/h3>
&lt;p>支持新的&lt;code>ReactiveDiscoveryClient&lt;/code>&lt;/p>
&lt;h3 id="spring-cloud-security">Spring Cloud Security&lt;/h3>
&lt;p>Bug修复&lt;/p>
&lt;h3 id="spring-cloud-curcuitbreaker">Spring Cloud CurcuitBreaker&lt;/h3>
&lt;p>引入新的项目Spring Cloud CircuitBreaker, 这个项目包含的抽象的API用于在项目中使用断路器. 支持该API的实现:&lt;/p>
&lt;ul>
&lt;li>Resilience4j&lt;/li>
&lt;li>Spring Retry&lt;/li>
&lt;li>Hystrix (in &lt;a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-hystrix/src/main/java/org/springframework/cloud/netflix/hystrix/HystrixCircuitBreaker.java">spring-cloud-netflix&lt;/a>)&lt;/li>
&lt;li>Sentinel (in &lt;a href="https://github.com/alibaba/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-sentinel">spring-cloud-alibaba&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker">更多信息&lt;/a>&lt;/p>
&lt;ul>
&lt;li>时添加了自动配置, 在使用Resilience4J收集断路器的指标数据&lt;/li>
&lt;li>升级到Resilience4J 1.1.0&lt;/li>
&lt;li>添加配置项禁用REsilience4J的自动配置&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-function">Spring Cloud Function&lt;/h3>
&lt;p>添加了更多新特性:&lt;/p>
&lt;ul>
&lt;li>透明类型转换&lt;/li>
&lt;li>函数路由&lt;/li>
&lt;li>函数参数&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://spring.io/blog/2019/11/25/announcing-the-release-of-spring-cloud-function-3-0-0-release">更多详细信息&lt;/a>&lt;/p>
&lt;h3 id="spring-cloud-gateway">Spring Cloud Gateway&lt;/h3>
&lt;ul>
&lt;li>支持新的&lt;code>ReactiveDiscoveryClient&lt;/code>&lt;/li>
&lt;li>RSocket模块迁移到了自己维护的位于Spring Cloud Incubator organization项目中&lt;/li>
&lt;li>通过增加的使用了新Spring Cloud CircuitBreaker库过滤器为路由提供断路器功能&lt;/li>
&lt;/ul></description></item><item><title>Zuul网关Ribbon重试</title><link>https://atbug.com/ribbon-retry-in-zuul/</link><pubDate>Thu, 02 Aug 2018 08:55:43 +0000</pubDate><guid>https://atbug.com/ribbon-retry-in-zuul/</guid><description>
&lt;h2 id="相关配置">相关配置&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">#如果路由转发请求发生超时(连接超时或处理超时), 只要超时时间的设置小于Hystrix的命令超时时间,那么它就会自动发起重试. 默认为false. 或者对指定响应状态码进行重试
zuul.retryable = true
zuul.routes.&amp;lt;route&amp;gt;.retryable = false
#同一实例上的最大重试次数, 默认值为0. 不包括首次调用
ribbon.MaxAutoRetries=0
#重试其他实例的最大重试次数, 不包括第一次选的实例. 默认为1
ribbon.MaxAutoRetriesNextServer=1
#是否所有操作执行重试, 默认值为false, 只重试`GET`请求
ribbon.OkToRetryOnAllOperations=false
#连接超时, 默认2000
ribbon.ConnectTimeout=15000
#响应超时, 默认5000
ribbon.ReadTimeout=15000
#每个host的最大连接数
ribbon.MaxHttpConnectionsPerHost=50
#最大连接数
ribbon.MaxTotalHttpConnections=200
#何种响应状态码才进行重试
ribbon.retryableStatusCodes=404,502
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="实现">实现&lt;/h2>
&lt;ol>
&lt;li>&lt;code>SimpleRouteLocator#getRoute&lt;/code>返回的&lt;code>route&lt;/code>对象中会带上&lt;code>retryable&lt;/code>的设置.&lt;/li>
&lt;li>&lt;code>PreDecorationFilter&lt;/code>在对&lt;code>RequestContext&lt;/code>进行装饰的时候会将&lt;code>retryable&lt;/code>的设置通过key&lt;code>FilterConstants.RETRYABLE_KEY&lt;/code>注入&lt;code>RequestContext&lt;/code>中.&lt;/li>
&lt;li>&lt;code>RibbonRoutingFilter#buildCommandContext&lt;/code>会使用&lt;code>RequestContext&lt;/code>的&lt;code>retryable&lt;/code>设置构造&lt;code>RibbonCommandContext&lt;/code>对象.&lt;/li>
&lt;li>&lt;code>RibbonCommandFactory&lt;/code>使用&lt;code>RibbonCommandContext&lt;/code>构建出&lt;code>RibbonCommand&lt;/code>对象.&lt;/li>
&lt;li>&lt;code>RibbonCommand#run&lt;/code>中, 当&lt;code>retryable&lt;/code>为&lt;code>true&lt;/code>时, 会调用&lt;code>IClient&lt;/code>的&lt;code>execute&lt;/code>方法处理请求. 为&lt;code>false&lt;/code>时, 会调用&lt;code>IClient&lt;/code>的&lt;code>executeWithLoadBalancer&lt;/code>方法执行请求.
&lt;ul>
&lt;li>&lt;code>execute&lt;/code>会在失败时进行重试(不超过超时限制)&lt;/li>
&lt;li>&lt;code>executeWithLoadBalancer&lt;/code>方法是先通过&lt;code>LoadBalancer&lt;/code>选择出一个&lt;code>Server&lt;/code>, 然后构建出请求地址.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>IClient#execute&lt;/code>执行时, 通过&lt;code>LoadBalancedRetryPolicyFactory&lt;/code>创建一个&lt;code>LoadBalancedRetryPolicy&lt;/code>对象. &lt;code>LoadBalancedRetryPolicy&lt;/code>持有上面&lt;code>ribbon.XXX&lt;/code>的设置. 当响应状态码不在&lt;code>ribbon.retryableStatusCodes&lt;/code>设置中, 则会直接返回响应. 如果属于可重试的响应状态码, 则会将响应封装为&lt;code>HttpClientStatusCodeException&lt;/code>抛出. 异常被&lt;code>RetryTemplate&lt;/code>捕获, 然后使用&lt;code>LoadBalancedRetryPolicy&lt;/code>对当前状态(MaxAutoRetries, MaxAutoRetriesNextServer)计算出能否进行一次重试. 直至成功, 或者当前状态不满足条件.&lt;/li>
&lt;/ol></description></item><item><title>Spring Cloud Ribbon 详解</title><link>https://atbug.com/spring-cloud-ribbon-breakdown-1/</link><pubDate>Sat, 05 May 2018 11:18:05 +0000</pubDate><guid>https://atbug.com/spring-cloud-ribbon-breakdown-1/</guid><description>
&lt;p>客户端负载均衡, Ribbon的核心概念是命名的客户端.&lt;/p>
&lt;h2 id="使用">使用&lt;/h2>
&lt;h3 id="引入ribbon依赖和配置">引入Ribbon依赖和配置&lt;/h3>
&lt;p>加入&lt;code>spring-cloud-starter-netflix-ribbon&lt;/code>依赖&lt;/p>
&lt;h3 id="代码中使用ribbonclient注解">代码中使用RibbonClient注解&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="nd">@RibbonClient&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;foo&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">configuration&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FooConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TestConfiguration&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Configuration&lt;/span> &lt;span class="kd">protected&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">FooConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ZonePreferenceServerListFilter&lt;/span> &lt;span class="nf">serverListFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ZonePreferenceServerListFilter&lt;/span> &lt;span class="n">filter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZonePreferenceServerListFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">filter&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setZone&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;myTestZone&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">filter&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">IPing&lt;/span> &lt;span class="nf">ribbonPing&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">PingUrl&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ribbon客户端的配置, 如果不指定会使用默认的实现:&lt;/p>
&lt;ul>
&lt;li>IClientConfig 客户端相关配置&lt;/li>
&lt;li>IRule 定义负载均衡策略&lt;/li>
&lt;li>IPing 定义如何ping目标服务实例来判断是否存活, ribbon使用单独的线程每隔一段时间(默认10s)对本地缓存的ServerList做一次检查&lt;/li>
&lt;li>ServerList&lt;!-- raw HTML omitted --> 定义如何获取服务实例列表. 两种实现基于配置的&lt;code>ConfigurationBasedServerList&lt;/code>和基于Eureka服务发现的&lt;code>DiscoveryEnabledNIWSServerList&lt;/code>&lt;/li>
&lt;li>ServerListFilter&lt;!-- raw HTML omitted --> 用来使用期望的特征过滤静态配置动态获得的候选服务实例列表. 若未提供, 默认使用&lt;code>ZoneAffinityServerListFilter&lt;/code>&lt;/li>
&lt;li>ILoadBalancer 定义了软负载均衡器的操作的接口. 一个典型的负载均衡器至少需要一组用来做负载均衡的服务实例, 一个标记某个服务实例不在旋转中的方法, 和对应的方法调用从实例列表中选出某一个服务实例.&lt;/li>
&lt;li>ServerListUpdater DynamicServerListLoadBalancer用来更新实例列表的策略(推&lt;code>EurekaNotificationServerListUpdater&lt;/code>/拉&lt;code>PollingServerListUpdater&lt;/code>, 默认是拉)&lt;/li>
&lt;/ul>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>类结构&lt;/p>
&lt;p>&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/Ribbon.png" alt="Ribbon">&lt;/p>
&lt;h3 id="实现">实现&lt;/h3>
&lt;p>实际使用中, 服务调用使用RestTemplate, 请求地址为&lt;code>http://&amp;lt;serviceName&amp;gt;/&amp;lt;path&amp;gt;&lt;/code>, 如&lt;code>http://foo/&lt;/code>
通过&lt;code>@RibbonClient&lt;/code>注解为服务创建ribbon客户端, 名字为方法名. RestTemplate发送请求的时候, 请求会被&lt;code>LoadBalancerInterceptor&lt;/code>拦截到, 使用服务对应的ribbon客户端. Ribbon客户端的&lt;code>LoadBalancer&lt;/code>会从&lt;code>ServerList&lt;/code>中根据&lt;code>IRule&lt;/code>的规则选择某个服务实例作为请求对象. &lt;code>ServerList&lt;/code>有动态的实现, 更新列表时会使用&lt;code>ServerListFilter&lt;/code>进行过滤.&lt;/p>
&lt;h4 id="ribbonclient注解">RibbonClient注解&lt;/h4>
&lt;p>从注释上&lt;code>@RibbonClient&lt;/code>为一个ribbon客户端声明配置信息. 把这个注解加在任何&lt;code>@Configuration&lt;/code>标注的类上, 然后注入&lt;code>SpringClientFactory&lt;/code>来访问创建的客户端.&lt;/p>
&lt;p>从代码上看&lt;code>@RibbonClient&lt;/code>引入了&lt;code>RibbonClientConfigurationRegistrar&lt;/code>. &lt;code>RibbonClientConfigurationRegistrar&lt;/code>实现了&lt;code>ImportBeanDefinitionRegistrar&lt;/code>接口, 在&lt;code>@Configuration&lt;/code>的解析极端调用接口的&lt;code>registerBeanDefinitions&lt;/code>方法, 为ribbon客户端创建BeanDefinition
使用&lt;code>name/value&lt;/code>和&lt;code>configuration&lt;/code>创建一个&lt;code>BeanDefinition&lt;/code>. Definition的名为&lt;code>&amp;lt;name&amp;gt;.RibbonClientSpecification&lt;/code>, class为&lt;code>RibbonClientSpecification&lt;/code>.&lt;/p>
&lt;p>&lt;code>FooConfiguration.class&lt;/code>也要使用&lt;code>@Configuration&lt;/code>注解, 然后通过&lt;code>RibbonClientConfigurationRegistrar&lt;/code>关联到Ribbon客户端的BeanDefinition. 所以&lt;strong>不能把FooConfiguration放到@ComponentScan的上下文中, 同样@SpringBootApplication也不行. 必要时使用exclude排除&lt;/strong>, 否则会变成所有Ribbon客户端共享.&lt;/p>
&lt;p>&lt;code>RibbonAutoConfiguration&lt;/code>中在创建&lt;code>SpringClientFactory&lt;/code>bean时, 会注入这些&lt;code>RibbonClientSpecification&lt;/code>. &lt;code>SpringClientFactory&lt;/code>继承了类&lt;code>NamedContextFactory&lt;/code>. 从注释看&lt;code>NamedContextFactory&lt;/code>可以创建一组子上下文, 每个子上下文中可以使用一组的Specification来定义bean. 对于Ribbon来说, 每个ribbon客户端各自为一个子上下文, &lt;code>@RibbonClient&lt;/code>的&lt;code>configuration&lt;/code>指定的配置, 就是用来构建该子上下文的配置, 最终被用来构建ribbon客户端. 这些上下文有共同的父上下文, 即&lt;code>ApplicationContext&lt;/code>. 这就是为什么上面提到的&lt;code>FooConfiguration&lt;/code>不能置于&lt;code>ApplicationContext&lt;/code>中, 否则会被所有的Ribbon客户端共享配置.&lt;/p>
&lt;h4 id="loadbalancerautoconfiguration配置类">LoadBalancerAutoConfiguration配置类&lt;/h4>
&lt;p>通过&lt;code>RibbonAutoConfiguration&lt;/code>引入, 定义了几个重要的bean:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>LoadBalancerRequestFactory&lt;/code>: 1) 将Http请求封装成&lt;code>ServiceRequestWrapper&lt;/code>. &lt;code>ServiceRequestWrapper&lt;/code>继承并重写了&lt;code>HttpRquestWrapper&lt;/code>的&lt;code>getURI&lt;/code>方法: 调用&lt;code>LoadBalancerClient&lt;/code>的&lt;code>reconstructURI&lt;/code>方法,创建实际请求的地址. 2) 如果有提供&lt;code>LoadBalancerRequestTransformer&lt;/code>的实例, 则使用这些实例对相求进行响应的转换.
&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15254831654150.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LoadBalancerInterceptor&lt;/code>: Http请求拦截器, 将请求的&lt;code>host&lt;/code>作为&lt;code>serviceName&lt;/code>并使用&lt;code>LoadBalancerRequestFactory&lt;/code>封装请求, 调用&lt;code>LoadBalancerClient&lt;/code>的&lt;code>execute&lt;/code>方法, 发送请求到真实的服务实例地址, 返回响应&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>RestTemplateCustomizer&lt;/code>: 提供一个&lt;code>RestTemplateCustomizer&lt;/code>的匿名类实现, 为所有的RestTemplate实例添加一个&lt;code>LoadBalancerInterceptor&lt;/code>拦截器&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="ribbonautoconfiguration配置类">RibbonAutoConfiguration配置类&lt;/h4>
&lt;p>通过spring.factories引入, &lt;code>RibbonAutoConfiguration&lt;/code>定义了几个重要的bean:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>SpringClientFactory&lt;/code>: 使用&lt;code>@RibbonClient&lt;/code>注解引入的ribbon客户端的配置, 构建ribbon客户端的子上下文, 初始化ribbon客户端bean. 四个get方法, 分别返回对应&lt;strong>service&lt;/strong>的&lt;code>IClient&lt;/code>, &lt;code>ILoadBalancer&lt;/code>, &lt;code>IClientConfig&lt;/code>, &lt;code>RibbonLoadBalancerContext&lt;/code>实例.
&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15254844516099.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LoadBalancerClient&lt;/code>: 使用Spring Cloud提供的实现&lt;code>RibbonLoadBalancerClient&lt;/code>. 通过&lt;code>SpringClientFactory&lt;/code>创建一个&lt;code>ILoadBalancer&lt;/code>实例, 通过&lt;code>ILoadBalancer&lt;/code>返回一个&lt;code>Server&lt;/code>实例. 使用&lt;code>Server&lt;/code>实例.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>reconstructURI(): 通过&lt;code>SpringClientFactory&lt;/code>获取该服务ribbon客户端子上下文&lt;code>RibbonLoadBalancerContext&lt;/code>对象, 调用&lt;code>RibbonLoadBalancerContext&lt;/code>的&lt;code>reconstructURIWithServer&lt;/code>方法构建最终的请求地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>choose(): 通过&lt;code>SpringClientFactory&lt;/code>获取该服务的服务均衡器, 使用负载均衡器的&lt;code>IRule&lt;/code>返回服务实例.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>execute(): 执行最终的请求, 并记录状态: &lt;code>ServerStats&lt;/code>和&lt;code>Stopwatch&lt;/code>&lt;/p>
&lt;p>&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15254847309993.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Spring Cloud Zuul详解</title><link>https://atbug.com/spring-cloud-zuul-breakdown/</link><pubDate>Thu, 22 Feb 2018 17:02:26 +0000</pubDate><guid>https://atbug.com/spring-cloud-zuul-breakdown/</guid><description>
&lt;p>Spring Cloud对Netflix Zuul做了封装集成, 使得在Spring Cloud环境中使用Zuul更方便. Netflix Zuul相关分析请看&lt;a href="http://atbug.com/learn-netflix-zuul/">上一篇&lt;/a>.&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>@EnableZuulProxy 与 @EnableZuulServer
二者的区别在于前者使用了服务发现作为路由寻址, 并使用Ribbon做客户端的负载均衡; 后者没有使用.
Zuul server的路由都通过&lt;code>ZuulProperties&lt;/code>进行配置.&lt;/p>
&lt;h3 id="具体实现">具体实现:&lt;/h3>
&lt;ol>
&lt;li>使用&lt;code>ZuulController&lt;/code>(&lt;code>ServletWrappingController&lt;/code>的子类)封装&lt;code>ZuulServlet&lt;/code>实例, 处理从&lt;code>DispatcherServlet&lt;/code>进来的请求.&lt;/li>
&lt;li>&lt;code>ZuulHandlerMapping&lt;/code>负责注册handler mapping, 将&lt;code>Route&lt;/code>的&lt;code>fullPath&lt;/code>的请求交由&lt;code>ZuulController&lt;/code>处理.&lt;/li>
&lt;li>同时使用&lt;code>ServletRegistrationBean&lt;/code>注册&lt;code>ZuulServlet&lt;/code>, 默认使用&lt;code>/zuul&lt;/code>作为urlMapping. 所有来自以&lt;code>/zuul&lt;/code>开头的path的请求都会直接进入&lt;code>ZuulServlet&lt;/code>, 不会进入&lt;code>DispatcherServlet&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h4 id="使用注解">使用注解&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;code>@EnableZuulProxy&lt;/code>引入了&lt;code>ZuulProxyMarkerConfiguration&lt;/code>, &lt;code>ZuulProxyMarkerConfiguration&lt;/code>只做了一件事, 实例化了内部类&lt;code>Marker&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulProxyMarkerConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Marker&lt;/span> &lt;span class="nf">zuulProxyMarkerBean&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Marker&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Marker&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>@EnableZuulServer&lt;/code>引入了&lt;code>ZuulServerMarkerConfiguration&lt;/code>, &lt;code>ZuulServerMarkerConfiguration&lt;/code>也只做了一件事: 实例化了内部类&lt;code>Marker&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulServerMarkerConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Marker&lt;/span> &lt;span class="nf">zuulServerMarkerBean&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Marker&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Marker&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="enableautoconfiguration">EnableAutoConfiguration&lt;/h4>
&lt;p>项目中使用&lt;code>@EnableAutoConfiguration&lt;/code>注解, 开启Spring上下文对象的自动配置功能, 尝试去猜测和实例化你&lt;strong>可能需要的&lt;/strong>bean.&lt;/p>
&lt;p>这个功能是基于classPath来完成的. 比如: 项目中引用了&lt;code>tomcat-embedded.jar&lt;/code>, 你可能需要一个&lt;code>TomcatEmbeddedServletContainerFactory&lt;/code>实例, 除非定义了自己的&lt;code>EmbeddedServletContainerFactory&lt;/code>实例.&lt;/p>
&lt;p>我们来接着看, 在&lt;code>spring-cloud-netflix-core&lt;/code>的&lt;code>spring.factories&lt;/code>中的&lt;code>org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/code>实现中我们可以找到&lt;code>org.springframework.cloud.netflix.zuul.ZuulProxyAutoConfiguration&lt;/code>和&lt;code>org.springframework.cloud.netflix.zuul.ZuulServerAutoConfiguration&lt;/code>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ZuulServerAutoConfiguration
它的初始化条件有两个:&lt;/p>
&lt;ul>
&lt;li>&lt;code>@ConditionalOnClass(ZuulServlet.class)&lt;/code>指定classpath中需要有&lt;code>ZuulServlet.class&lt;/code>. 这个servlet负责对所有进入Zuul server的请求以及配置应用指定的&lt;code>preRoute&lt;/code>, &lt;code>route&lt;/code>, &lt;code>postRoute&lt;/code>和&lt;code>error&lt;/code>.&lt;/li>
&lt;li>&lt;code>@ConditionalOnBean(ZuulServerMarkerConfiguration.Marker.class)&lt;/code> 与&lt;code>@EnableZuulServer&lt;/code>注解呼应.&lt;/li>
&lt;/ul>
&lt;p>​&lt;code>java @Configuration @EnableConfigurationProperties({ ZuulProperties.class }) @ConditionalOnClass(ZuulServlet.class) @ConditionalOnBean(ZuulServerMarkerConfiguration.Marker.class) // Make sure to get the ServerProperties from the same place as a normal web app would @Import(ServerPropertiesAutoConfiguration.class) public class ZuulServerAutoConfiguration { ... } ​&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ZuulProxyAutoConfiguration
它有一个初始化的条件&lt;code>@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)&lt;/code>, 就是上下文中需要有&lt;code>ZuulProxyMarkerConfiguration.Marker&lt;/code>这个内部类的bean. 与&lt;code>@EnableZuulProxy&lt;/code>注解呼应.&lt;/p>
&lt;p>初始化包括内置的filter, 以及Discovery, Ribbon等的初始化.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="nd">@Import&lt;/span>&lt;span class="o">({&lt;/span> &lt;span class="n">RibbonCommandFactoryConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">RestClientRibbonConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">RibbonCommandFactoryConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">OkHttpRibbonConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">RibbonCommandFactoryConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">HttpClientRibbonConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span> &lt;span class="o">})&lt;/span>
&lt;span class="nd">@ConditionalOnBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ZuulProxyMarkerConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Marker&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulProxyAutoConfiguration&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">ZuulServerAutoConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>​&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="zuulserverautoconfiguration-详解">ZuulServerAutoConfiguration 详解&lt;/h5>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">//声明配置
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="c1">//配置ZuulProperties实例
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nd">@EnableConfigurationProperties&lt;/span>&lt;span class="o">({&lt;/span> &lt;span class="n">ZuulProperties&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span> &lt;span class="o">})&lt;/span>
&lt;span class="c1">//条件1 存在ZuulServlet.class
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nd">@ConditionalOnClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ZuulServlet&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="c1">//条件2 存在ZuulServerMarkerConfiguration.Marker.class bean, 即应用使用@EnableZuulServer注解
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nd">@ConditionalOnBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ZuulServerMarkerConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Marker&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="c1">//配置ServerProperties实例
&lt;/span>&lt;span class="c1">// Make sure to get the ServerProperties from the same place as a normal web app would
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nd">@Import&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ServerPropertiesAutoConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulServerAutoConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Autowired&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="n">ZuulProperties&lt;/span> &lt;span class="n">zuulProperties&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Autowired&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="n">ServerProperties&lt;/span> &lt;span class="n">server&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Autowired&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">required&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">ErrorController&lt;/span> &lt;span class="n">errorController&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">HasFeatures&lt;/span> &lt;span class="nf">zuulFeature&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">HasFeatures&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">namedFeature&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Zuul (Simple)&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ZuulServerAutoConfiguration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//复合结构的RouteLocator
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Bean&lt;/span>
&lt;span class="nd">@Primary&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">CompositeRouteLocator&lt;/span> &lt;span class="nf">primaryRouteLocator&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">Collection&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">RouteLocator&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">routeLocators&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">CompositeRouteLocator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">routeLocators&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//没有SimpleRouteLocator.class的bean时, 使用zuulProperties实例化一个SimpleRouteLocator实例.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Bean&lt;/span>
&lt;span class="nd">@ConditionalOnMissingBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SimpleRouteLocator&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">SimpleRouteLocator&lt;/span> &lt;span class="nf">simpleRouteLocator&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">SimpleRouteLocator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">server&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getServletPrefix&lt;/span>&lt;span class="o">(),&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">zuulProperties&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//zuulController, 包装了一个ZuulServlet类型的servlet, 实现对ZuulServlet类型的servlet的初始化.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ZuulController&lt;/span> &lt;span class="nf">zuulController&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulController&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ZuulHandlerMapping&lt;/span> &lt;span class="nf">zuulHandlerMapping&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RouteLocator&lt;/span> &lt;span class="n">routes&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ZuulHandlerMapping&lt;/span> &lt;span class="n">mapping&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulHandlerMapping&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">routes&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">zuulController&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">mapping&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setErrorController&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">errorController&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">mapping&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ApplicationListener&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">ApplicationEvent&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">zuulRefreshRoutesListener&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulRefreshListener&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="nd">@ConditionalOnMissingBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;zuulServlet&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ServletRegistrationBean&lt;/span> &lt;span class="nf">zuulServlet&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ServletRegistrationBean&lt;/span> &lt;span class="n">servlet&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ServletRegistrationBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">ZuulServlet&lt;/span>&lt;span class="o">(),&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">zuulProperties&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getServletPattern&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="c1">// The whole point of exposing this servlet is to provide a route that doesn&amp;#39;t
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// buffer requests.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">servlet&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">addInitParameter&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;buffer-requests&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;false&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">servlet&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// pre filters
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ServletDetectionFilter&lt;/span> &lt;span class="nf">servletDetectionFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ServletDetectionFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">FormBodyWrapperFilter&lt;/span> &lt;span class="nf">formBodyWrapperFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">FormBodyWrapperFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">DebugFilter&lt;/span> &lt;span class="nf">debugFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DebugFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Servlet30WrapperFilter&lt;/span> &lt;span class="nf">servlet30WrapperFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Servlet30WrapperFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// post filters
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">SendResponseFilter&lt;/span> &lt;span class="nf">sendResponseFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">SendResponseFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">SendErrorFilter&lt;/span> &lt;span class="nf">sendErrorFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">SendErrorFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">SendForwardFilter&lt;/span> &lt;span class="nf">sendForwardFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">SendForwardFilter&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="nd">@ConditionalOnProperty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;zuul.ribbon.eager-load.enabled&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">matchIfMissing&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ZuulRouteApplicationContextInitializer&lt;/span> &lt;span class="nf">zuulRoutesApplicationContextInitiazer&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">SpringClientFactory&lt;/span> &lt;span class="n">springClientFactory&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulRouteApplicationContextInitializer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">springClientFactory&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">zuulProperties&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulFilterConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Autowired&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ZuulFilter&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">filters&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ZuulFilterInitializer&lt;/span> &lt;span class="nf">zuulFilterInitializer&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">CounterFactory&lt;/span> &lt;span class="n">counterFactory&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TracerFactory&lt;/span> &lt;span class="n">tracerFactory&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">FilterLoader&lt;/span> &lt;span class="n">filterLoader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FilterLoader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getInstance&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">FilterRegistry&lt;/span> &lt;span class="n">filterRegistry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FilterRegistry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">instance&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ZuulFilterInitializer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">filters&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">counterFactory&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">tracerFactory&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">filterLoader&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">filterRegistry&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="nd">@ConditionalOnClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">CounterService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulCounterFactoryConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="nd">@ConditionalOnBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">CounterService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">CounterFactory&lt;/span> &lt;span class="nf">counterFactory&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">CounterService&lt;/span> &lt;span class="n">counterService&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DefaultCounterFactory&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">counterService&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulMetricsConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="nd">@ConditionalOnMissingBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">CounterFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">CounterFactory&lt;/span> &lt;span class="nf">counterFactory&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">EmptyCounterFactory&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@ConditionalOnMissingBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TracerFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Bean&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">TracerFactory&lt;/span> &lt;span class="nf">tracerFactory&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">EmptyTracerFactory&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ZuulRefreshListener&lt;/span>
&lt;span class="kd">implements&lt;/span> &lt;span class="n">ApplicationListener&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">ApplicationEvent&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Autowired&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">ZuulHandlerMapping&lt;/span> &lt;span class="n">zuulHandlerMapping&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">HeartbeatMonitor&lt;/span> &lt;span class="n">heartbeatMonitor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HeartbeatMonitor&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">onApplicationEvent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ApplicationEvent&lt;/span> &lt;span class="n">event&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">event&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">ContextRefreshedEvent&lt;/span>
&lt;span class="o">||&lt;/span> &lt;span class="n">event&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">RefreshScopeRefreshedEvent&lt;/span>
&lt;span class="o">||&lt;/span> &lt;span class="n">event&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">RoutesRefreshedEvent&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">zuulHandlerMapping&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setDirty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">event&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">HeartbeatEvent&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">heartbeatMonitor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="o">(((&lt;/span>&lt;span class="n">HeartbeatEvent&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">event&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">getValue&lt;/span>&lt;span class="o">()))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">zuulHandlerMapping&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setDirty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="zuulproxyautoconfiguration-详解">ZuulProxyAutoConfiguration 详解&lt;/h5>
&lt;pre>&lt;code>​```java
//声明配置
@Configuration
//引入RibbonCommandFactory配置
@Import({ RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,
RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,
RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,
HttpClientConfiguration.class })
//配置生效条件
@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)
public class ZuulProxyAutoConfiguration extends ZuulServerAutoConfiguration {
@SuppressWarnings(&amp;quot;rawtypes&amp;quot;)
@Autowired(required = false)
private List&amp;lt;RibbonRequestCustomizer&amp;gt; requestCustomizers = Collections.emptyList();
//网关服务注册实例信息
@Autowired(required = false)
private Registration registration;
//服务发现客户端
@Autowired
private DiscoveryClient discovery;
//serviceId和路由的映射逻辑, 默认为相同
@Autowired
private ServiceRouteMapper serviceRouteMapper;
@Override
public HasFeatures zuulFeature() {
return HasFeatures.namedFeature(&amp;quot;Zuul (Discovery)&amp;quot;,
ZuulProxyAutoConfiguration.class);
}
//静态和动态路由寻址: 静态从配置文件获取, 动态通过服务发现客户端完成. 后者优先级更高
@Bean
@ConditionalOnMissingBean(DiscoveryClientRouteLocator.class)
public DiscoveryClientRouteLocator discoveryRouteLocator() {
return new DiscoveryClientRouteLocator(this.server.getServletPrefix(),
this.discovery, this.zuulProperties, this.serviceRouteMapper, this.registration);
}
//装饰过滤器
// pre filters
@Bean
public PreDecorationFilter preDecorationFilter(RouteLocator routeLocator,
ProxyRequestHelper proxyRequestHelper) {
return new PreDecorationFilter(routeLocator, this.server.getServletPrefix(),
this.zuulProperties, proxyRequestHelper);
}
//基于Ribbon路由过滤器
// route filters
@Bean
public RibbonRoutingFilter ribbonRoutingFilter(ProxyRequestHelper helper,
RibbonCommandFactory&amp;lt;?&amp;gt; ribbonCommandFactory) {
RibbonRoutingFilter filter = new RibbonRoutingFilter(helper, ribbonCommandFactory,
this.requestCustomizers);
return filter;
}
//基于host的路由过滤器
@Bean
@ConditionalOnMissingBean({SimpleHostRoutingFilter.class, CloseableHttpClient.class})
public SimpleHostRoutingFilter simpleHostRoutingFilter(ProxyRequestHelper helper,
ZuulProperties zuulProperties,
ApacheHttpClientConnectionManagerFactory connectionManagerFactory,
ApacheHttpClientFactory httpClientFactory) {
return new SimpleHostRoutingFilter(helper, zuulProperties,
connectionManagerFactory, httpClientFactory);
}
@Bean
@ConditionalOnMissingBean({SimpleHostRoutingFilter.class})
public SimpleHostRoutingFilter simpleHostRoutingFilter2(ProxyRequestHelper helper,
ZuulProperties zuulProperties,
CloseableHttpClient httpClient) {
return new SimpleHostRoutingFilter(helper, zuulProperties,
httpClient);
}
//服务发现寻址刷新监听器
@Bean
public ApplicationListener&amp;lt;ApplicationEvent&amp;gt; zuulDiscoveryRefreshRoutesListener() {
return new ZuulDiscoveryRefreshListener();
}
@Bean
@ConditionalOnMissingBean(ServiceRouteMapper.class)
public ServiceRouteMapper serviceRouteMapper() {
return new SimpleServiceRouteMapper();
}
@Configuration
@ConditionalOnMissingClass(&amp;quot;org.springframework.boot.actuate.endpoint.Endpoint&amp;quot;)
protected static class NoActuatorConfiguration {
@Bean
public ProxyRequestHelper proxyRequestHelper(ZuulProperties zuulProperties) {
ProxyRequestHelper helper = new ProxyRequestHelper();
helper.setIgnoredHeaders(zuulProperties.getIgnoredHeaders());
helper.setTraceRequestBody(zuulProperties.isTraceRequestBody());
return helper;
}
}
@Configuration
@ConditionalOnClass(Endpoint.class)
protected static class EndpointConfiguration {
@Autowired(required = false)
private TraceRepository traces;
@ConditionalOnEnabledEndpoint(&amp;quot;routes&amp;quot;)
@Bean
public RoutesEndpoint routesEndpoint(RouteLocator routeLocator) {
return new RoutesEndpoint(routeLocator);
}
@ConditionalOnEnabledEndpoint(&amp;quot;routes&amp;quot;)
@Bean
public RoutesMvcEndpoint routesMvcEndpoint(RouteLocator routeLocator,
RoutesEndpoint endpoint) {
return new RoutesMvcEndpoint(endpoint, routeLocator);
}
@ConditionalOnEnabledEndpoint(&amp;quot;filters&amp;quot;)
@Bean
public FiltersEndpoint filtersEndpoint() {
FilterRegistry filterRegistry = FilterRegistry.instance();
return new FiltersEndpoint(filterRegistry);
}
@Bean
public ProxyRequestHelper proxyRequestHelper(ZuulProperties zuulProperties) {
TraceProxyRequestHelper helper = new TraceProxyRequestHelper();
if (this.traces != null) {
helper.setTraces(this.traces);
}
helper.setIgnoredHeaders(zuulProperties.getIgnoredHeaders());
helper.setTraceRequestBody(zuulProperties.isTraceRequestBody());
return helper;
}
}
private static class ZuulDiscoveryRefreshListener
implements ApplicationListener&amp;lt;ApplicationEvent&amp;gt; {
private HeartbeatMonitor monitor = new HeartbeatMonitor();
@Autowired
private ZuulHandlerMapping zuulHandlerMapping;
@Override
public void onApplicationEvent(ApplicationEvent event) {
if (event instanceof InstanceRegisteredEvent) {
reset();
}
else if (event instanceof ParentHeartbeatEvent) {
ParentHeartbeatEvent e = (ParentHeartbeatEvent) event;
resetIfNeeded(e.getValue());
}
else if (event instanceof HeartbeatEvent) {
HeartbeatEvent e = (HeartbeatEvent) event;
resetIfNeeded(e.getValue());
}
}
private void resetIfNeeded(Object value) {
if (this.monitor.update(value)) {
reset();
}
}
private void reset() {
this.zuulHandlerMapping.setDirty(true);
}
}
}
​```
&lt;/code>&lt;/pre>
&lt;h2 id="配置项">配置项&lt;/h2>
&lt;p>&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15192869619623.jpg" alt="">&lt;/p>
&lt;h4 id="zuulservletpath">zuul.servletPath&lt;/h4>
&lt;p>默认为*/zuul*, 注册ZuulServlet的时候作为urlMapping使用. 即所有来自以*/zuul*开头的path都会由ZuulServlet处理.&lt;/p>
&lt;h4 id="zuulignoredpatterns">zuul.ignoredPatterns&lt;/h4>
&lt;p>Zuul使用&lt;code>ZuulController&lt;/code>封装了&lt;code>ZuulServlet&lt;/code>. 所有进入Zuul的请求的入口都是&lt;code>ZuulController&lt;/code>.
&lt;code>ZuulController&lt;/code>的&lt;code>ZuulHandlerMapping&lt;/code>默认把&lt;code>zuul.routes.[ITEM].path&lt;/code>的请求交给&lt;code>ZuulServlet&lt;/code>处理. 如果找不到对应的path的route, 则会走其他的&lt;code>DispatcherServlet&lt;/code>&lt;/p>
&lt;p>&lt;code>zuul.ignoredPatterns&lt;/code>作用就是进入Zuul的请求, 只要match都会直接交由其他的&lt;code>DispatcherServlet&lt;/code>处理, 而不需要先检查是否有对应path的route.&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="过滤器">过滤器&lt;/h2>
&lt;p>&lt;img src="http://7xvxng.com1.z0.glb.clouddn.com/15192707341614.jpg" alt="">&lt;/p>
&lt;h3 id="zuulserverautoconfiguration">ZuulServerAutoConfiguration&lt;/h3>
&lt;h4 id="servletdetectionfilter">ServletDetectionFilter&lt;/h4>
&lt;p>检查请求的入口是&lt;code>DispatcherServlet&lt;/code>还是&lt;code>ZuulServlet&lt;/code>
如果是&lt;code>DispatcherServlet&lt;/code>进来的请求, 将&lt;code>RequestContext&lt;/code>中的属性&lt;code>isDispatcherServletRequest&lt;/code>设置为ture.&lt;/p>
&lt;p>检查的方法是判断&lt;code>RequestContext&lt;/code>中的请求类型是否为&lt;code>HttpServletRequestWrapper&lt;/code>类型, 因为&lt;code>ZuulServlet&lt;/code>进来的请求会使用&lt;code>HttpServletRequestWrapper&lt;/code>进行再次封装; 同时检查请求中中是否有&lt;code>DispatcherServlet.CONTEXT&lt;/code>属性, 因为&lt;code>DispatcherServlet&lt;/code>进来的请求会带有该属性.&lt;/p>
&lt;h4 id="formbodywrapperfilter">FormBodyWrapperFilter&lt;/h4>
&lt;p>为下游的服务解析表单数据, 并重新编码. 只针对multipart/form-data和application/x-www-form-urlencoded类型的请求.&lt;/p>
&lt;h4 id="debugfilter">DebugFilter&lt;/h4>
&lt;p>通过设置&lt;code>zuul.debug.parameter&lt;/code>属性控制, 默认启用.
执行时将上下文中的&lt;code>debugRouting&lt;/code>和&lt;code>debugRequest&lt;/code>设置为&lt;code>true&lt;/code>&lt;/p>
&lt;h4 id="servlet30wrapperfilter">Servlet30WrapperFilter&lt;/h4>
&lt;p>使用&lt;code>Servlet30RequestWrapper&lt;/code>封装请求, 强制启用.&lt;/p>
&lt;h4 id="sendresponsefilter">SendResponseFilter&lt;/h4>
&lt;p>后执行的过滤器, 负责将代理请求的响应写入当前的请求的响应中.&lt;/p>
&lt;h3 id="zuulproxyautoconfiguration">ZuulProxyAutoConfiguration&lt;/h3>
&lt;h4 id="predecorationfilter">PreDecorationFilter&lt;/h4>
&lt;p>Pre类型的过滤器, 通过提供的RouteLocator决定将如何请求路由到哪里和如何路由. 同时为下游请求添加多个与代理相关的头信息. 当&lt;code>RequestContext&lt;/code>中不存在&lt;code>FORWARD_TO_KEY&lt;/code>和&lt;code>SERVICE_ID_KEY&lt;/code>信息时生效.&lt;/p>
&lt;p>将路由判断结果写入&lt;code>routeHost&lt;/code>, &lt;code>FORWARD_TO_KEY&lt;/code>或者&lt;code>SERVICE_ID_KEY&lt;/code>.&lt;/p>
&lt;h4 id="ribbonroutingfilter">RibbonRoutingFilter&lt;/h4>
&lt;p>Route类型的过滤器, 当&lt;code>RequestContext&lt;/code>中&lt;code>routeHost&lt;/code>为空, 且有&lt;code>serviceId&lt;/code>值时生效.&lt;/p>
&lt;p>使用&lt;code>RequestContext&lt;/code>构建&lt;code>RibbonCommandContext&lt;/code>, 通过&lt;code>RibbonCommandFactory&lt;/code>进而创建&lt;code>RibbonCommand&lt;/code>并执行. 最后通过&lt;code>ProxyRequestHelper&lt;/code>将响应结果记录到&lt;code>RequestContext&lt;/code>中.&lt;/p>
&lt;h4 id="simplehostroutingfilter">SimpleHostRoutingFilter&lt;/h4>
&lt;p>Route类型的过滤器, 当&lt;code>RequestContext&lt;/code>中的&lt;code>routeHost&lt;/code>不为空时生效. 使用Apache的HttpClient发送请求&lt;/p>
&lt;h2 id="监听器">监听器&lt;/h2>
&lt;h4 id="zuulrefreshlistener">ZuulRefreshListener&lt;/h4>
&lt;p>通过监听应用程序事件(&lt;code>ContextRefreshedEvent&lt;/code>, &lt;code>RefreshScopeRefreshedEvent&lt;/code>, &lt;code>RoutesRefreshedEvent&lt;/code>和&lt;code>RoutesRefreshedEvent&lt;/code>)更新handler mapping的注册信息. 前两个事件在&lt;code>ContextRefresh&lt;/code>时发出; 第三个是通过JMX重置路由时发出(参考&lt;code>RoutesMvcEndpoint&lt;/code>); 最后一个是&lt;code>DiscoveryClient&lt;/code>每次拉取服务注册信息后发出.&lt;/p>
&lt;p>收到事件后, 将&lt;code>ZuulHandlerMapping&lt;/code>的&lt;code>dirty&lt;/code>变量置为&lt;code>true&lt;/code>, 当下次请求进来时, 检查到&lt;code>dirty&lt;/code>为&lt;code>true&lt;/code>, 就会重新注册url mapping.&lt;/p>
&lt;h4 id="zuuldiscoveryrefreshlistener">ZuulDiscoveryRefreshListener&lt;/h4>
&lt;p>监听应用程序事件(&lt;code>InstanceRegisteredEvent&lt;/code>, &lt;code>ParentHeartbeatEvent&lt;/code>和&lt;code>HeartbeatEvent&lt;/code>)更新handler mapping的注册信息.&lt;/p>
&lt;p>&lt;code>InstanceRegisteredEvent&lt;/code>当前路由服务实例完成服务注册后发出的事件.
&lt;code>ParentHeartbeatEvent&lt;/code>当&lt;code>DiscoveryClient&lt;/code>定位到&lt;em>Config Server&lt;/em>服务的时候有&lt;code>bootstrapContext&lt;/code>发给应用程序上下文的事件.
&lt;code>HeartbeatEvent&lt;/code>由&lt;code>DiscoveryClient&lt;/code>每次拉取服务注册信息后发出.&lt;/p></description></item><item><title>Spring Cloud - Eureka Client源码分析</title><link>https://atbug.com/spring-cloud-eureka-client-source-code-analysis/</link><pubDate>Sat, 14 Oct 2017 22:04:59 +0000</pubDate><guid>https://atbug.com/spring-cloud-eureka-client-source-code-analysis/</guid><description>
&lt;p>准备做个Spring Cloud源码分析系列, 作为Spring Cloud的源码分析笔记.&lt;/p>
&lt;p>这一篇是Eureka的客户端.&lt;/p>
&lt;h2 id="客户端">客户端&lt;/h2>
&lt;p>两种方式, 最终的实现基本一样.&lt;/p>
&lt;h3 id="显示指定服务发现的实现类型">显示指定服务发现的实现类型&lt;/h3>
&lt;p>使用&lt;code>@EnableEurekaClient&lt;/code>注解显示的指定使用Eureka作为服务发现的实现, 并实例化&lt;code>EurekaClient&lt;/code>实例. 实际上使用的是&lt;code>@EnableDiscoveryClient&lt;/code>注解.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Target&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">TYPE&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Retention&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Documented&lt;/span>
&lt;span class="nd">@Inherited&lt;/span>
&lt;span class="nd">@EnableDiscoveryClient&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nd">@interface&lt;/span> &lt;span class="n">EnableEurekaClient&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="动态配置实现">动态配置实现&lt;/h3>
&lt;p>使用&lt;code>@EnableDiscoveryClient&lt;/code>注解来配置服务发现的实现.&lt;/p>
&lt;h4 id="源码分析">源码分析&lt;/h4>
&lt;p>&lt;strong>EnableDiscoveryClient&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Target&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">TYPE&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Retention&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Documented&lt;/span>
&lt;span class="nd">@Inherited&lt;/span>
&lt;span class="nd">@Import&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EnableDiscoveryClientImportSelector&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nd">@interface&lt;/span> &lt;span class="n">EnableDiscoveryClient&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>EnableDiscoveryClient&lt;/code>注解的作用主要是用来引入&lt;code>EnableDiscoveryClientImportSelector&lt;/code>&lt;/p>
&lt;p>&lt;strong>EnableDiscoveryClientImportSelector&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Order&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Ordered&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">LOWEST_PRECEDENCE&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">100&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">EnableDiscoveryClientImportSelector&lt;/span>
&lt;span class="kd">extends&lt;/span> &lt;span class="n">SpringFactoryImportSelector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">EnableDiscoveryClient&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEnabled&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RelaxedPropertyResolver&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">getEnvironment&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">getProperty&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="s">&amp;#34;spring.cloud.discovery.enabled&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Boolean&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Boolean&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">TRUE&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">hasDefaultFactory&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>EnableDiscoveryClientImportSelector&lt;/code>继承了&lt;code>SpringFactoryImportSelector&lt;/code>并指定了泛型&lt;code>EnableDiscoveryClient&lt;/code>. &lt;strong>这里的泛型是重点&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>SpringFactoryImportSelector&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SpringFactoryImportSelector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="kd">implements&lt;/span> &lt;span class="n">DeferredImportSelector&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">BeanClassLoaderAware&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">EnvironmentAware&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">ClassLoader&lt;/span> &lt;span class="n">beanClassLoader&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">annotationClass&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="nf">SpringFactoryImportSelector&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">annotationClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;)&lt;/span> &lt;span class="n">GenericTypeResolver&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">resolveTypeArgument&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">SpringFactoryImportSelector&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="nf">selectImports&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AnnotationMetadata&lt;/span> &lt;span class="n">metadata&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里只截取了部分变量和方法
&lt;code>SpringFactoryImportSelector&lt;/code>是spring cloud common包中的一个抽象类, 主要作用是检查泛型T是否有指定的factory实现, 即spring.factories中有对应类的配置.&lt;/p>
&lt;p>&lt;strong>spring.factories&lt;/strong>&lt;/p>
&lt;p>在&lt;code>spring-cloud-netflix-eureka-client.jar!/META-INF/spring.factories&lt;/code>中&lt;code>EnableDiscoveryClient&lt;/code>的指定factory实现是&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\
org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceAutoConfiguration,\
org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\
org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration
org.springframework.cloud.bootstrap.BootstrapConfiguration=\
org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration
org.springframework.cloud.client.discovery.EnableDiscoveryClient=\
org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时&lt;code>EnableAutoConfiguration&lt;/code>中包含了&lt;code>org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&lt;/code>, &lt;code>EurekaClientAutoConfiguration&lt;/code>会为&lt;code>EurekaDiscoveryClientConfiguration&lt;/code>的实例依赖进行初始化, 如EurekaClient. EurekaClient在构造时会启动一个HeartBeat线程, 线程在运行的时候会做renew的操作, 将Application的信息注册更新到Eureka的服务端.&lt;/p>
&lt;p>&lt;strong>EurekaDiscoveryClientConfiguration&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="nd">@EnableConfigurationProperties&lt;/span>
&lt;span class="nd">@ConditionalOnClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EurekaClientConfig&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@ConditionalOnProperty&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;eureka.client.enabled&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">matchIfMissing&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@CommonsLog&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">EurekaDiscoveryClientConfiguration&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">SmartLifecycle&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Ordered&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>