<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>架构 on 乱世浮生</title><link>https://atbug.com/tags/%E6%9E%B6%E6%9E%84/</link><description>Recent content in 架构 on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 11 Oct 2023 19:06:24 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>单体 or 微服务？Service Weaver：我全都要！</title><link>https://atbug.com/service-weaver-framework-for-writing-distributed-applications/</link><pubDate>Wed, 11 Oct 2023 19:06:24 +0800</pubDate><guid>https://atbug.com/service-weaver-framework-for-writing-distributed-applications/</guid><description>TL;DR 怎么理解 Service Weaver，就是一个应用中有很多的接口，这些接口间会互相调用。如果将操作系统进程（应用）比做一块电路板，接口比做元器件。可以选择将哪些元器件放入该电路板中，哪些元器件放入其他的电路板中。
同一块电路板中的元器件间通过板上的导线连接（进程内的本地方法调用）；不同电路板中的元器件间通过排线来连接（远程方法调用）。
总结几个关键词：
一个编程框架 用于编写、部署、管理分布式应用 支持的语言 Go 在本地以单进程、多进程运行 在云端由框架拆分成微服务，并于云供应商集成 单体方式开发，微服务方式部署 体验了一圈下来，给我的感觉有点类似 Notion、Obsidian 这类笔记软件。传统的笔记软件只能引用其他的笔记，而这类笔记可以细粒度到 heading 内容。
放到微服务下就是管理的维度不在是服务本身，而且更小的接口，并且对某些接口进行扩展，即使所有接口都位于同一个二进制文件中。
背景 架构的演进，总是在解决问题的过程中引入新的问题，然后再解决问题，循环往复。
从单体到微服务 软件架构从单体演进到微服务架构已经十多年了，尤其是近几年云原生风生水起，微服务架构已有深入人心的架势。
单体架构由于在规模扩大时，单体面临性能瓶颈和硬件限制、无法支撑业务的快读迭代、开发效率下降协同难度增加等原因，颓势日渐明显。然后就有了微服务架构的提出，来解决单体架构的各种问题。
上云 由于云平台提供显著的成本效益，减少初始投资并实现按需付费、提供极大的灵活性和可扩展性、提供的稳定性和可靠性确保业务连续性、专业的安全保障和合规性支持减轻企业的运营负担，企业将其业务和数据迁移至云计算平台。
问题 拆分成微服务，由此带来了不少好处：更高效的应用扩展、更小的错误传播半径、独立的安全域以及完善的模块边界。
反过来，如何正确地找到边界进行拆分并非易事。拆分的依据是什么？two pizza team？依据资源使用、组织架构、数据结构？亦或是考虑未来的增长？
微服务的拆分执行下来毫无章法，最终的结果是微服务越来越多、更多的故障点、更长的链路、更大的延迟。这实际上增加了应用的开发、部署和管理成本。
原本单个二进制文件，拆分后有多个；原本一次部署完成，拆分后需要多个 CI/CD 流水线来部署；原本一个配置文件，拆分后需要维护多个。 微服务彼此独立部署，无法忽略多版本的情况。需要调整部署策略来降低风险，同样还有本地开发和测试的难度增加。 学习成本高，需要学习如何将应用二进制文件包装成容器，并了解云的各种工具和部署方式，即使对经验丰富的程序员来说也难以理解。 同时还要解决分布式带来的各种问题，如服务发现、安全、负载均衡，以及服务间的调用。 延迟增加，时间消耗在数据的序列化以及网络传输上。 为什么用 Service Weaver？ 今年 3 月 Google 开源了 Service Weaver，希望能解决微服务架构的各种问题。</description></item><item><title>【译】分拆：技术栈的自然演进</title><link>https://atbug.com/the-unbundling-of-tech-stack-translation/</link><pubDate>Sun, 12 Feb 2023 20:26:32 +0800</pubDate><guid>https://atbug.com/the-unbundling-of-tech-stack-translation/</guid><description>本文翻译自 Bilgin Lbryam 的 Unbundling: The Natural Evolution of Tech Stacks，翻译难免有所疏漏，有建议请反馈。
“unbundling” 如何翻译，有点纠结，我一度将其翻译成“解耦”，但解耦是 “decoupling” 的翻译。这里我将其翻译成分拆，如果你有更好的翻译请告知。
译者注 作者应该是去年 7 月离开红帽加入了基于 Dapr 的创业公司 Diagrid，曾写过 Multi-Runtime Microservices Architecture 介绍多运行时，多运行时实际上也是分拆的体现。
作者从多种技术和团队触发，介绍在演进中分拆的体现。除了文中提到，我认为可以分拆的是计算资源。将计算资源拆分：虚拟机、多租户、多集群、多云、混合云，以降低成本、避免供应商绑定、提升性能和可靠性。在计算资源拆分过程中，也衍生出了与之配套的技术来解决拆分后带来的不便。
随着 IT 领域的不断发展，新的软件架构、开发技术和工具层出不穷。包括微服务、微前端、零信任、服务网格和数据网格，并将其网格化。尽管这些技术和方法间存在着明显的不同，但它们都被一个共同趋势联系在一起：技术栈和团队的分拆。这种趋势包括将系统分解成更小的、独立的组件，并将工作组织成更小、更专注的团队，以实现更高的灵活性和模块化。
他们都是如何体现分拆的？
微服务 的出现是为了应对单体架构的局限性，随着应用程序的增长单体架构灵活性不足，并且扩展和维护困难。通过将单体应用程序分解为更小的、独立服务，就可以独立开发、部署和扩展应用程序的每一部分，从而缩短开发周期并提高灵活性。 六边形架构 的出现是为了通过将组件解耦并提供与它们交互的标准接口来提高 3 层应用程序的灵活性和可维护性。 领域驱动设计 (DDD) 是一种软件开发方法，可以帮助将整体应用程序分解成更小的、松耦合的、代表不同的业务领域或上下文的模块。 微前端 架构是一种设计方法，是将大型单体前端应用程序分解为较小的、独立的、可以单独开发和部署的模块。 JAMstack 通过将构成用户界面的 HTML、CSS 和 JavaScript 与为应用程序提供支持的服务器端代码和数据库分离，实现应用程序的前端和后端分离。由于系统的一部分的变更无需变更其他部分，从而可以更轻松地维护应用。 服务网格 将分布式应用程序的网络职责（例如路由、负载平衡和服务发现）与应用程序本身分离，使开发人员可以专注于构建业务逻辑和功能，而无需担心底层网络基础设施。 与微服务类似，数据网格 将大型复杂系统分解为更小的独立组件。它将数据治理和管理实践分解为更小的、独立组件，这些组件可以跨不同的数据源和系统一致地实现和执行。 2 个比萨团队 模型是一种在组织中组织团队和工作的策略，它提倡更小的团队能够更快地响应变化、沟通和协作，并可以更快地做出决策并更有效地解决问题。 每种技术趋势的最终结果都是分拆。将技术栈分解为独立的组件，将团队分解为更小、更专注的团队，这些团队可能会扩展到所有其他领域。在前端、数据、网络、安全之后，下一个拆分领域你认为会是什么？ 和我一起 致力于 Dapr 和分拆集成。 也可以在 @bibryam 上关注我，并大声说出关于 分拆 主题的任何想法和评论。</description></item></channel></rss>