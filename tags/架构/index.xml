<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>架构 on 乱世浮生</title><link>https://atbug.com/tags/%E6%9E%B6%E6%9E%84/</link><description>Recent content in 架构 on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 26 May 2021 07:37:04 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Quarkus 和 MicroProfile 实现微服务特性</title><link>https://atbug.com/microservicilities-quarkus/</link><pubDate>Wed, 26 May 2021 07:37:04 +0800</pubDate><guid>https://atbug.com/microservicilities-quarkus/</guid><description>
&lt;p>Quarkus 的文章之前写过三篇了，讲过了 Quarkus 的小而快。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/YcEqFm3oxlsEvJ3ckRbQyA">Hello, Quarkus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dq3hQrXE4XWH-MyjBAGMEw">应&amp;quot;云&amp;quot;而生的 Java 框架 Quarkus：构建本机可执行文件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/1eqjYC36O3qm1XDw84aAPA">谁说 Java 不能用来跑 Serverless？&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一直在酝酿写一篇 Quarkus 生态相关的，因为最近一直在忙 Meetup 的事情而搁浅。正好看到了这篇文章，就拿来翻译一下，补全云原生中的“微服务”这一块。&lt;/p>
&lt;p>本文译自&lt;a href="https://www.infoq.com/articles/microservicilities-quarkus">《Implementing Microservicilities with Quarkus and MicroProfile》&lt;/a> 。&lt;/p>
&lt;hr>
&lt;h2 id="为什么要使用微服务特性">为什么要使用微服务特性？&lt;/h2>
&lt;p>在微服务架构中，一个应用程序是由几个相互连接的服务组成的，这些服务一起工作来实现所需的业务功能。&lt;/p>
&lt;p>因此，典型的企业微服务架构如下所示：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855266680.jpg" alt="">&lt;/p>
&lt;p>刚开始，使用微服务架构实现应用程序看起来很容易。&lt;/p>
&lt;p>但是，因为有了单体架构没有一些新的挑战，因此做起来并不容器&lt;/p>
&lt;p>举几个例子，比如容错、服务发现、扩展性、日志记录和跟踪。&lt;/p>
&lt;p>为了解决这些挑战，每个微服务都应实现我们在 Red Hat 所说的“微服务特性”。&lt;/p>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 该术语是指除业务逻辑以外，服务还必须实现来解决的跨领域关注点清单，如下图所示：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855419604.jpg" alt="">&lt;/p>
&lt;p>可以用任何语言（Java、Go、JavaScript）或任何框架（Spring Boot、Quarkus）实现业务逻辑，但是围绕业务逻辑，应实现以下关注点：&lt;/p>
&lt;p>&lt;strong>API&lt;/strong>：可通过一组定义的 API 操作来访问该服务。例如，对于 RESTful Web API，HTTP 用作协议。此外，可以使用诸如 Swagger 之类的工具来记录 API 。
&lt;strong>服务发现（Discovery）&lt;/strong>：服务需要发现其他服务。&lt;/p>
&lt;p>&lt;strong>调用服务（Invocation）&lt;/strong>：发现服务后，需要使用一组参数对其进行调用，并选择性地返回响应。&lt;/p>
&lt;p>&lt;strong>弹性（Elasticity）&lt;/strong>：微服务架构的重要特征之一是每个服务都是弹性的，这意味着可以根据系统的关键程度或当前的工作量等参数独立地进行缩放。（译者注：这里的弹性只是资源的弹性）&lt;/p>
&lt;p>&lt;strong>弹性（Resiliency）&lt;/strong>：在微服务架构中，我们在开发时应牢记失败，尤其是在与其他服务进行通信时。在单体应用中，整个应用程序处于启动或关闭状态。但是，当此应用程序分解为微服务体系结构时，该应用程序由多个服务组成，并且所有这些服务都通过网络互连，这意味着该应用程序的某些部分可能正在运行，而其他部分可能会失败。遏制故障对避免通过其他服务传播错误很重要。弹性（或应用程序弹性）是应用程序/服务对问题做出反应并仍然提供最佳结果的能力。（译者注：这里的弹性与容错相关，对失败处理的弹性）&lt;/p>
&lt;p>&lt;strong>管道（Pipeline）&lt;/strong>：服务应独立部署，而无需进行任何形式的编排。因此，每个服务应具有自己的部署管道。&lt;/p>
&lt;p>&lt;strong>身份验证（Authentication）&lt;/strong>：关于微服务体系结构中的安全性的关键方面之一是如何对内部服务之间的调用进行身份验证/授权。Web 令牌（通常是令牌）是在内部服务中安全地表示声明的首选方式。&lt;/p>
&lt;p>&lt;strong>日志记录（Logging）&lt;/strong>：在单体应用程序中，日志记录很简单，因为该应用程序的所有组件都在同一节点上运行。然后现在组件以服务的形式分布在多个节点上，因此，要拥有完整的日志记录视图，需要一个统一的日志记录系统/数据收集器。&lt;/p>
&lt;p>&lt;strong>监控（Monitoring）&lt;/strong>：衡量系统的性能、了解应用程序的整体运行状况，以及在出现问题时发出警报是保持基于微服务的应用程序正确运行的关键方面。监控是控制应用程序的关键方面。&lt;/p>
&lt;p>&lt;strong>跟踪（Tracing）&lt;/strong>：跟踪用于可视化程序的流程和数据进度。作为开发人员/运维人员，当我们需要检查用户在整个应用程序中的行程时，这特别有用。&lt;/p>
&lt;p>Kubernetes正在成为部署微服务的实际工具。这是一个用于自动化、编排、扩展和管理容器的开源系统。&lt;/p>
&lt;p>使用 Kubernetes 时，十个微服务特性中只有三个被涵盖。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855537970.jpg" alt="">&lt;/p>
&lt;p>**服务发现 **是通过 &lt;em>Kubernetes 服务&lt;/em>的概念实现的。它提供了一种使用稳定的虚拟 IP 和 DNS 名称将 Kubernetes Pod 分组（作为一个整体）的方法。发现服务只是使用 Kubernetes 的服务名作为 hostname 进行请求。&lt;/p>
&lt;p>使用 Kubernetes 可以很容易地&lt;strong>调用服务&lt;/strong>，因为平台本身提供了调用任何服务所需的网络。&lt;/p>
&lt;p>从一开始，Kubernetes 就一直在考虑&lt;strong>弹性&lt;/strong>（或可伸缩性），例如运行时&lt;code>kubectl scale deployment myservice --replicas=5 command&lt;/code>，myservice deployment 可伸缩至五个副本或实例。Kubernetes 平台负责寻找合适的节点，部署服务并始终保持所需数量的副本并正常运行。&lt;/p>
&lt;p>但是其余的微服务特性又如何呢？Kubernetes 仅涵盖其中的三个，那么我们如何实现剩下的呢？&lt;/p>
&lt;p>根据所使用的语言或框架，可以遵循的策略很多。但是在本文中，我们将了解如何使用 &lt;a href="https://quarkus.io/">Quarkus&lt;/a> 实现其中的一些&lt;a href="https://quarkus.io/">策略&lt;/a>。&lt;/p>
&lt;h2 id="什么是-quarkus">什么是 Quarkus？&lt;/h2>
&lt;p>&lt;a href="https://quarkus.io/">Quarkus&lt;/a> 是针对 Java 虚拟机（JVM）和本机编译的全栈 Kubernetes 本地 Java 框架，专门针对容器优化 Java，使其成为无服务器（Serverless）、云和 Kubernetes 环境的高效平台。&lt;/p>
&lt;p>Instead of reinventing the wheel, Quarkus uses well-known enterprise-grade frameworks backed by standards/specifications and makes them compilable to a binary using &lt;a href="https://www.graalvm.org/">GraalVM&lt;/a>.
Quarkus不用重新发明轮子，而是使用以标准/规范为后盾的知名企业级框架，并使用 &lt;a href="https://www.graalvm.org/">GraalVM&lt;/a> 将其编译为二进制&lt;a href="https://www.graalvm.org/">文件&lt;/a>。&lt;/p>
&lt;h2 id="什么是-microprofile">什么是 MicroProfile？&lt;/h2>
&lt;p>Quarkus 与 &lt;a href="https://microprofile.io/">MicroProfile&lt;/a> 规范集成，从而将企业 Java 生态系统迁移到微服务体系结构中。&lt;/p>
&lt;p>在下图中，我们看到了构成 MicroProfile 规范的所有 API。某些 API（例如 CDI、JSON-P 和 JAX-RS）基于 &lt;a href="https://jakarta.ee/">Jakarta EE&lt;/a>（以前的 Java EE）规范。其余的由 Java 社区开发。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855657899.jpg" alt="">&lt;/p>
&lt;p>Let’s implement API, invocation, resilience, authentication, logging, monitoring, and tracing microservicilities using Quarkus.
让我们使用Quarkus实现API、调用、弹性、身份验证、日志记录、监视和跟踪微服务特性。&lt;/p>
&lt;h2 id="如何使用-quarkus-实现微服务特性">如何使用 Quarkus 实现微服务特性&lt;/h2>
&lt;h3 id="入门">入门&lt;/h3>
&lt;p>开始使用 Quarkus 的最快方法是通过在&lt;a href="https://code.quarkus.io/">开始页面&lt;/a>中选择所需的依赖。对于当前示例，选择如下依赖关系以满足微服务需求：&lt;/p>
&lt;p>API：RESTEasy JAX-RS、RESTEasy JSON-B、OpenAPI
调用：REST Client JSON-B
弹性：Fault Tolerance
认证：JWT
记录：GELF
监控：Micrometer metrics
跟踪：OpenTracing&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855795760.jpg" alt="">&lt;/p>
&lt;p>我们可以手动选择各自的依赖关系，或浏览以下链接 &lt;a href="https://code.quarkus.io/?a=microservicilities-quarkus&amp;amp;e=resteasy&amp;amp;e=resteasy-jsonb&amp;amp;e=rest-client-jsonb&amp;amp;e=smallrye-jwt&amp;amp;e=smallrye-openapi&amp;amp;e=logging-gelf&amp;amp;e=smallrye-fault-tolerance&amp;amp;e=micrometer&amp;amp;e=smallrye-opentracing">Quarkus 微服务特性生成器&lt;/a>，所有这些都会被选中。然后按“生成应用程序”按钮以下载包含支架应用程序的zip文件。&lt;/p>
&lt;h3 id="服务">服务&lt;/h3>
&lt;p>对于当前示例，仅使用两个服务生成了一个非常简单的应用程序。一个名为“&lt;em>评级服务 rating service&lt;/em>”的服务返回给定书籍的评级，而另一个名为“&lt;em>书籍服务 book service&lt;/em>”的服务则返回一本书的信息及其评级。服务之间的所有调用都必须经过身份验证。&lt;/p>
&lt;p>在下图中，我们看到了整个系统的概述：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855936882.jpg" alt="">&lt;/p>
&lt;p>&lt;em>评级服务&lt;/em>已经开发并作为 Linux 容器提供。通过运行以下命令，在端口 9090 上启动服务：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --rm -ti -p 9090:8080
quay.io/lordofthejars/rating-service:1.0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>要验证服务，请向 http://localhost:9090/rate/1 发出请求&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl localhost:8080/rate/1 -vv
&amp;gt; GET /rate/1 HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; User-Agent: curl/7.64.1
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 &lt;span class="m">401&lt;/span> Unauthorized
&amp;lt; www-authenticate: Bearer &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span>
&amp;lt; Content-Length: &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回的状态码是 &lt;code>401 Unauthorized&lt;/code> 因为没有在请求中携带令牌（JWT）提供授权信息。只有带有 &lt;em>group &lt;code>Echoer&lt;/code>&lt;/em> 有效令牌才能访问评级服务。&lt;/p>
&lt;h3 id="api">API&lt;/h3>
&lt;p>Quarkus 使用众所周知的 JAX-RS 规范来定义 RESTful Web API。在幕后，Quarkus 使用 RESTEasy 实现直接与 Vert.X 框架一起使用，而无需使用 Servlet 技术。&lt;/p>
&lt;p>让我们为实现最常见操作的图书服务定义一个 API：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Consumes&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.DELETE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.GET&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.POST&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Path&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.PathParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Produces&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.QueryParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.MediaType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.Response&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.UriBuilder&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/book&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">BookResource&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="nd">@POST&lt;/span>
&lt;span class="nd">@Consumes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">getBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Book&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">created&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">UriBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">fromResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">BookResource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">book&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">bookId&lt;/span>&lt;span class="o">))&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">())&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@DELETE&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">delete&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">noContent&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;search&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">searchBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@QueryParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;description&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">description&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">ok&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">books&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先要注意的是，定义了四个不同的端点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GET /book/{bookId}&lt;/code> 使用 GET HTTP 方法返回带有其评级的图书信息。return 元素会自动解编为 JSON。&lt;/li>
&lt;li>&lt;code>POST /book&lt;/code> 使用 POST HTTP 方法插入一本书作为正文内容。正文内容会自动从 JSON 编组到 Java 对象。&lt;/li>
&lt;li>&lt;code>DELETE /book/{bookId}&lt;/code> 使用 DELETE HTTP 方法通过书的 ID 删除书。&lt;/li>
&lt;li>&lt;code>GET /book/search?description={description}&lt;/code> 按书名搜索书籍。&lt;/li>
&lt;/ul>
&lt;p>注意的第二件事是返回类型，有时是 Java 对象，有时是 Java 实例 &lt;code>javax.ws.rs.core.Response&lt;/code>。使用 Java 对象时，会将其从 Java 对象序列化为 &lt;code>@Produces&lt;/code> 注解中设置的媒体类型。在此特定服务中，输出为 JSON 文档。通过该 &lt;code>Response&lt;/code> 对象，我们可以对返回给调用方的内容进行细粒度的控制。可以设置 HTTP 状态代码、标头或返回给调用方的内容。取决于使用场景，是偏爱一种方法而不是另一种方法。&lt;/p>
&lt;h3 id="调用">调用&lt;/h3>
&lt;p>在定义了用于访问&lt;em>图书服务&lt;/em>的 API 之后，是时候开发一段代码来调用&lt;em>评级服务&lt;/em>以检索图书的评级了。&lt;/p>
&lt;p>Quarkus 使用 &lt;a href="https://github.com/eclipse/microprofile-rest-client">MicroProfile Rest Client&lt;/a> 规范来访问外部（HTTP）服务。它提供了一种类型安全的方法，以通过某些 JAX-RS 2.0 API 通过 HTTP 调用 RESTful 服务，以实现一致性和更易于重用。&lt;/p>
&lt;p>要创建的第一个元素是一个使用 JAX-RS 批注表示远程服务的接口。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.GET&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Path&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.PathParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Produces&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.MediaType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.rest.client.inject.RegisterRestClient&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/rate&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RegisterRestClient&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">RatingService&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the getRate() method is called, a remote HTTP call is invoked at /rate/{bookId} replacing the bookId with the value set in the method parameter. It is important to annotate the interface with the @RegisterRestClient annotation.
Then the RatingService interface needs to be injected into BookResource to execute the remote calls.
当 &lt;code>getRate() &lt;/code>方法被调用时，远程 HTTP 请求在调用 &lt;code>/rate/{bookId}&lt;/code> 替换 &lt;code>bookId&lt;/code> 用在该方法中的参数值集合。用 &lt;code>@RegisterRestClient&lt;/code> 注解对接口进行注解很重要。&lt;/p>
&lt;p>然后 &lt;code>RatingService&lt;/code> 需要将接口注入 &lt;code>BookResource&lt;/code> 以执行远程调用。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.rest.client.inject.RestClient&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@RestClient&lt;/span>
&lt;span class="n">RatingService&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Book&lt;/span> &lt;span class="n">book&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The @RestClient annotation injects a proxied instance of the interface, providing the implementation of the client.
The last thing is to configure the service location (the hostname part). In Quarkus, the configuration properties are set in src/main/resources/application.properties file. To configure the location of the service, we need to use the fully qualified name of the Rest Client interface with URL as key, and the location as a value:
该 &lt;code>@RestClient&lt;/code> 注解注入界面的代理实例，提供客户端的实现。&lt;/p>
&lt;p>最后一件事是配置服务位置（&lt;em>hostname&lt;/em> 部分）。在 Quarkus 中，配置属性在 &lt;code>src/main/resources/application.properties&lt;/code> 文件中设置。要配置服务的位置，我们需要使用 Rest Client 接口的标准名称，其中 URL 作为键，而 location 作为值：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.acme.RatingService/mp-rest/url=http://localhost:9090
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在正确访问&lt;em>评估服务&lt;/em>而没有 &lt;code>401 Unauthorized&lt;/code> 问题之前，必须解决相互认证问题。&lt;/p>
&lt;h3 id="身份验证">身份验证&lt;/h3>
&lt;p>基于令牌的身份验证机制允许系统基于安全令牌对身份进行身份验证、授权和验证。Quarkus 与 &lt;a href="https://github.com/eclipse/microprofile-jwt-auth">MicroProfile JWT RBAC 安全&lt;/a>规范集成在一起，以使用 JWT 令牌保护服务。&lt;/p>
&lt;p>要使用 MicroProfile JWT RBAC 安全性保护端点，我们只需要使用批注对方法进行 &lt;code>@RolesAllowed&lt;/code> 注解。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RolesAllowed&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Echoer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，我们配置令牌的发行方和公钥的位置，以验证令牌在 &lt;code>application.properties&lt;/code> 文件中的签名：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">mp.jwt.verify.publickey.location=https://raw.githubusercontent.com/redhat-developer-demos/quarkus-tutorial/master/jwt-token/quarkus.jwt.pub
mp.jwt.verify.issuer=https://quarkus.io/using-jwt-rbac
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此扩展名自动验证：令牌有效；发行方是正确的；令牌尚未修改；签名有效；没有过期。&lt;/p>
&lt;p>这两种&lt;em>图书服务&lt;/em>和&lt;em>评级服务&lt;/em>现在是由同一 JWT 发行方和密钥保护，因此服务之间的通信要求验证提供在令牌的有效承载用户 &lt;code>Authentication&lt;/code> 头部。&lt;/p>
&lt;p>&lt;em>评级服务&lt;/em>启动和运行，让我们开始用下面的命令&lt;em>图书服务&lt;/em>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">./mvnw compile quarkus:dev
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we can make a request to get book information providing a valid JSON Web Token as a bearer token.
The generation of the token is out of the scope of this article, and a token has been already generated:
最后，我们可以请求获取提供有效 JSON Web 令牌作为承载令牌的图书信息。&lt;/p>
&lt;p>令牌的生成不在本文的讨论范围之内，并且已经生成了令牌：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856429022.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">curl -H &amp;#34;Authorization: Bearer eyJraWQiOiJcL3ByaXZhdGVLZXkucGVtIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJqZG9lLXVzaW5nLWp3dC1yYmFjIiwiYXVkIjoidXNpbmctand0LXJiYWMiLCJ1cG4iOiJqZG9lQHF1YXJrdXMuaW8iLCJiaXJ0aGRhdGUiOiIyMDAxLTA3LTEzIiwiYXV0aF90aW1lIjoxNTcwMDk0MTcxLCJpc3MiOiJodHRwczpcL1wvcXVhcmt1cy5pb1wvdXNpbmctand0LXJiYWMiLCJyb2xlTWFwcGluZ3MiOnsiZ3JvdXAyIjoiR3JvdXAyTWFwcGVkUm9sZSIsImdyb3VwMSI6Ikdyb3VwMU1hcHBlZFJvbGUifSwiZ3JvdXBzIjpbIkVjaG9lciIsIlRlc3RlciIsIlN1YnNjcmliZXIiLCJncm91cDIiXSwicHJlZmVycmVkX3VzZXJuYW1lIjoiamRvZSIsImV4cCI6MjIwMDgxNDE3MSwiaWF0IjoxNTcwMDk0MTcxLCJqdGkiOiJhLTEyMyJ9.Hzr41h3_uewy-g2B-sonOiBObtcpkgzqmF4bT3cO58v45AIOiegl7HIx7QgEZHRO4PdUtR34x9W23VJY7NJ545ucpCuKnEV1uRlspJyQevfI-mSRg1bHlMmdDt661-V3KmQES8WX2B2uqirykO5fCeCp3womboilzCq4VtxbmM2qgf6ag8rUNnTCLuCgEoulGwTn0F5lCrom-7dJOTryW1KI0qUWHMMwl4TX5cLmqJLgBzJapzc5_yEfgQZ9qXzvsT8zeOWSKKPLm7LFVt2YihkXa80lWcjewwt61rfQkpmqSzAHL0QIs7CsM9GfnoYc0j9po83-P3GJiBMMFmn-vg&amp;#34; localhost:8080/book/1 -v
&lt;/code>&lt;/pre>&lt;/div>&lt;p>响应又是 forbidden 错误：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&amp;lt; HTTP/1.1 401 Unauthorized
&amp;lt; Content-Length: 0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可能想知道为什么在提供有效令牌后仍然出现此错误。如果我们检查图书服务的控制台，就会发现抛出了以下异常：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.jboss.resteasy.client.exception.ResteasyWebApplicationException: Unknown error, status code 401
at org.jboss.resteasy.client.exception.WebApplicationExceptionWrapper.wrap(WebApplicationExceptionWrapper.java:107)
at org.jboss.resteasy.microprofile.client.DefaultResponseExceptionMapper.toThrowable(DefaultResponseExceptionMapper.java:21)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发生此异常的原因是，我们已获得身份验证并有权访问&lt;em>图书服务&lt;/em>，但承载令牌尚未传播到&lt;em>评级服务&lt;/em>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856618998.jpg" alt="">&lt;/p>
&lt;p>为了自动将 &lt;code>Authorization&lt;/code> 标头从传入请求传播到其余客户端请求，需要进行两次修改。&lt;/p>
&lt;p>第一个修改是修改 Rest Client 界面，并使用对其进行注解 &lt;code>org.eclipse.microprofile.rest.client.inject.RegisterClientHeaders&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/rate&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RegisterRestClient&lt;/span>
&lt;span class="nd">@RegisterClientHeaders&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">RatingService&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二个修改是配置在请求之间传播哪些标头。这是在 &lt;code>application.properties&lt;/code> 文件中设置的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"> org.eclipse.microprofile.rest.client.propagateHeaders=Authorization
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行与之前相同的 curl 命令，我们将获得正确的输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&amp;lt; HTTP/1.1 &lt;span class="m">200&lt;/span> OK
&amp;lt; Content-Length: &lt;span class="m">39&lt;/span>
&amp;lt; Content-Type: application/json
&amp;lt;
* Connection &lt;span class="c1">#0 to host localhost left intact&lt;/span>
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:2,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 2&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:1&lt;span class="o">}&lt;/span>* Closing connection &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="弹性">弹性&lt;/h3>
&lt;p>在微服务架构中，具有容错能力很重要，这样可以避免故障从一个服务传播到该服务的所有直接和间接调用方。Quarkus 将 &lt;a href="https://github.com/eclipse/microprofile-fault-tolerance">MicroProfile Fault Tolerance&lt;/a> 规范与以下用于处理故障的注释集成在一起：&lt;/p>
&lt;p>●    &lt;code>@Timeout&lt;/code>：定义抛出异常之前执行的最长时间。
●    &lt;code>@Retry&lt;/code>：如果调用失败，请再次重试执行。
●    &lt;code>@Bulkhead&lt;/code>：限制并发执行，以使该区域中的故障不会使整个系统过载。
●    &lt;code>@CircuitBreaker&lt;/code>：执行反复失败时，将自动进行快速故障切换。
●    &lt;code>@Fallback&lt;/code>：执行失败时，提供备用解决方案/默认值。&lt;/p>
&lt;p>让我们添加三次重试，其中重试之间的延迟计时器为一秒，以防访问&lt;em>评级服务&lt;/em>时发生错误。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Retry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxRetries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，停止&lt;em>评级服务&lt;/em>并执行请求。引发以下异常：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.jboss.resteasy.spi.UnhandledException: javax.ws.rs.ProcessingException: RESTEASY004655: Unable to invoke request:
org.apache.http.conn.HttpHostConnectException: Connect to localhost:9090 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused
&lt;/code>&lt;/pre>&lt;/div>&lt;p>显然，这里存在错误，但是请注意，由于执行了三次重试（延迟一秒），因此引发异常之前，经过了三秒钟。&lt;/p>
&lt;p>在这种情况下，&lt;em>评级服务&lt;/em>已关闭，因此无法进行恢复，但是在一个实际示例中，&lt;em>评级服务&lt;/em>可能仅在短时间内就恢复了，或者部署了该服务的多个副本，因此可以简单地重试操作可能足以恢复并提供有效的响应。&lt;/p>
&lt;p>但是，当引发异常时重试次数不够时，我们可以将错误传播给调用方，也可以为调用提供替代值。这种选择可以是对另一个系统的调用（即分布式缓存）或静态值。&lt;/p>
&lt;p>对于此用例，当与评级服务的连接失败时，将返回评级值 0。&lt;/p>
&lt;p>要实现回退逻辑，首先要做的是实现将 &lt;code>org.eclipse.microprofile.faulttolerance.FallbackHandler&lt;/code> 返回类型设置为与回退策略方法提供的替代类型相同的接口。对于这种情况，将 &lt;code>Rate&lt;/code> 返回默认对象。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.faulttolerance.ExecutionContext&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.faulttolerance.FallbackHandler&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">RatingServiceFallback&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">FallbackHandler&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rate&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="nf">handle&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ExecutionContext&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Rate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">rate&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rate&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后要做的是用注解对 &lt;code>getRating()&lt;/code> 方法进行 &lt;code>@org.eclipse.microprofile.faulttolerance.Fallback&lt;/code> 注解，以配置无法恢复时要执行的回退类。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Retry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxRetries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Fallback&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RatingServiceFallback&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果重复与以前相同的请求，则不会引发任何异常，但是有效值的输出将 rating 字段设置为 0。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">* Connection #0 to host localhost left intact
{&amp;#34;bookId&amp;#34;:2,&amp;#34;name&amp;#34;:&amp;#34;Book 2&amp;#34;,&amp;#34;rating&amp;#34;:0}* Closing connection 0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>规范提供的任何其他策略都可以使用相同的方法。例如，对于断路器模式：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@CircuitBreaker&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">requestVolumeThreshold&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">4&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">failureRatio&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">75&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在四个连续调用的滚动窗口中发生了三个（&lt;em>4 x 0.75&lt;/em>）故障，则电路将断开 1000 ms，然后恢复到半断开状态。如果在半开时调用成功，则将其再次关闭。否则，它将保持打开状态&lt;/p>
&lt;h3 id="日志记录">日志记录&lt;/h3>
&lt;p>在微服务架构中，建议将所有服务的日志收集在一个统一的日志中，以更有效地使用和理解。&lt;/p>
&lt;p>一种解决方案是使用 &lt;a href="https://www.fluentd.org/">Fluentd&lt;/a>，它是 &lt;a href="https://www.fluentd.org/">Kubernetes&lt;/a> 中用于统一日志记录层的开源数据收集器。Quarkus 使用 Graylog 扩展日志格式（GELF）与 Fluentd 集成。&lt;/p>
&lt;p>集成真的很简单。首先，与其他任何 Quarkus 应用程序一样使用日志逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.jboss.logging.Logger&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Logger&lt;/span> &lt;span class="n">LOG&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getLogger&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">BookResource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RolesAllowed&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Echoer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">LOG&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Get Book&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，启用 GELF 格式并设置 Fluentd 服务器位置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">quarkus.log.handler.gelf.enabled=true
quarkus.log.handler.gelf.host=localhost
quarkus.log.handler.gelf.port=12201
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，我们可以向记录的端点发出请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出方面没有任何变化，但是日志行已传输到 Fluentd。如果使用 &lt;a href="https://www.elastic.co/kibana">Kibana&lt;/a> 可视化数据，我们将看到存储的日志行：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856876241.jpg" alt="">&lt;/p>
&lt;h3 id="监控">监控&lt;/h3>
&lt;p>监控是另一个需要在我们的微服务架构中实现的 “微服务特性”。Quarkus 与 &lt;a href="https://micrometer.io/">Micrometer&lt;/a> 集成在一起以进行应用程序监控。Micrometer 提供了最流行的监控系统的单个入口点，使你无需供应商锁定即可检测基于 JVM 的应用程序代码。&lt;/p>
&lt;p>对于此示例，监控输出采用 &lt;a href="https://prometheus.io/">Prometheus&lt;/a> 格式，但 Micrometer（和 Quarkus）还支持其他格式，例如 Azure Monitor、Stackdriver、SignalFx、StatsD 和 DataDog。&lt;/p>
&lt;p>你可以注册以下 Maven 依赖项以提供 Prometheus 输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.quarkus&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>quarkus-micrometer-registry-prometheus&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，Micrometer 扩展注册了一些与系统，JVM 或 HTTP 相关的度量。收集的指标的一个子集在 &lt;code>/q/metrics&lt;/code> 端点处可用，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl localhost:8080/q/metrics
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;runnable&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 22.0
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;blocked&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 0.0
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;waiting&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 10.0
http_server_bytes_read_count 1.0
http_server_bytes_read_sum 0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，也可以使用 Micrometer API 来实现特定于应用程序的指标。
让我们实现一个自定义指标，该指标用于衡量评价最高的图书。&lt;/p>
&lt;p>使用 &lt;code>io.micrometer.core.instrument.MeterRegistry&lt;/code> 该类可以完成指标（在这种情况下为量规）的注册。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">MeterRegistry&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">LongAccumulator&lt;/span> &lt;span class="n">highestRating&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LongAccumulator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">BookResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MeterRegistry&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">registry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">registry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">gauge&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;book.rating.max&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">BookResource&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">highestRatingBook&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求一下，并验证量规是否正确更新。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
curl localhost:8080/q/metrics
&lt;span class="c1"># HELP book_rating_max&lt;/span>
&lt;span class="c1"># TYPE book_rating_max gauge&lt;/span>
book_rating_max 3.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还可以设置一个计时器来记录从&lt;em>评级服务&lt;/em>获取评级信息所花费的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">Supplier&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rate&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">rateSupplier&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">};&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">timer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;book.rating.test&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">wrap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">rateSupplier&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求一下，并验证收集评价​​所花费的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"># HELP book_rating_test_seconds
# TYPE book_rating_test_seconds summary
book_rating_test_seconds_count 4.0
book_rating_test_seconds_sum 1.05489108
# HELP book_rating_test_seconds_max
# TYPE book_rating_test_seconds_max gauge
book_rating_test_seconds_max 1.018622001
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Micrometer 使用 &lt;code>MeterFilter&lt;/code> 实例来自定义 &lt;code>MeterRegistry&lt;/code> 实例发出的度量。Micrometer 扩展将检测 &lt;code>MeterFilter&lt;/code> CDI bean，并在初始化 &lt;code>MeterRegistry&lt;/code> 实例时使用它们。&lt;/p>
&lt;p>例如，我们可以定义一个通用标签来设置运行应用程序的环境（产品、测试、预发布等）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Singleton&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MicrometerCustomConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Produces&lt;/span>
&lt;span class="nd">@Singleton&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">MeterFilter&lt;/span> &lt;span class="nf">configureAllRegistries&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">MeterFilter&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">commonTags&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Arrays&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">asList&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">Tag&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">of&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;env&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;prod&amp;#34;&lt;/span>&lt;span class="o">)));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发送新请求并验证指标是否已标记。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">http_client_requests_seconds_max{clientName=&amp;#34;localhost&amp;#34;,env=&amp;#34;prod&amp;#34;,method=&amp;#34;GET&amp;#34;,outcome=&amp;#34;SUCCESS&amp;#34;,status=&amp;#34;200&amp;#34;,uri=&amp;#34;/rate/2&amp;#34;,} 0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意 &lt;code>env&lt;/code> 包含值为 &lt;code>prod&lt;/code> 的标签。&lt;/p>
&lt;h3 id="跟踪">跟踪&lt;/h3>
&lt;p>Quarkus 应用程序利用 &lt;a href="https://opentracing.io/">OpenTracing&lt;/a> 规范为交互式 Web 应用程序提供分布式跟踪。&lt;/p>
&lt;p>让我们配置 OpenTracing 以连接到 Jaeger 服务器，将 book-service 设置为服务名称以标识跟踪：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">quarkus.jaeger.enabled=true
quarkus.jaeger.endpoint=http://localhost:14268/api/traces
quarkus.jaeger.service-name=book-service
quarkus.jaeger.sampler-type=const
quarkus.jaeger.sampler-param=1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在发一个请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1 &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问Jaeger UI以验证是否跟踪了该调用：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219857070960.jpg" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>与开发整体应用程序相比，开发和实现微服务体系结构更具挑战性。我们认为，微服务可以驱动你根据应用程序基础结构正确地开发服务。&lt;/p>
&lt;p>此处介绍的大多数微服务（API 和管道除外）是新的，或者在整体应用中实现方式有所不同。原因是现在应用程序被分解成几部分，所有部分都在网络中互连。&lt;/p>
&lt;p>如果你May 26, 2021打算开发微服务并将其部署到 Kubernetes，那么 Quarkus 是一个很好的解决方案，因为它可以与 Kubernetes 顺利集成。实施大多数微服务很简单，只需要几行代码。&lt;/p>
&lt;p>本文演示的源代码可以在 &lt;a href="https://github.com/lordofthejars/microservicilities-quarkus">github&lt;/a> 上找到。&lt;/p>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219857200384.jpg" alt="">&lt;/p>
&lt;p>Alex Soto 是 Red Hat 开发人员经验总监。他对 Java 世界，软件自动化充满热情，并且他相信开源软件模型。Soto 是 &lt;a href="https://www.manning.com/books/testing-java-microservices">Manning&lt;/a> 的合著者 | &lt;a href="https://www.manning.com/books/testing-java-microservices">测试 Java 微服务&lt;/a>和 &lt;a href="https://www.oreilly.com/library/view/quarkus-cookbook/9781492062646/">O&amp;rsquo;Reilly Quarkus Cookbook&lt;/a> 和几个开源项目的贡献者。自 2017 年以来一直是 Java 冠军，他还是 Salle URL University 的国际演讲者和老师。你可以在 Twitter （Alex Soto）上关注他，以随时了解 Kubernetes 和 Java 世界中正在发生的事情。&lt;/p></description></item><item><title>【译】2021 年及未来的云原生预测</title><link>https://atbug.com/translation-cloud-native-predictions-for-2021-and-beyond/</link><pubDate>Tue, 09 Feb 2021 06:43:54 +0800</pubDate><guid>https://atbug.com/translation-cloud-native-predictions-for-2021-and-beyond/</guid><description>
&lt;p>本文译自 &lt;a href="https://www.cncf.io/blog/2021/01/29/cloud-native-predictions-for-2021-and-beyond/">Cloud Native Predictions for 2021 and Beyond&lt;/a>&lt;/p>
&lt;p>原文发布在 &lt;a href="https://www.aniszczyk.org/2021/01/19/cloud-native-predictions-for-2021-and-beyond/">Chris Aniszczyk 的个人博客&lt;/a>&lt;/p>
&lt;p>我希望每个人都有一个美好的假期，因为 2021 年 1 月的前几周一直非常疯狂，从叛乱到新的 COVID 菌株。在云原生国度，CNCF 最近发布了关于我们去年完成的所有工作的&lt;a href="https://www.cncf.io/cncf-annual-report-2020/">年度报告&lt;/a>。我建议大家找个机会去看一下这份报告，在疫情大流行的这一年，我们收获颇丰。&lt;a href="https://twitter.com/CloudNativeFdn/status/1343914259177222145">https://twitter.com/CloudNativeFdn/status/1343914259177222145&lt;/a>&lt;/p>
&lt;p>作为我工作的一部分，我对云原生趋势有一个独特的观点，送给所有与我合作的会员公司和开发人员，所以我想我会分享我对 2021 年及以后云原生发展的想法。&lt;/p>
&lt;p>&lt;strong>云原生的 IDE&lt;/strong>&lt;/p>
&lt;p>作为一个在 Eclipse 基金会内部从事开发者工具工作的人，我对最近的技术状态进展感到无比兴奋。未来，开发生命周期（代码、构建、调试）将主要发生在云端，而不是你本地的 Emacs 或 VSCode。你将每一个拉动请求最终得到一个完整的开发环境设置，预先配置并连接到他们自己的部署，以协助你的开发和调试需求。今天这种技术的一个具体例子是通过 GitHub &lt;a href="https://github.com/features/codespaces">Codespaces&lt;/a> 和 &lt;a href="https://gitpod.io/">GitPod&lt;/a> 实现的。虽然 GitHub Codespaces 还处于测试阶段，但今天你可以通过 GitPod 来体验，以 &lt;a href="https://gitpod.io/#https://github.com/prometheus/prometheus">Prometheus&lt;/a> 为例。一分钟左右，你就拥有了一个有编辑器和预览环境的完全实时的开发环境。最疯狂的是，这个开发环境（工作空间）是 &lt;a href="https://github.com/prometheus/prometheus/blob/master/.gitpod.yml">用代码描述&lt;/a>，并且可以像其他代码工件一样，与你团队的其他开发者共享。&lt;/p>
&lt;p>最后，我期望在接下来的一年里，能看到云原生 IDE 领域出现令人难以置信的创新，特别是随着 GitHub Codespaces 进入测试版之后，并得到广泛地使用，让开发者可以体验到这个新概念，并爱上它。&lt;/p>
&lt;p>&lt;strong>边缘的 Kubernetes&lt;/strong>&lt;/p>
&lt;p>Kubernetes 是通过在大规模数据中心的使用而诞生的，但 Kubernetes 会像 Linux 一样为新的环境而进化。Linux 所发生的事情是，终端用户最终对内核进行了扩展，以支持从移动、嵌入式等各种新的部署场景。我坚信 Kubernetes 也会经历类似的进化，我们已经见证了 Telcos（和其他初创公司）通过将 VNFs 转化为 &lt;a href="https://github.com/cncf/cnf-wg">云原生网络功能&lt;/a>（CNFs），以及 &lt;a href="https://k3s.io/">k3s&lt;/a>、KubeEdge、k0s、&lt;a href="https://www.lfedge.org/">LFEdge&lt;/a>、Eclipse ioFog 等开源项目，来探索 Kubernetes 作为边缘平台。推动超大规模云服务支持电信公司和边缘的能力，再加上重用云原生软件的能力，以及建立在现有庞大的生态系统基础上的能力，将巩固 Kubernetes 在未来几年内成为边缘计算的主导平台。&lt;/p>
&lt;p>&lt;strong>云原生 + Wasm&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://webassembly.org/">Web Assembly&lt;/a>(Wasm) 是一项新的技术，但我预计它将成为云原生生态系统中不断增长的实用工具和工作负载，特别是随着 &lt;a href="https://wasi.dev/">WASI&lt;/a> 的成熟，以及 Kubernetes 更多地作为边缘编排工具使用，如前所述。一个场景是增强扩展机制，就像 Envoy 对过滤器和 LuaJIT 所做的那样。你可以与一个支持各种编程语言的更小的优化运行时协同，而不是直接与 Lua 打交道。Envoy 项目目前正处于 &lt;a href="https://www.solo.io/blog/the-state-of-webassembly-in-envoy-proxy/">采用 Wasm&lt;/a> 的过程中，我预计任何使用脚本语言作为流行扩展机制的环境都会出现被 Wasm 全盘取代的情况。&lt;/p>
&lt;p>在 Kubernetes 方面，有像微软的 &lt;a href="https://deislabs.io/posts/introducing-krustlet/">Krustlet&lt;/a> 这样的项目，正在探索如何在 Kubernetes 中支持基于 WASI 的运行时。这不应该太令人惊讶，因为 Kubernetes 已经在通过 CRD 和其他机制扩展，以运行不同类型的工作负载，如 VM（&lt;a href="https://kubevirt.io/">KubeVirt&lt;/a>）等等。&lt;/p>
&lt;p>另外，如果你是 Wasm 的新手，我推荐 Linux 基金会的这本新的 &lt;a href="https://www.edx.org/course/introduction-to-webassembly-runtime">入门课程&lt;/a>，它对其进行了介绍，以及优选的文档。&lt;/p>
&lt;p>&lt;strong>FinOps 的崛起（CFM）&lt;/strong>&lt;/p>
&lt;p>新冠病毒的爆发加速了向云原生的转变。至少有一半的公司在危机中加快了他们的云计划。近 60% 的受访者表示，由于 COVID-19 大流行，云计算的使用量将超过之前的计划 (&lt;a href="https://info.flexera.com/SLO-CM-REPORT-State-of-the-Cloud-2020">2020 年云计算现状报告&lt;/a>)。除此之外，云财务管理 (或 FinOps) 对许多公司来说是一个日益严重的问题和 &lt;a href="https://www.wsj.com/articles/cloud-bills-will-get-loftier-1518363001">关注&lt;/a>，老实说，在过去 6 个月里，我与正在进行云原生之旅的公司进行的讨论中，大约有一半的讨论都会提到这个问题。你也可以说，云提供商没有动力让云财务管理变得更容易，因为这将使客户更容易减少支出，然而，在我看来，真正的痛苦是缺乏围绕云财务管理的开源创新和标准化（所有的云都以不同的方式进行成本管理）。在 CNCF 的背景下，试图让 FinOps 变得更容易的开源项目并不多，有 &lt;a href="https://github.com/kubecost/cost-model">KubeCost&lt;/a> 项目，但还相当早期。&lt;/p>
&lt;p>另外，Linux 基金会最近推出了 &lt;a href="https://www.finops.org/blog/linux-foundation">FinOps 基金会&lt;/a> 来帮助这个领域的创新，他们在这个领域有一些 &lt;a href="https://www.edx.org/course/introduction-to-finops">很棒的入门材料&lt;/a>。我期望在未来几年，在 FinOps 领域能看到更多的开源项目和规范。&lt;/p>
&lt;p>&lt;strong>云原生中更多的使用 Rust&lt;/strong>&lt;/p>
&lt;p>Rust 仍然是一门年轻而小众的编程语言，特别是如果你以 Redmonk 的 &lt;a href="https://redmonk.com/sogrady/2020/07/27/language-rankings-6-20/">编程语言排名&lt;/a> 为例。然而，我的感觉是，鉴于已经有一些 &lt;a href="https://www.cncf.io/blog/2020/06/22/rust-at-cncf/">使用 Rust 的 CNCF 项目&lt;/a>，以及它出现在像 microvm &lt;a href="https://firecracker-microvm.github.io/">Firecracker&lt;/a> 这样有趣的基础设施项目中，你将在未来一年中看到 Rust 出现在更多的云原生项目中。虽然 CNCF 目前有超多的项目是用 Golang 编写的，但我预计随着 &lt;a href="https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html">Rust 社区的成熟&lt;/a>，几年后基于 Rust 的项目将与基于 Go 的项目平起平坐。&lt;/p>
&lt;p>&lt;strong>GitOps+CD/PD 增长显著&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.weave.works/blog/what-is-gitops-really">GitOps&lt;/a> 是云原生技术的一种操作模式，提供了一套统一部署、管理和监控应用程序的最佳实践 (最初是由 Weaveworks 名气很大的 Alexis Richardson&lt;a href="https://www.weave.works/blog/gitops-operations-by-pull-request">创造&lt;/a>)。GitOps 最重要的方面是通过声明的方式描述所需的在 Git 中版本化的系统状态，这基本上可以使一系列复杂的系统变更被正确地应用，然后进行验证（通过 Git 和其他工具启用的漂亮的审计日志）。从实用的角度来看，GitOps 改善了开发者的体验，随着 Argo、GitLab、Flux 等项目的发展，我预计今年 GitOps 工具会更多地冲击企业。如果你看过 GitLab 的 &lt;a href="https://about.gitlab.com/blog/2020/07/14/gitops-next-big-thing-automation/">数据&lt;/a>，GitOps 还是一个大部分公司还没有探索出来的新兴的实践，但随着越来越多的公司大规模采用云原生软件，我认为 GitOps 自然会随之而来。如果你有兴趣了解更多关于这个领域的信息，我推荐你去看看 CNCF 中 &lt;a href="https://codefresh.io/devops/announcing-gitops-working-group/">新&lt;/a> 成立的 &lt;a href="https://github.com/gitops-working-group/gitops-working-group">GitOps 工作组&lt;/a>。&lt;/p>
&lt;p>&lt;strong>服务目录2.0：云原生开发者仪表盘&lt;/strong>&lt;/p>
&lt;p>服务目录的概念并不是一个新事物，对于我们一些在 &lt;a href="https://en.wikipedia.org/wiki/ITIL">ITIL&lt;/a> 时代成长起来的老人们来说，你可能还记得 &lt;a href="https://en.wikipedia.org/wiki/Configuration_management_database">CMDBs&lt;/a> （恐怖）等东西。然而，随着微服务和云原生开发的兴起，对服务进行编目和索引各种实时服务元数据的能力对于推动开发者自动化是至关重要的。这可以包括使用服务目录来了解所有权来处理事件管理、管理 SLO 等。&lt;/p>
&lt;p>在未来，你将看到开发人员仪表盘的趋势，它不仅是一个服务目录，而且提供了通过各种自动化功能在扩展仪表盘的能力。这方面的典范开源例子是 Lyft 的 &lt;a href="https://engineering.atspotify.com/2020/03/17/what-the-heck-is-backstage-anyway/">Backstage&lt;/a> 和 &lt;a href="https://eng.lyft.com/announcing-clutch-the-open-source-platform-for-infrastructure-tooling-143d00de9713">Clutch&lt;/a>，然而，任何拥有相当现代的云原生部署的公司往往都有一个平台基础设施团队，他们已经尝试构建类似的东西。随着开源开发者仪表盘与 &lt;a href="https://backstage.io/plugins">大型插件生态系统&lt;/a> 的成熟，你会看到其被各地的平台工程团队加速采用。&lt;/p>
&lt;p>&lt;strong>跨云变得更真实&lt;/strong>&lt;/p>
&lt;p>Kubernetes 和云原生运动已经证明了云原生和多云方式在生产环境中是可行的，数据很清楚地表明“93% 的企业都有使用微软 Azure、亚马逊网络服务和谷歌云等多个提供商的策略” (&lt;a href="https://info.flexera.com/SLO-CM-REPORT-State-of-the-Cloud-2020">2020 年云计算现状报告&lt;/a>)。事实上，Kubernetes 这些年伴随着云市场的发展而更加成熟，将有望解锁程序化的跨云管理服务。这种方法的一个具体例子体现在 Crossplane 项目中，该项目提供了一个开源的跨云控制平面，利用 Kubernetes API 的可扩展性来实现跨云工作负载管理（参见 &lt;a href="https://thenewstack.io/gitlab-deploys-the-crossplane-control-plane-to-offer-multicloud-deployments/">&amp;ldquo;GitLab 部署 Crossplane 控制平面，提供多云部署 &amp;ldquo;&lt;/a>）。&lt;/p>
&lt;p>&lt;strong>主流 eBPF&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">eBPF&lt;/a> 允许你在不改变内核代码或加载模块的情况下，在 Linux 内核中运行程序，你可以把它看作是一种沙箱扩展机制。eBPF 允许 &lt;a href="https://ebpf.io/projects">新一代软件&lt;/a> 从改进的网络、监控和安全等各种不同的方向扩展 Linux 内核的行为。从历史上看，eBPF 的缺点是它需要一个现代的内核版本来利用它，在很长一段时间里，这对许多公司来说都不是一个现实的选择。然而，事情正在发生变化，甚至新版本的 RHEL 终于支持 eBPF，所以你会看到更多的项目利用其 [优势]（https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/）。如果你看过 Sysdig 最新的 &lt;a href="https://sysdig.com/blog/sysdig-2021-container-security-usage-report/">容器报告&lt;/a>，你会发现 Falco 的采用率最近在上升，虽然 Sysdig 的报告可能有点偏颇，但它反映在生产使用上。所以请继续关注，并期待未来更多基于 eBPF 的项目。&lt;/p>
&lt;p>&lt;strong>最后，祝大家 2021 年快乐！&lt;/strong>&lt;/p>
&lt;p>我还有一些预测和趋势要分享，尤其是围绕终端用户驱动的开源、服务网格拆解/标准化、Prometheus+OTel、保障软件供应链安全的 KYC 等等，但我会把这些留到更详细的文章中去，9 个预测足以开启新的一年！总之，感谢大家的阅读，希望在 2021 年 5 月的 &lt;a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/">KubeCon+CloudNativeCon EU&lt;/a> 上与大家见面，报名已开始！&lt;/p></description></item><item><title>【译】应用架构：为什么要随着市场演进</title><link>https://atbug.com/translation-application-architecture-why-it-should-evolve-with-the-market/</link><pubDate>Sun, 17 Jan 2021 21:37:23 +0800</pubDate><guid>https://atbug.com/translation-application-architecture-why-it-should-evolve-with-the-market/</guid><description>
&lt;p>本文译自 &lt;a href="https://www.cncf.io/blog/2021/01/07/application-architecture-why-it-should-evolve-with-the-market/">Application architecture: why it should evolve with the market&lt;/a>
最初由Mia Platform团队发布在&lt;a href="https://blog.mia-platform.eu/en/application-architecture-why-it-should-evolve-with-the-market">Mia Platform的博客&lt;/a>上&lt;/p>
&lt;p>如今，IT 挑战在于通过有效选择应用架构来适应市场和业务需求的发展。为了满足业务和客户的需求，IT 部门应能够对技术和&lt;strong>方法&lt;/strong>采取行动以确保软件具有灵活性，并实现产品和服务的持续创新流程，从而做出更快的反应 。&lt;/p>
&lt;p>当然，过去的单体应用程序和刚性基础设施无法做到这一点。相反，它可以通过&lt;strong>为演化而设计的架构&lt;/strong>来实现，该架构在需要时易于更新和重构。容器化实践的广泛应用（根据 &lt;a href="https://www.gartner.com/en/newsroom/press-releases/2020-06-25-gartner-forecasts-strong-revenue-growth-for-global-co">Gartner&lt;/a>，到2022年，大公司的就业人数将从目前的 30％ 增长到 75％），这种情况下采用云原生方法重新设计微服务应用是成功的关键。&lt;/p>
&lt;h2 id="如何构建不断发展的应用架构">如何构建不断发展的应用架构&lt;/h2>
&lt;p>海外专家称它们为&lt;strong>可演进的架构&lt;/strong>，以将它们与当今阻碍或无助于改变的传统架构区分开。应用架构基于&lt;a href="https://blog.mia-platform.eu/it/architettura-a-microservizi-i-vantaggi-per-il-business-e-per-lit">微服务架构风格&lt;/a> ，被设计成在现代虚拟化 IT 和云环境中发挥最佳性能。&lt;/p>
&lt;p>基本思想是&lt;strong>创建可以轻松“分解”的应用程序，其组件可以在其他上下文或组合中重用&lt;/strong>，如 Lego 系列。开发一系列微服务，每个微服务都用于执行单个业务功能（根据“单一职责原则”），可以在应用本身的开发和演进中获得相当大的灵活性。实际上，可以根据支持功能的特定生命周期独立开发、更新和测试服务。&lt;/p>
&lt;p>此外，谈到部署，微服务应用的架构具有很大的优势：可以根据需要在内部或云中通过使用可用资源来扩展单个微服务。&lt;/p>
&lt;p>为此，微服务应用获得&lt;strong>基于容器的基础设施&lt;/strong>的支持，该基础设施通过业务编排系统（通常为 &lt;a href="https://blog.mia-platform.eu/en/kubernetes-why-it-is-so-popular-and-who-should-use-it">Kubernetes&lt;/a>）进行管理，该流程可以自动化并促进公司系统之间以及从这些系统到云提供商服务的软件作业的迁移。&lt;/p>
&lt;h2 id="随着业务发展的应用架构的优势">随着业务发展的应用架构的优势&lt;/h2>
&lt;p>基于微服务的应用架构在开发和部署方面具有更大的自治权。如我们所见，微服务可以在其他应用程序中单独实现、“分解”、更新和重用。因此，通过产品或客户需求的演变，它有降低&lt;strong>减少市场所需的每个新产品的设计/开发时间和成本&lt;/strong>。&lt;/p>
&lt;p>此外，通过使用容器化实践，可以简化在本地、云、多云或混合环境的任何环境中应用程序的部署，从而优化成本。&lt;/p>
&lt;p>在微服务架构风格的优点中，我们还发现有可能在各种服务之间的对话及其健康状况上获得更大的&lt;strong>透明度&lt;/strong>：更好的可观察性意味着可以轻松解决复杂应用的问题。实际上，管理员可以&lt;strong>更快地定位和解决性能和安全性问题&lt;/strong>，在运维和代码层面实施措施，从而使响应速度与变更的长期有效性保持一致。&lt;/p>
&lt;p>通过采用微服务以及新的开发和部署方法，可以创建能够随时间发展的应用架构。除了 IT 团队必须掌握的新技能外，还必须对公司的未来有一个清晰的愿景，以确保所提供的服务对业务发展有用。&lt;/p>
&lt;h2 id="创建可演进的应用架构">创建可演进的应用架构&lt;/h2>
&lt;p>我们已经看到了基于微服务的现代应用架构如何保证软件的灵活性，并允许你利用本地和按需使用的所有资源，在可以&lt;strong>方便地&lt;/strong>获得所需性能、降低成本或保护数据的&lt;strong>位置分配作业&lt;/strong>。&lt;/p>
&lt;p>为了使之成为可能，有必要在云和混合环境中创建和管理虚拟化的 IT 环境，并&lt;strong>采用最合适的方法和策略&lt;/strong>。例如，在用于将开发和运维活动链接在一起的DevOps领域中，&lt;strong>持续集成/持续交付&lt;/strong>（CI / CD）策略的方法学支持可帮助提高更新速度和应用软件的质量。&lt;/p>
&lt;p>此外，微服务可促进对&lt;a href="https://blog.mia-platform.eu/it/da-monolite-a-microservizi-come-far-evolvere-unapplicazione-legacy">遗留应用程序的集成&lt;/a>，从而使公司更加敏捷，并利用市场上最&lt;strong>先进的解决方案&lt;/strong>。除了需要新的技术和工作方法外，现在还需要可演进的应用架构来&lt;strong>支持数字化转型所决定的不断变化的需求&lt;/strong>。&lt;/p></description></item><item><title>翻译：多运行时微服务架构</title><link>https://atbug.com/translation-multi-runtime-microservices-architecture/</link><pubDate>Wed, 01 Apr 2020 23:18:00 +0800</pubDate><guid>https://atbug.com/translation-multi-runtime-microservices-architecture/</guid><description>
&lt;p>这样文章通过Google翻译和人工逐字修改的方式完成的，某些位置也加上自己的理解。如有错误，请指出。&lt;/p>
&lt;p>翻译这篇文章的目的其实是为了自己加深对微服务、分布式架构以及多运行时架构的理解。整篇文章从”战略“上分析了微服务”从古至今“解决的问题，以及带来的新问题；进而在“战术”层面，给出了解决这些新问题的手段。&lt;/p>
&lt;p>个人见解：架构从来都是解决问题并带来问题， &lt;em>取舍之道&lt;/em> 。&lt;/p>
&lt;h3 id="背景知识">背景知识&lt;/h3>
&lt;p>微服务的 12 要素：&lt;/p>
&lt;ol>
&lt;li>基准代码：一份基准代码，多份部署&lt;/li>
&lt;li>依赖：显式声明依赖关系&lt;/li>
&lt;li>配置：在环境中存储配置&lt;/li>
&lt;li>后端服务：把后端服务当做附加资源&lt;/li>
&lt;li>构建、发布、运行：严格分离构建和运行&lt;/li>
&lt;li>进程：以一个或多个无状态进程运行应用&lt;/li>
&lt;li>端口绑定：通过端口绑定提供服务&lt;/li>
&lt;li>并发：通过进程模型进行扩展&lt;/li>
&lt;li>易处理：快速启动和优雅终止可最大化健壮性&lt;/li>
&lt;li>开发环境与线上环境等价：尽可能的保持开发、预发布、线上环境相同&lt;/li>
&lt;li>日志：把日志当做事件流&lt;/li>
&lt;li>管理进程：后台管理任务当做一次性进程运行&lt;/li>
&lt;/ol>
&lt;p>&lt;em>原文从此处开始：&lt;/em>&lt;/p>
&lt;ul>
&lt;li>创建分布式系统并非易事。围绕“微服务”架构和“ 12要素应用程序”设计出现了最佳实践。这些提供了与交付生命周期，网络，状态管理以及对外部依赖项的绑定有关的准则。&lt;/li>
&lt;li>但是，以可扩展和可维护的方式一致地实施这些原则是具有挑战性的。&lt;/li>
&lt;li>解决这些原理的以技术为中心的传统方法包括企业服务总线（ESB）和面向消息的中间件（MOM）。虽然这些解决方案提供了良好的功能集，但主要的挑战是整体架构以及业务逻辑和平台之间的紧密技术耦合。&lt;/li>
&lt;li>随着云，容器和容器协调器（Kubernetes）的流行，出现了解决这些原理的新解决方案。例如，Knative用于交付，服务网格用于网络，而Camel-K用于绑定和集成。&lt;/li>
&lt;li>通过这种方法，业务逻辑（称为“微逻辑”）构成了应用程序的核心，并且可以创建提供强大的现成分布式原语的sidecar“ mecha”组件。&lt;/li>
&lt;li>微观组件和机械组件的这种分离可以改善第二天的操作，例如打补丁和升级，并有助于维持业务逻辑内聚单元的长期可维护性。&lt;/li>
&lt;/ul>
&lt;p>创建良好的分布式应用程序并非易事：此类系统通常遵循12要素应用程序和微服务原则。它们必须是无状态的，可伸缩的，可配置的，独立发布的，容器化的，可自动化的，并且有时是事件驱动的和无服务器的。创建后，它们应该易于升级，并且长期可以承受。在当今的技术中，要在这些相互竞争的要求之间找到良好的平衡仍然是一项艰巨的努力。&lt;/p>
&lt;p>在本文中，我将探讨分布式平台如何发展以实现这种平衡，更重要的是，在分布式系统的演进中还需要发生什么事情，以简化可维护的分布式体系结构的创建。如果您想让我实时谈论这个话题，请加入我的QCon 三月的伦敦。&lt;/p>
&lt;h2 id="分布式应用程序需求">分布式应用程序需求&lt;/h2>
&lt;p>在此讨论中，我将把现代分布式应用程序的需求分为四个类别-生命周期，网络，状态，绑定-并简要分析它们在最近几年中的发展情况。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/04/01/15856635785757.jpg" alt="">&lt;/p>
&lt;h3 id="生命周期-lifecycle">生命周期 Lifecycle&lt;/h3>
&lt;ul>
&lt;li>打包 Packaging&lt;/li>
&lt;li>健康检查 Healthcheck&lt;/li>
&lt;li>部署 Deployment&lt;/li>
&lt;li>扩展 Scaling&lt;/li>
&lt;li>配置 Configuration&lt;/li>
&lt;/ul>
&lt;p>让我们从基础开始。当我们编写一项功能时，编程语言将指示生态系统中的可用库，打包格式和运行时。例如，Java使用.jar格式，将所有Maven依赖项用作生态系统，并将JVM用作运行时。如今，随着发布周期的缩短，生命周期更重要的是能够自动部署，从错误中恢复以及扩展服务的能力。这组功能广泛地代表了我们的应用程序生命周期需求。&lt;/p>
&lt;blockquote>
&lt;p>译者：错误恢复依赖健康检查&lt;/p>
&lt;/blockquote>
&lt;h3 id="网络-networking">网络 Networking&lt;/h3>
&lt;ul>
&lt;li>服务发现 Service Discovery&lt;/li>
&lt;li>A/B 测试、金丝雀部署 A/B Testing，Canary rollouts&lt;/li>
&lt;li>重试、超时、断路器 Retry，timeout，circuit breaker&lt;/li>
&lt;li>点到点、发布/订阅 Point-to-point，pub/sub&lt;/li>
&lt;li>安全、可观测性 Security observability&lt;/li>
&lt;/ul>
&lt;p>从某种意义上讲，今天几乎每个应用程序都是分布式应用程序，因此需要联网。但是现代分布式系统需要从更广泛的角度掌握网络。从服务发现和错误恢复开始，到启用现代软件发布技术以及各种跟踪和遥测。为了我们的目的，我们甚至将不同的消息交换模式，点对点和发布/订阅方法以及智能路由机制包括在此类别中。&lt;/p>
&lt;h3 id="状态-state">状态 State&lt;/h3>
&lt;ul>
&lt;li>工作流管理 Workflow mgmt&lt;/li>
&lt;li>幂等性 Idempotency&lt;/li>
&lt;li>临时调度 Temporal scheduling&lt;/li>
&lt;li>缓存 Caching&lt;/li>
&lt;li>应用状态 Application State&lt;/li>
&lt;/ul>
&lt;p>当我们谈论状态时，通常是关于服务状态以及为什么最好是无状态的。但是管理服务的平台本身需要状态。这对于执行可靠的服务编排和工作流，分布式单例，临时调度（cron作业），幂等性，有状态的错误恢复，缓存等是必需的。此处列出的所有功能都依赖于底层的状态。虽然实际的状态管理不在本文讨论范围之内，但关注状态的分布式原语及其抽象却很受关注。&lt;/p>
&lt;h3 id="绑定-binding">绑定 Binding&lt;/h3>
&lt;ul>
&lt;li>连接器 Connectors&lt;/li>
&lt;li>协议转换 Protocol conversion&lt;/li>
&lt;li>消息转换 Message transformation&lt;/li>
&lt;li>消息路由 Message routeing&lt;/li>
&lt;li>事务性 Transactionality&lt;/li>
&lt;/ul>
&lt;p>分布式系统的组件不仅必须彼此对话，而且还必须与现代或旧式外部系统集成。这就要求连接器能够转换各种协议，支持不同的消息交换模式（例如轮询，事件驱动，请求/答复）转换消息格式，甚至能够执行自定义的错误恢复过程和安全机制。&lt;/p>
&lt;blockquote>
&lt;p>译者：执行自定义的错误恢复过程和安全机制 &amp;ndash; 事务&lt;/p>
&lt;/blockquote>
&lt;p>在不涉及一次性使用案例的情况下，以上内容代表了创建良好的分布式系统所需的通用原语的良好集合。如今，许多平台都提供了这样的功能，但是本文中我们要寻找的是过去十年中我们使用这些功能的方式如何变化，以及在下一个十年中它将如何变化。为了进行比较，让我们看一下过去的十年，看看基于Java的中间件如何满足这些需求。&lt;/p>
&lt;h2 id="传统中间件的限制">传统中间件的限制&lt;/h2>
&lt;p>上一代的企业服务总线（ESB）及其变体（例如面向消息的中间件，更轻量级的集成框架等）可满足上述需求，这是一种众所周知的传统解决方案。ESB 是一种中间件，可以使用面向服务的体系结构（即经典SOA）在异构环境之间实现互操作性。&lt;/p>
&lt;p>ESB可以为您提供良好的功能集，但ESB的主要挑战是整体架构以及业务逻辑和平台之间紧密的技术耦合，从而导致技术和组织集中化。在将服务开发并部署到这样的系统中时，它与分布式系统框架紧密结合，从而限制了服务的发展。这通常只会在软件生命周期的后期才变得明显。&lt;/p>
&lt;p>以下是每类需求的一些问题和局限性，这些问题和局限性使得ESB在现代时代不再有用。&lt;/p>
&lt;h3 id="生命周期">生命周期&lt;/h3>
&lt;p>在传统的中间件中，通常只有一个受支持的语言运行时（例如Java），它规定了软件的打包方式，可用的库，必须定期对其进行打补丁等。业务服务必须使用那些使其与以相同语言编写的平台紧密结合的库。实际上，这导致协调的服务和平台升级，从而阻止了独立和常规的服务和平台发布。&lt;/p>
&lt;h3 id="联网">联网&lt;/h3>
&lt;p>尽管传统的中间件拥有围绕与其他内部和外部服务交互的高级功能集，但它具有一些主要缺点。 网络功能集中于一种主要语言及其相关技术。 对于Java来说，即JMS，JDBC，JTA等。更重要的是，网络问题和语义也深深地刻在业务服务中。 有一些具有抽象的库来解决网络问题（例如曾经很受欢迎的Hystrix项目），但是该库的抽象“泄漏”到了服务的编程模型，交换模式和错误处理语义以及库本身中。 虽然可以方便地在一个位置编写和读取与网络方面混合的整个业务逻辑，但是这将两个问题紧密地耦合到一个实现中，最终形成了一条共同的演进路径。&lt;/p>
&lt;p>译者：这里问题在于一些通用的高级功能与语言绑定。这里提到的 Hystrix 作为断路器的一个实现，使用的时候需要采用 Hystrix 的编程模型。如果切换到其他的实现，则需要学习和改造的成本。&lt;/p>
&lt;h3 id="状态">状态&lt;/h3>
&lt;p>为了进行可靠的服务编排，业务流程管理以及实施模式（例如Saga模式和其他运行缓慢的流程），平台需要在幕后保持持久状态。同样，临时动作（例如触发计时器和cron作业）建立在状态之上，并且需要在分布式环境中对数据库进行集群化和恢复。这里的主要约束是以下事实：与状态交互的库和接口没有完全抽象出来，也没有与服务运行时分离。通常，这些库必须配置有数据库详细信息，并且它们存在于服务中，从而将语义和依赖关系泄漏到应用程序域中&lt;/p>
&lt;h3 id="绑定">绑定&lt;/h3>
&lt;p>使用集成中间件的主要驱动程序之一是能够使用不同的协议，数据格式和消息交换模式连接到其他各种系统。但是，这些连接器必须与应用程序一起使用，这意味着必须将依赖关系与业务逻辑一起进行更新和修补。这意味着必须在服务内来回转换数据类型和数据格式。这意味着必须根据消息交换模式来构造代码并设计流程。这些是即使抽象的端点如何影响传统中间件中服务实现的一些示例。&lt;/p>
&lt;blockquote>
&lt;p>译者：使用不同 RPC 实现的服务之间的对话，比如某个服务调用会同时（空间上）调用使用 Dubbo 协议的服务和使用 RESTful 协议的服务&lt;/p>
&lt;/blockquote>
&lt;h2 id="云原生趋势">云原生趋势&lt;/h2>
&lt;p>传统的中间件功能强大。它具有所有必要的技术功能，但缺乏现代数字业务需求所要求的快速更改和扩展的能力。这就是微服务体系结构及其设计现代分布式应用程序的指导原则所要解决的问题。&lt;/p>
&lt;p>微服务背后的思想及其技术要求促进了容器和Kubernetes的普及和广泛使用。这开始了一种新的创新方式，这种方式将影响我们今后几年处理分布式应用程序的方式。让我们看看Kubernetes和相关技术如何影响每组需求。&lt;/p>
&lt;h3 id="生命周期-1">生命周期&lt;/h3>
&lt;p>容器和Kubernetes将我们打包、分发和部署应用程序的方式发展为与语言无关的格式。关于Kubernetes模式和Kubernetes对开发人员的影响的文章很多，在这里我将简短介绍。但是请注意，对于Kubernetes，要管理的最小原语是容器，它专注于在容器级别和流程模型上交付分布式原语。这意味着它在管理应用程序的生命周期方面，运行状况检查、恢复、部署和扩展方面做得很好，但是在容器内的分布式应用程序的其他方面却没有做得那么好，例如灵活的网络、状态管理和绑定。&lt;/p>
&lt;p>您可能会指出，Kubernetes具有状态工作负载、服务发现、cron作业和其他功能。的确如此，但是所有这些原语都是在容器级别的，并且在容器内部，开发人员仍然必须使用特定于语言的库来访问我们在本文开头列出的更详细的功能。这就是推动诸如Envoy、Linkerd、Consul、Knative、Dapr、Camel-K等项目的原因。&lt;/p>
&lt;h3 id="网络">网络&lt;/h3>
&lt;p>事实证明，Kubernetes提供的围绕服务发现的基本网络功能是一个很好的基础，但对于现代应用程序来说还不够。随着微服务数量的增加和部署速度的加快，对更高级的发布策略、管理安全性、指标、跟踪、从错误中恢复、错误模拟等等方面的需求变得越来越具有吸引力，并产生了一种新的软件类别，称为服务网格。&lt;/p>
&lt;p>这里更令人兴奋的是，趋势是将与网络相关的问题从包含业务逻辑的服务移出到单独的运行时（无论是sidecar还是节点级代理）。如今，服务网格可以执行高级路由、助力测试、处理安全性的某些部分，更甚至特定于应用程序的协议（例如，Envoy支持Kafka，MongoDB，Redis，MySQL等）。尽管作为解决方案的服务网格可能尚未得到广泛采用，但它触及了分布式系统中的真正痛点，我相信它将找到其形状和存在形式。&lt;/p>
&lt;p>除了典型的服务机制外，还有其他项目，例如Skupper，这些项目证实了将网络功能放入外部运行时代理的趋势。Skupper通过第7层虚拟网络解决了多集群间的通信难题，并提供了先进的路由和连接功能。但是，Skupper并没有被嵌入到业务服务运行时中，而是每个Kubernetes命名空间运行一个实例，该实例充当共享的补充工具。&lt;/p>
&lt;p>综上所述，容器和Kubernetes在应用程序的生命周期管理方面迈出了重要的一步。服务网格和相关技术遇到了真正的痛点，并为将更多职责从应用程序移到代理中奠定了基础。让我们看看下一步。&lt;/p>
&lt;h3 id="状态-1">状态&lt;/h3>
&lt;p>我们在前面列出了依赖状态的主要集成原语。管理状态非常困难，应将其委派给专门的存储软件和托管服务。这不是这里的主题，而是在语言无关的抽象中使用状态来帮助集成用例。今天，许多努力试图在语言无关的抽象后面提供有状态的原语。有状态的工作流管理是基于云的服务中的强制性功能，例如AWS Step Functions，Azure Durable Functions等示例。在基于容器的部署中，CloudState和Dapr都依赖于sidecar模型来进一步解耦分布式应用程序中的状态抽象。&lt;/p>
&lt;p>我也期待将上面列出的所有有状态功能抽象到一个单独的运行时中。这意味着工作流管理、单例、幂等、事务管理、cron作业触发器和有状态错误处理都可靠地发生在Sidecar（或主机级代理）中，而不是存在于服务中。业务逻辑不需要在应用程序中包含此类依赖关系和语义，并且可以从绑定环境中声明性地请求此类行为。例如，Sidecar可以充当cron作业触发器、幂等消费者和工作流管理器，而自定义业务逻辑可以作为回调调用或插入工作流的某些阶段、错误处理、临时调用或唯一幂等要求等。&lt;/p>
&lt;p>另一个有状态用例是缓存。无论是由服务网格层执行请求缓存，还是使用诸如Infinispan，Redis，Hazelcast等之类的数据缓存，都有一些将缓存功能推到应用程序运行时之外的示例。&lt;/p>
&lt;h3 id="绑定-1">绑定&lt;/h3>
&lt;p>尽管我们的主题是将所有分布式需求与应用程序运行时脱钩，但这种趋势也继续伴随着绑定。连接器、协议转换、消息转换
、错误处理和安全中介都可以移出服务运行时。我们还没有到那里，但是在诸如Knative和Dapr之类的项目中朝这个方向进行了尝试。将所有这些职责移出应用程序运行时将导致更小，更注重业务逻辑的代码。这样的代码将在独立于分布式系统需求的运行时中运行，而分布式系统需求可以作为预包装功能使用。&lt;/p>
&lt;p>Apache Camel-K 采用了另一种有趣的方法。该项目没有使用来伴随主应用程序的代理运行时，而是依靠智能的Kubernetes Operator来构建具有Kubernetes和Knative的附加平台功能的应用程序运行时。在这里，单一代理是负责包括应用程序所需的分布式系统原语的操作员。不同之处在于，某些分布式原语已添加到应用程序运行时中，而某些已在平台中启用（也可能包括Sidecar）。&lt;/p>
&lt;h2 id="未来架构趋势">未来架构趋势&lt;/h2>
&lt;p>概括地说，我们可以得出结论，通过将功能部件转移到平台级别，分布式应用程序的产品化达到了新的领域。除了生命周期之外，现在我们还可以观察到联网，状态抽象，声明性事件和端点绑定（拆箱即用），并且EIPs在此列表中排在后面。有趣的是，产品化使用进程外模型（sidecar）进行功能扩展，而不是使用运行时库或纯平台功能（例如新的Kubernetes功能）。&lt;/p>
&lt;blockquote>
&lt;p>译者：产品化可以理解为分布式原语的内聚：便于独立发布和演进。&lt;/p>
&lt;/blockquote>
&lt;p>现在，我们通过将所有传统的中间件功能（也称为ESB）转移到其他运行时中来，不久，我们在服务中要做的就只是编写业务逻辑。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/04/01/15857495038535.jpg" alt="">
传统中间件平台和云原生平台概述&lt;/p>
&lt;p>与传统的ESB时代相比，此体系结构将业务逻辑与平台更好地分离了，但是还没有完全分离。许多分布式原语，例如经典的企业集成模式（EIP）：拆分器、聚合器、过滤器、基于内容的路由器；流处理模式：映射、过滤、折叠、联接、合并、滑动窗口；仍然必须包含在业务逻辑运行时中，许多其他依赖于多个不同且重叠的平台附加组件。&lt;/p>
&lt;p>如果我们将在不同领域进行创新的各种云原生项目进行堆叠，那么最终将得到如下图所示：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/04/01/15857496466055.jpg" alt="">
多运行时微服务&lt;/p>
&lt;p>这里的图仅用于说明目的，它有目的地选择代表性的项目并将其映射到分布式原语的类别。实际上，您不会同时使用所有这些项目，因为其中一些项目是重叠的且不兼容的工作负载模型。如何解释这个图？&lt;/p>
&lt;ul>
&lt;li>Kubernetes和容器在多语言应用程序的生命周期管理中取得了巨大飞跃，并为未来的创新奠定了基础。&lt;/li>
&lt;li>服务网格技术通过高级网络功能在Kubernetes上进行了改进，并开始涉足应用程序方面。&lt;/li>
&lt;li>尽管Knative通过快速扩展主要专注于无服务器工作负载，但它也满足了服务编排和事件驱动的绑定需求。&lt;/li>
&lt;li>Dapr以Kubernetes、Knative和Service Mesh的思想为基础，并深入应用程序运行时以解决有状态的工作负载、绑定和集成需求，充当现代的分布式中间件。&lt;/li>
&lt;/ul>
&lt;p>该图可帮助您直观地看到，很可能在将来，我们最终将使用多个运行时来实现分布式系统。多个运行时，不是因为有多个微服务，而是因为每个微服务都将由多个运行时组成，最有可能是两个运行时-&lt;strong>自定义业务逻辑运行时&lt;/strong>和&lt;strong>分布式原语运行时&lt;/strong>。&lt;/p>
&lt;h2 id="引入多运行时微服务">引入多运行时微服务&lt;/h2>
&lt;p>这是开始形成的多运行时微服务体系结构的简要说明。&lt;/p>
&lt;p>您还记得科学家们制作的电影中的Avatar和机甲（机械套件），他们去旷野探索潘多拉吗？这种多运行时架构类似于这些Mecha-为类人动物驾驶员赋予超能力的套装。在电影中，您要穿上套装才能获得力量并获得破坏性武器。在这种软件架构中，您具有构成应用程序核心的业务逻辑（称为micrologic微逻辑）和提供强大且拆箱即用的分布式原语的sidecar mecha组件。微逻辑与mecha功能相结合，形成了一个多运行时微服务，该服务将进程外功能用于解决其分布式系统需求。最棒的是，Avatar 2即将面世，以帮助推广这种架构。我们最终可以在所有软件会议上用令人赞叹的机甲图片代替老式的边车摩托车；-)。接下来，让我们看看该软件体系结构的详细信息。&lt;/p>
&lt;p>这是一个类似于客户端-服务器体系结构的两组件模型，其中每个组件都是独立的运行时。它与纯客户端-服务器体系结构的不同之处在于，这两个组件都位于同一主机上，彼此之间没有可靠的网络连接。这两个组件的重要性相同，它们可以在任一方向上启动操作并充当客户端或服务器。其中的一个组件称为为逻辑（Micrologic），它拥有从几乎所有分布式系统问题中剥离出来的非常少的业务逻辑。另一个随附的组件是Mecha，它提供了我们在本文中一直讨论的所有分布式系统功能（生命周期除外，它是一个平台功能）。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/04/01/15857504765833.jpg" alt="">
多运行时（进程外）微服务架构&lt;/p>
&lt;p>Micrologic和Mecha可能是一对一的部署（称为sidecar模型），也可以是带有几个Micrologic运行时的共享Mecha。第一种模型最适用于Kubernetes等环境，而第二种模型则适用于边缘部署。&lt;/p>
&lt;h3 id="微逻辑运行时特征">微逻辑运行时特征&lt;/h3>
&lt;p>让我们简要地探讨Micrologic运行时的一些特征：&lt;/p>
&lt;ul>
&lt;li>Micrologic组件本身不是微服务。它包含微服务将具有的业务逻辑，但是该逻辑只能与Mecha组件结合使用。另一方面，微服务是自包含的，没有整体功能的一部分，也没有一部分处理流程扩展到其他运行时中。Micrologic及其与Mecha对应的产品的组合形成了微服务。&lt;/li>
&lt;li>这也不是函数或无服务器架构。无服务器最著名的是其提供的快速扩展和从零扩展到零的能力。在无服务器体系结构中，函数实现单个操作，因为这是可伸缩性的单位。在这方面，函数不同于实现多种操作的Micrologic，但实现方式不是端到端的。最重要的是，操作的实现分布在Mecha和Micrologic运行时上。&lt;/li>
&lt;li>这是客户端-服务器体系结构的一种特殊形式，针对无需编码即可使用众所周知的分布式原语进行了优化。另外，如果我们假设Mecha扮演服务器角色，那么每个实例都必须经过专门配置以便与单个客户端一起工作。它不是那种旨在与典型的客户端-服务器体系结构同时支持多个客户端的通用服务器实例。（译者：多运行时架构中假如 mecha 作为服务端，那么微逻辑作为客户端。客户端与服务端的关系多为一对一，或者多对一。而传统微服务架构中的客户端服务端一般是多对多）&lt;/li>
&lt;li>Micrologic中的用户代码不会直接与其他系统交互，也不会实现任何分布式系统原语。它通过事实上的标准（例如HTTP / gRPC，CloudEvents规范）与Mecha进行交互，并且Mecha使用丰富的功能并在配置的步骤和机制的指导下与其他系统进行通信。&lt;/li>
&lt;li>尽管Micrologic仅负责实现从分布式系统问题中剥离出来的业务逻辑，但它仍必须至少实现一些API。它必须允许Mecha和平台通过预定义的API和协议与其进行交互（例如，通过遵循Kubernetes部署的云原生设计原则）。（译者：比如微逻辑需要实现健康检查的 API，方便平台-Kubernetes 或者 mecha 进行健康检查）&lt;/li>
&lt;/ul>
&lt;h3 id="mecha运行时特征">Mecha运行时特征&lt;/h3>
&lt;p>以下是一些Mecha运行时特征：&lt;/p>
&lt;ul>
&lt;li>Mecha是一个通用的、高度可配置的、可重用的组件、提供分布式原语作为现成的功能。&lt;/li>
&lt;li>Mecha的每个实例都必须配置为与一个Micrologic组件（边车模型）一起使用，或者配置为与几个组件共享（节点级别）。&lt;/li>
&lt;li>Mecha不对Micrologic运行时做任何假设。它与使用开放协议和格式（例如HTTP / gRPC，JSON，Protobuf，CloudEvents）的多语言微服务甚至单片系统一起使用。&lt;/li>
&lt;li>Mecha以简单的文本格式（例如YAML，JSON）声明性地配置，该格式表明要启用的功能以及如何将其绑定到Micrologic端点。对于专门的API交互，可以为Mechan附加规范，例如OpenAPI，AsyncAPI，ANSI-SQL等。对于由多个处理步骤组成的有状态工作流，可以使用诸如Amazon State Language的规范。对于无状态集成，可以使用与Camel-K YAML DSL类似的方法来使用企业集成模式（EIP）。这里的关键点是，所有这些都是Mecha无需编码即可实现的简单的、基于文本的、声明性的、多种语言的定义。请注意，这些都是未来派的预测，当前，没有用于状态编排或EIP的Mechas，但是我希望现有的Mechas（Envoy，Dapr，Cloudstate等）很快就会开始添加此类功能。Mecha是应用程序级别的分布式原语抽象层。&lt;/li>
&lt;li>与其为了不同目的而依赖于多个代理的（例如网络代理、缓存代理、绑定代理），而应该由一个Mecha提供所有这些功能。一些功能（例如存储、消息持久性、缓存等）的实现将被其他云或本地服务注入并支持。&lt;/li>
&lt;li>一些与生命周期管理有关的分布式系统问题可以由管理平台（例如Kubernetes或其他云服务）来处理，而不是使用通用的开放规范（例如Open App Model）提供的Mecha运行时。&lt;/li>
&lt;/ul>
&lt;h3 id="这种架构的主要好处是什么">这种架构的主要好处是什么？&lt;/h3>
&lt;p>好处是业务逻辑和越来越多的分布式系统问题之间的耦合变得松散。软件系统的这两个要素具有完全不同的动力学。业务逻辑始终是内部编写的唯一的自定义代码。它经常更改，具体取决于您的组织优先级和执行能力。另一方面，用于解决本文中列出的问题的分布式原语，并且众所周知。这些由软件供应商开发，并作为库，容器或服务使用。该代码根据供应商的优先级、发布周期、安全补丁、开放源代码管理规则等而更改。这两部分之间几乎不可见并且无法相互控制。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/04/01/15857520911736.jpg" alt="">
业务逻辑和分布式系统关注不同架构中的耦合&lt;/p>
&lt;p>微服务原理有助于通过有限的上下文使不同的业务领域脱钩，每个微服务都可以独立发展。但是微服务架构无法解决将业务逻辑与中间件问题耦合在一起带来的困难。对于某些依赖于集成用例的微服务，这可能不是一个大因素。但是，如果您的领域涉及复杂的集成（也是越来越多的人所面临的），那么遵循微服务原则也无法帮助您避免与中间件的耦合。即使中间件是为您包含在微服务中的库，当您开始迁移和更改这些库时，这种耦合便会显现出来。还有您需要的分布的原语越多，您与集成平台的耦合就越强。通过预定义的API（而不是库）来访问作为独立运行时/进程的中间件，有助于解耦并实现每个组件的独立演进。&lt;/p>
&lt;p>这也是为供应商分发和维护复杂的中间件软件的较好的方法。只要与中间件的交互是通过开放API和标准的进程间通信进行的，软件供应商就可以按照自己的节奏自由发布补丁和升级。消费者可以自由使用他们喜欢的语言、库、运行时、部署方法和过程。&lt;/p>
&lt;h3 id="这种架构的主要缺点是什么">这种架构的主要缺点是什么？&lt;/h3>
&lt;p>进程间通信。分布式系统的业务逻辑和中间件机制（您可以看到名称的来源）在不同的运行时中，并且需要HTTP或gRPC调用而不是进程内方法调用。但是请注意，这并不是跨机器或数据中心的网络调用。Micrologic运行时和Mecha应当位于同一主机上，并且延迟时间短，并且出现网络问题的可能性最小。&lt;/p>
&lt;p>复杂。下一个问题是，是否值得为获得某些好处而进行复杂的开发、并维护此类系统。我认为答案将越来越倾向于是。分布式系统的需求和发布周期的步伐正在增加，并且此架构为此进行了优化。我前段时间写道，未来的开发人员必须具备混合开发技能。这种体系结构进一步证实了这一趋势。应用程序的一部分将使用高级编程语言编写，部分功能将由必须进行声明性配置的现成组件提供。这两个部分的互连不是在编译时或在启动时通过进程内依赖注入，而是在部署时通过进程间通信互连。该模型可实现更高的软件重用率和更快的变更速度。&lt;/p>
&lt;h3 id="微服务后无法使用的功能">微服务后无法使用的功能&lt;/h3>
&lt;p>微服务架构有一个明确的目标。它为变化而优化。通过将应用程序划分到业务域中，此软件架构通过独立的团队分离、管理并以独立的步调发布的服务，为软件演进和可维护性提供了最佳的服务边界。&lt;/p>
&lt;p>如果我们看一下无服务器体系结构的编程模型，它主要基于功能。功能已针对可伸缩性进行了优化。通过功能，我们将每个操作分解为一个独立的组件，以便可以快速，独立和按需扩展。在此模型中，部署粒度是一项功能。之所以选择该函数，是因为它是代码结构：其输入的速率与缩放行为直接相关。这是一种针对极端可伸缩性（而不是复杂系统的长期可维护性）进行了优化的体系结构。&lt;/p>
&lt;p>从AWS Lambda的流行及其完全托管的运营性质来看，Serverless的其他方面又如何呢？在这方面，“AWS无服务器”为配置速度进行了优化，但缺少控制和锁定功能。但是完全托管的方面不是应用程序体系结构，而是一种软件使用模型。它在功能上是正交的，类似于使用基于SaaS的平台，该平台在理想情况下应适用于任何类型的体系结构，无论是整体式、微服务、机甲还是功能。在许多方面，AWS Lambda类似于完全托管的Mecha架构，但有一个很大的区别：Mecha不执行功能模型，而是允许围绕业务域使用更具凝聚力的代码构造，而与所有中间件无关。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/04/01/15857521845846.jpg" alt="">
架构优化&lt;/p>
&lt;p>另一方面，Mecha架构为中间件独立性优化了微服务。尽管微服务彼此独立，但它们在很大程度上依赖于嵌入的分布式原语。Mecha架构将这两个问题分为单独的运行时，从而允许独立团队独立发布它们。这种解耦可以改善第二天（day-2）的操作（例如修补和升级），并改善业务逻辑内聚单元的长期可维护性。在这方面，Mecha架构是微服务架构的自然发展，它通过根据引起最大摩擦的边界拆分软件来进行开发。与功能模型相比，该优化以软件重用和演化的形式提供了更多好处，而功能模型则以代码的过度分配为代价进行了优化，以实现极高的可伸缩性。&lt;/p>
&lt;blockquote>
&lt;p>译者：day-2可以理解为前一天的发布带来的问题需要第二天的发布进行修复，而多运行时解耦了业务逻辑和分布式原语，允许其中一个的独立发布，不需要统一安排升级的节点。&lt;/p>
&lt;/blockquote>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>分布式应用程序有许多要求。创建高效的分布式系统需要多种技术和良好的集成方法。尽管传统的单体中间件提供了分布式系统所需的所有必要的技术功能，但它缺乏业务所需的快速更改、适应和扩展的能力。这就是为什么基于微服务的架构背后的思想为容器和Kubernetes的快速普及做出了贡献。随着云原生领域的最新发展，我们现在通过将所有传统中间件功能转移到平台和现成的辅助运行时中来全面发展。&lt;/p>
&lt;p>应用程序功能的这种产品化主要是使用进程外模型进行功能扩展，而不是运行时库或纯平台功能。这意味着，将来很有可能我们将使用多个运行时来实现分布式系统。多个运行时，不是因为有多个微服务，而是因为每个微服务都将由多个运行时组成。自定义微业务逻辑的运行时，以及拆箱即用的分布式原语运行时。&lt;/p>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/04/01/15857522443912.jpg" alt="">&lt;/p>
&lt;p>Bilgin Ibryam是Red Hat的首席架构师、提交者和Apache Software Foundation的成员。他是一位开源的传播者
、博客作者、偶尔的演讲者，并且是Kubernetes Patterns和Camel Design Patterns书籍的作者。在日常工作中，Bilgin乐于指导、编码并带领开发人员成功构建开源解决方案。他当前的工作集中在区块链、分布式系统、微服务、devops和云原生应用程序开发上。&lt;/p>
&lt;p>原文的某些连接：&lt;/p>
&lt;ul>
&lt;li>12-Factors：https://12factor.net/zh_cn/&lt;/li>
&lt;li>原文：https://www.infoq.com/articles/multi-runtime-microservice-architecture/&lt;/li>
&lt;/ul></description></item></channel></rss>