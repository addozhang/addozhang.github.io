<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dapr on 乱世浮生</title><link>https://atbug.com/tags/dapr/</link><description>Recent content in Dapr on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 24 Feb 2023 00:32:19 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/dapr/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Ingres 访问 Dapr 应用</title><link>https://atbug.com/access-dapr-application-with-ingress-controller/</link><pubDate>Fri, 24 Feb 2023 00:32:19 +0800</pubDate><guid>https://atbug.com/access-dapr-application-with-ingress-controller/</guid><description>在 上一篇 文章中体验了下分布式运行时 Dapr，在示例中将状态存储能力分离到 Dapr 运行时中，应用通过 Dapr API 来使用该能力。这篇文章主要介绍如何通过 Ingress Controller（入口控制器）来访问 Dapr 应用。
方案 如何公开 Dapr 应用的访问，方案有两种：
像传统用法一样，配置应用的 Service 作为后端，有入口控制器直接将流量转发到应用容器 不直接访问应用容器，而是通过 Daprd 运行时来访问。这时，我们就需要将入口控制器也声明为 Dapr 应用，为其注入 Daprd 运行时容器。此时创建入口规则指向的后端，则是 Ingress 的 Dapr Service。 两种方案各有优劣，前者链路简单，少了一次 HTTP 和一次 gRPC 的带来的延迟；后者虽然引入了延迟，但相应的可以使用 Dapr 的服务治理能力，如超时、重试、访问控制等等。</description></item><item><title>分布式应用运行时 Dapr：万物皆可 API</title><link>https://atbug.com/first-sight-of-dapr/</link><pubDate>Sat, 11 Feb 2023 11:18:45 +0800</pubDate><guid>https://atbug.com/first-sight-of-dapr/</guid><description>Dapr 分布式应用运行时 Distributed Application Runtime 的首字母缩写。有关多运行时，可以看下 Bilgin Ibryam 的 Multi-Runtime Microservices Architecture，不想看英文的可以看下我之前的翻译。
Dapr 是一个分布式系统工具包，通过提供 API 实现应用程序与外围组件的解耦合，让开发人员更加聚焦于业务逻辑的研发。解耦也是与传统 SDK 的很大区别，能力不再是通过应用程序中加入库的方式提供，而是通过应用附近的边车（sidecar）运行时提供（sidecar 不是广为人知的服务网格 sidecar - pod 中的容器，而是广泛使用在系统软件设计中的一种模式，比如操作系统的 initd、日志采集组件，甚至是 Java 中的多线程。）。因此这里说的 Dapr sidecar 可能是个独立的进程，也可能是 pod 中的一个容器。
在 Dapr 中我们可以看到很多常见 SDK 的能力：
如 SpringCloud、Netflix OSS 的 服务调用，以及超时、熔断、重试等 弹性策略 如 Spring Data KeyValue 一样提供 状态存储 的抽象，简化各种持久存储的访问 如 Kafka、NATS、MQTT 等消息代理，提供 发布/订阅 抽象供服务通过消息进行通信 如 Kafka、MQTT、RabbitMQ 提供以事件触发应用的抽象：绑定 如 Redis 一样的 分布式锁 如 Consul、Kubernetes 等的 名称解析 &amp;hellip; 以上能力都是通过 HTTP 和 gRPC API 暴露给应用，这些 API 在 Dapr 中被叫做 构建块（building blocks），并且也 仅提供抽象，也就是说你可以随意替换底层实现（Dapr 中也叫做 组件）而无需修改任何应用代码。</description></item><item><title>分布式系统在 Kubernetes 上的进化</title><link>https://atbug.com/translation-distributed-systems-kubernetes/</link><pubDate>Mon, 29 Mar 2021 23:11:25 +0800</pubDate><guid>https://atbug.com/translation-distributed-systems-kubernetes/</guid><description>本文译自 The Evolution of Distributed Systems on Kubernetes
在 3 月份的 QCon 上，我做了一个关于 Kubernetes 的分布式系统进化的演讲。首先，我想先问一个问题，微服务之后是什么？我相信大家都有各自的答案，我也有我的答案。你会在最后发现我的想法是什么。为了达到这个目的，我建议大家看看分布式系统的需求是什么？以及这些需求在过去是如何发展的，从单体应用开始到 Kubernetes，再到最近的 Dapr、Istio、Knative 等项目，它们是如何改变我们做分布式系统的方式。我们将尝试对未来做一些预测。
现代分布式应用 为了给这个话题提供更多的背景信息，我认为的分布式系统是由数百个组件组成的系统。这些组件可以是有状态的、无状态的或者无服务器的。此外，这些组件可以用不同的语言创建，运行在混合环境上，并开发开源技术、开放标准和互操作性。我相信你可以使用闭源软件来构建这样的系统，也可以在 AWS 和其他地方构建。具体到这次演讲，我将关注 Kubernetes 生态系统，以及你如何在 Kubernetes 平台上构建这样一个系统。
我们从分布式系统的需求讲起。我认为是我们要创建一个应用或者服务，并写一些业务逻辑。那从运行时的平台到构建分布式系统，我们还需要什么呢？在底层，最开始是我们要一些生命周期的能力。当你用任一语言开发你的应用时，我们希望有能力把这个应用可靠地打包和部署、回滚、健康检查。并且能够把应用部署到不同的节点上，并实现资源隔离、扩展、配置管理，以及所有这些。这些都是你创建分布式应用所需要的第一点。
第二点是围绕网络。我们有了应用之后，我们希望它能够可靠地连接到其他服务，无论该服务是在集群内部还是在外部。我们希望其具有服务发现、负载均衡的能力。为了不同的发布策略或是其他的一些原因的我们希望有流量转移的能力。然后我们还希望其具有与其他系统进行弹性通信的能力，无论是通过重试、超时还是断路器。要有适当的安全保障，并且要有足够的监控、追踪、可观察性等等。
我们有了网络之后，接下来就是我们希望有能力与不同的 API 和端点交互，即资源绑定&amp;ndash;与其他协议和不同的数据格式交互。甚至能够从一种数据格式转换成另一种数据格式。我还会在这里加入诸如滤光的功能，也就是说，当我们订阅一个主题时，我们也许只对某些事件感兴趣。
你认为最后一类是什么？是状态。当我在说状态和有状态的抽象时，我并不是在谈论实际的状态管理，比如数据库或者文件系统的功能。我要说的更多是有关幕后依赖状态的开发人员抽象。可能，你需要具有工作流管理的能力。也许你想管理运行时间长的进程或者做临时调度或者某些定时任务来定期运行服务。也许你还想进行分布式缓存，具有幂等性或者支持回滚。所有这些都是开发人员级的原语，但在幕后，它们依赖于具有某种状态。你想随意使用这些抽象俩创建完善的分布式系统。
我们将使用这个分布式系统原语的框架来评估它们在 Kubernetes 和其他项目上的变化情况。
单体架构 &amp;ndash; 传统中间件功能 假设我们从单体架构以及如何获得这些能力开始。在那种情况下，首先是当我说单体的时候，在分布式应用的情况下我想到的是 ESB。ESB 是相当强大的，当我们检查我们的需求列表时，我们会说 ESB 对所有有状态的抽象有很好的支持。</description></item></channel></rss>