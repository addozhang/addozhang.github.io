<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>容器 on 乱世浮生</title><link>https://atbug.com/tags/%E5%AE%B9%E5%99%A8/</link><description>Recent content in 容器 on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 22 Jan 2022 10:15:31 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>追踪 Kubernetes 中的网络流量</title><link>https://atbug.com/tracing-path-of-kubernetes-network-packets/</link><pubDate>Sat, 22 Jan 2022 10:15:31 +0800</pubDate><guid>https://atbug.com/tracing-path-of-kubernetes-network-packets/</guid><description>
&lt;p>译者注：&lt;/p>
&lt;p>这篇文章很全面的罗列出了 Kubernetes 中涉及的网络知识，从 Linux 内核的网络内容，到容器、Kubernetes，一一进行了详细的说明。&lt;/p>
&lt;p>​文章篇幅有点长，不得不说，网络是很复杂很麻烦的一层，但恰恰这层多年来变化不大。希望翻译的内容对大家能有所帮助，有误的地方，也欢迎大家指正。&lt;/p>
&lt;p>本文翻译获得 Learnk8s 的授权，原文 &lt;a href="https://learnk8s.io/kubernetes-network-packets">Tracing the path of network traffic in Kubernetes&lt;/a> 作者 Kristijan Mitevski。&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427680911539.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>TL;DR：&lt;/strong> &lt;em>本文将代理了解 Kubernetes 集群内外的数据流转。从最初的 Web 请求开始，一直到托管应用程序的容器。&lt;/em>&lt;/p>
&lt;h2 id="目录">目录&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#%E7%9B%AE%E5%BD%95">目录&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kubernetes-%E7%BD%91%E7%BB%9C%E8%A6%81%E6%B1%82">Kubernetes 网络要求&lt;/a>&lt;/li>
&lt;li>&lt;a href="#linux-%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A6%82%E6%9E%9C%E5%9C%A8-pod-%E4%B8%AD%E5%B7%A5%E4%BD%9C">Linux 网络命名空间如果在 pod 中工作&lt;/a>&lt;/li>
&lt;li>&lt;a href="#pause-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA-pod-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">Pause 容器创建 Pod 中的网络命名空间&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%B8%BA-pod-%E5%88%86%E9%85%8D%E4%BA%86-ip-%E5%9C%B0%E5%9D%80">为 Pod 分配了 IP 地址&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A3%80%E6%9F%A5%E9%9B%86%E7%BE%A4%E4%B8%AD-pod-%E5%88%B0-pod-%E7%9A%84%E6%B5%81%E9%87%8F">检查集群中 pod 到 pod 的流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#pod-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A1%A5%E6%8E%A5%E5%99%A8">Pod 命名空间连接到以太网桥接器&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%B7%9F%E8%B8%AA%E5%90%8C%E4%B8%80%E8%8A%82%E7%82%B9%E4%B8%8A-pod-%E9%97%B4%E7%9A%84%E6%B5%81%E9%87%8F">跟踪同一节点上 pod 间的流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%B7%9F%E8%B8%AA%E4%B8%8D%E5%90%8C%E8%8A%82%E7%82%B9%E4%B8%8A-pod-%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">跟踪不同节点上 pod 间的通信&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">位运算的工作原理&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3---cni">容器网络接口 - CNI&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A3%80%E6%9F%A5-pod-%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B5%81%E9%87%8F">检查 pod 到服务的流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%BD%BF%E7%94%A8-netfilter-%E5%92%8C-iptables-%E6%8B%A6%E6%88%AA%E5%92%8C%E9%87%8D%E5%86%99%E6%B5%81%E9%87%8F">使用 Netfilter 和 Iptables 拦截和重写流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%93%8D%E5%BA%94">检查服务的响应&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%9B%9E%E9%A1%BE">回顾&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes-网络要求">Kubernetes 网络要求&lt;/h2>
&lt;p>在深入了解 Kubernetes 中的数据流转之前，让我们先澄清下 Kubernetes 网络的要求。&lt;/p>
&lt;p>Kubernetes 网络模型定义了一套基本规则：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>集群中的 pod 应该能够与任何其他 pod 自由通信&lt;/strong>，而无需使用网络地址转换（NAT）。&lt;/li>
&lt;li>在不使用 NAT 的情况下，&lt;strong>集群节点上运行的任意程序都应该能够与同一节点上的任意 pod 通信&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>每个 pod 都有自己的 IP 地址&lt;/strong>（IP-per Pod），其他 pod 都可以使用同一个地址进行访问。&lt;/li>
&lt;/ul>
&lt;p>这些要求不会将实现限制在单一方案上。&lt;/p>
&lt;p>相反，他们概括了集群网络的特性。&lt;/p>
&lt;p>在满足这些限制时，必须解决如下&lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/network/networking.md">挑战&lt;/a>：&lt;/p>
&lt;ol>
&lt;li>&lt;em>如何保证同一 pod 中的容器间的访问就像在同一主机上一样？&lt;/em>&lt;/li>
&lt;li>&lt;em>Pod 能否访问集群中的其他 pod？&lt;/em>&lt;/li>
&lt;li>&lt;em>Pod 能否访问服务（service）？以及服务可以负载均衡请求吗？&lt;/em>&lt;/li>
&lt;li>&lt;em>Pod 可以接收来自集群外的流量吗？&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>本文将专注于前三点，从 pod 内部网络或者容器间的通信说起。&lt;/p>
&lt;h2 id="linux-网络命名空间如果在-pod-中工作">Linux 网络命名空间如果在 pod 中工作&lt;/h2>
&lt;p>我们想象下，有一个承载应用程序的主容器和另一个与它一起运行的容器。&lt;/p>
&lt;p>在示例 Pod 中有一个 Nginx 容器和 busybox 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">multi-container-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">container-1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;/bin/sh&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;-c&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;sleep 1d&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">container-2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在部署时，会出现如下情况：&lt;/p>
&lt;ol>
&lt;li>Pod 在节点上得到&lt;strong>自己的网络命名空间&lt;/strong>。&lt;/li>
&lt;li>Pod &lt;strong>分配到一个 IP 地址&lt;/strong>，两个容器间共享端口。&lt;/li>
&lt;li>&lt;strong>两个容器共享同一个网络命名空间&lt;/strong>，在本地互相可见。&lt;/li>
&lt;/ol>
&lt;p>网络配置在后台很快完成。&lt;/p>
&lt;p>然后，我们退后一步，是这理解&lt;em>为什么&lt;/em>上面是容器运行所必须的。&lt;/p>
&lt;p>&lt;a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">在 Linux 中，网络命名空间是独立的、隔离的逻辑空间。&lt;/a>&lt;/p>
&lt;p>可以将网络命名空间堪称将物理网络接口分割成更小的独立部分。&lt;/p>
&lt;p>每部分都可以单独配置，并使用自己的网络规则和资源。&lt;/p>
&lt;p>这些可以包括防火墙规则、接口（虚拟或物理）、路由和其他所有与网络相关的内容。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>物理接口持有根命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427699864958.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以使用 Linux 网络命名空间创建隔离的网络。每个网络都是独立的，除非进行配置否则不会与其他命名空间通信。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427700613518.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>物理接口必须处理最后的所有&lt;em>真实&lt;/em>数据包，因此所有的虚拟接口都是从中创建的。&lt;/p>
&lt;p>网络命名空间可以通过 &lt;a href="https://man7.org/linux/man-pages/man8/ip-netns.8.html">&lt;code>ip-netns&lt;/code> 管理工具&lt;/a> 来管理，可以使用 &lt;code>ip netns list&lt;/code> 列出主机上的命名空间。&lt;/p>
&lt;blockquote>
&lt;p>请注意，创建的网络命名空间将会出现在 &lt;code>/var/run/netns&lt;/code> 目录下，但 &lt;a href="https://www.packetcoders.io/how-to-view-the-network-namespaces-in-kubernetes/">Docker 并没有遵循这一点&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>例如，下面是 Kubernetes 节点的命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns list
cni-0f226515-e28b-df13-9f16-dd79456825ac &lt;span class="o">(&lt;/span>id: 3&lt;span class="o">)&lt;/span>
cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd &lt;span class="o">(&lt;/span>id: 4&lt;span class="o">)&lt;/span>
cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e &lt;span class="o">(&lt;/span>id: 2&lt;span class="o">)&lt;/span>
cni-7619c818-5b66-5d45-91c1-1c516f559291 &lt;span class="o">(&lt;/span>id: 1&lt;span class="o">)&lt;/span>
cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8 &lt;span class="o">(&lt;/span>id: 0&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意 &lt;code>cni-&lt;/code> 前缀意味着命名空间的创建由 CNI 来完成。&lt;/p>
&lt;/blockquote>
&lt;p>当创建 pod 并分配给节点时，&lt;a href="https://github.com/containernetworking/cni#what-is-cni">CNI&lt;/a> 会：&lt;/p>
&lt;ol>
&lt;li>为其创建网络命名空间。&lt;/li>
&lt;li>分配 IP 地址。&lt;/li>
&lt;li>将容器连接到网络。&lt;/li>
&lt;/ol>
&lt;p>如果 pod 像上面的示例一样包含多个容器，则所有容器都被置于同一个命名空间中。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建 pod 时，CNI 为容器创建网络命名空间&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427706567489.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后分配 IP 地址&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427707025246.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后将容器连接到网络的其余部分&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427710287189.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;em>那么当列出节点上的容器时会看到什么？&lt;/em>&lt;/p>
&lt;p>可以 SSH 到 Kubernetes 节点来查看命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ lsns -t net
NS TYPE NPROCS PID USER NETNSID NSFS COMMAND
&lt;span class="m">4026531992&lt;/span> net &lt;span class="m">171&lt;/span> &lt;span class="m">1&lt;/span> root unassigned /run/docker/netns/default /sbin/init noembed norestore
&lt;span class="m">4026532286&lt;/span> net &lt;span class="m">2&lt;/span> &lt;span class="m">4808&lt;/span> &lt;span class="m">65535&lt;/span> &lt;span class="m">0&lt;/span> /run/docker/netns/56c020051c3b /pause
&lt;span class="m">4026532414&lt;/span> net &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> &lt;span class="m">1&lt;/span> /run/docker/netns/7db647b9b187 /pause
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>lsns&lt;/code> 命令会列出主机上&lt;em>所有&lt;/em>的命名空间。&lt;/p>
&lt;blockquote>
&lt;p>记住 Linux 中有&lt;a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">多种命名空间类型&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;em>Nginx 容器在哪？&lt;/em>&lt;/p>
&lt;p>&lt;em>那么 &lt;code>pause&lt;/code> 容器又是什么？&lt;/em>&lt;/p>
&lt;h2 id="pause-容器创建-pod-中的网络命名空间">Pause 容器创建 Pod 中的网络命名空间&lt;/h2>
&lt;p>从节点上的所有进程中找出 Nginx 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ lsns
NS TYPE NPROCS PID USER COMMAND
&lt;span class="c1"># truncated output&lt;/span>
&lt;span class="m">4026532414&lt;/span> net &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> /pause
&lt;span class="m">4026532513&lt;/span> mnt &lt;span class="m">1&lt;/span> &lt;span class="m">5599&lt;/span> root sleep 1d
&lt;span class="m">4026532514&lt;/span> uts &lt;span class="m">1&lt;/span> &lt;span class="m">5599&lt;/span> root sleep 1d
&lt;span class="m">4026532515&lt;/span> pid &lt;span class="m">1&lt;/span> &lt;span class="m">5599&lt;/span> root sleep 1d
&lt;span class="m">4026532516&lt;/span> mnt &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532517&lt;/span> uts &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532518&lt;/span> pid &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该容器出现在了挂在（mount &lt;code>mnt&lt;/code>）、Unix 分时系统（Unix time-sharing &lt;code>uts&lt;/code>）和 PID（&lt;code>pid&lt;/code>）命名空间中，但是并不在网络命名空间（&lt;code>net&lt;/code>）中。&lt;/p>
&lt;p>不幸的是，&lt;code>lsns&lt;/code> 只显示了每个进程最低的 PID，不过可以根据进程 ID 进一步过滤。&lt;/p>
&lt;p>可以通过以下内容检索Nginx 容器的所有命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ sudo lsns -p &lt;span class="m">5777&lt;/span>
NS TYPE NPROCS PID USER COMMAND
&lt;span class="m">4026531835&lt;/span> cgroup &lt;span class="m">178&lt;/span> &lt;span class="m">1&lt;/span> root /sbin/init noembed norestore
&lt;span class="m">4026531837&lt;/span> user &lt;span class="m">178&lt;/span> &lt;span class="m">1&lt;/span> root /sbin/init noembed norestore
&lt;span class="m">4026532411&lt;/span> ipc &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> /pause
&lt;span class="m">4026532414&lt;/span> net &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> /pause
&lt;span class="m">4026532516&lt;/span> mnt &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532517&lt;/span> uts &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532518&lt;/span> pid &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>pause&lt;/code> 进程再次出现，这次它劫持了网络命名空间。&lt;/p>
&lt;p>&lt;em>那是什么？&lt;/em>&lt;/p>
&lt;p>&lt;strong>集群中的每个 pod 都有一个在后台运行的隐藏容器，被称为 &lt;code>pause&lt;/code>&lt;/strong>。&lt;/p>
&lt;p>列出节点上的所有容器并过滤出 pause 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ docker ps &lt;span class="p">|&lt;/span> grep pause
fa9666c1d9c6 k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_kube-dns-599484b884-sv2js…
44218e010aeb k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_blackbox-exporter-55c457d…
5fb4b5942c66 k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_kube-dns-599484b884-cq99x…
8007db79dcf2 k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_konnectivity-agent-84f87c…
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将看到对于节点分配到的每个 pod，都有一个匹配的 &lt;code>pause&lt;/code> 容器。&lt;/p>
&lt;p>&lt;strong>该 &lt;code>pause&lt;/code> 容器负责创建和维持网络命名空间。&lt;/strong>&lt;/p>
&lt;p>它包含的代码极少，部署后立即进入睡眠状态。&lt;/p>
&lt;p>然而，&lt;a href="https://www.ianlewis.org/en/almighty-pause-container">它在 Kubernetes 生态中的首当其冲，发挥着至关重要的作用。&lt;/a>。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建 pod 时，CNI 会创建一个带有&lt;em>睡眠&lt;/em>容器的网络命名空间&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427720335296.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pod 中的所有容器都会加入到它创建的网络命名空间中&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427721343650.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此时 CNI 分配 IP 地址并将容器连接到网络&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427710287189.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;em>进入睡眠状态的容器有什么用？&lt;/em>&lt;/p>
&lt;p>要了解它的实用性，我们可以想象下如示例一样有两个容器的 pod，但没有 &lt;code>pause&lt;/code> 容器。&lt;/p>
&lt;p>容器启动，CNI：&lt;/p>
&lt;ol>
&lt;li>为 Nginx 容器创建一个网络命名空间。&lt;/li>
&lt;li>把 busybox 容器加入到前面创建的网络命名空间中。&lt;/li>
&lt;li>为 pod 分配 IP 地址。&lt;/li>
&lt;li>将容器连接到网络。&lt;/li>
&lt;/ol>
&lt;p>&lt;em>假如 Nginx 容器崩溃了会发生什么？&lt;/em>&lt;/p>
&lt;p>CNI 将不得不&lt;em>再次&lt;/em>完成所有流程，两个容器的网络都会中断。&lt;/p>
&lt;p>由于 &lt;code>sleep&lt;/code> 容器不太可能有任何 bug，因此创建网络命名空间通常是一个更保险、更健壮的选择。&lt;/p>
&lt;p>&lt;strong>如果 pod 中的一个容器崩溃，其余的仍可以处理网络请求。&lt;/strong>&lt;/p>
&lt;h2 id="为-pod-分配了-ip-地址">为 Pod 分配了 IP 地址&lt;/h2>
&lt;p>前面提到 pod 和所有容器获得了同样的 IP。&lt;/p>
&lt;p>&lt;code>这是怎么配置的？&lt;/code>&lt;/p>
&lt;p>&lt;em>&lt;em>在 pod 网络命名空间中，创建一个接口并分配 IP 地址&lt;/em>。&lt;/em>&lt;/p>
&lt;p>我们来验证下。&lt;/p>
&lt;p>首先，找到 pod 的 IP 地址：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod multi-container-pod -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">={&lt;/span>.status.podIP&lt;span class="o">}&lt;/span>
10.244.4.40
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，找到相关的网络命名空间。&lt;/p>
&lt;p>由于网络命名空间是从物理接口创建的，需要访问集群节点。&lt;/p>
&lt;blockquote>
&lt;p>如果你运行的是 minikube，可以通过 &lt;code>minikube ssh&lt;/code> 访问节点。如果在云提供商中运行，应该有某种方法通过 SSH 访问节点。&lt;/p>
&lt;/blockquote>
&lt;p>进入后，可以找到创建的最新的网络命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ls -lt /var/run/netns
total &lt;span class="m">0&lt;/span>
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">25&lt;/span> 13:34 cni-0f226515-e28b-df13-9f16-dd79456825ac
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-7619c818-5b66-5d45-91c1-1c516f559291
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本示例中，它是 &lt;code>cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;/code>。此时，可以在该命名空间总执行 &lt;code>exec&lt;/code> 命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip a
&lt;span class="c1"># output truncated&lt;/span>
3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">1450&lt;/span> qdisc noqueue state UP group default
link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span class="m">0&lt;/span>
inet 10.244.4.40/32 brd 10.244.4.40 scope global eth0
valid_lft forever preferred_lft forever
inet6 fe80::14a4:f8ff:fe4f:5677/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>&lt;code>10.244.4.40&lt;/code> 就是 pod 的 IP 地址。&lt;/strong>&lt;/p>
&lt;p>通过查找 &lt;code>@if12&lt;/code> 中的 &lt;code>12&lt;/code> 找到网络接口。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip link &lt;span class="p">|&lt;/span> grep -A1 ^12
12: vethweplb3f36a0@if16: mtu &lt;span class="m">1376&lt;/span> qdisc noqueue master weave state UP mode DEFAULT group default
link/ether 72:1c:73:d9:d9:f6 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以验证 Nginx 容器是否从该命名空间中监听 HTTP 流量：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac netstat -lnp
Active Internet connections &lt;span class="o">(&lt;/span>only servers&lt;span class="o">)&lt;/span>
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
tcp &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 0.0.0.0:80 0.0.0.0:* LISTEN 692698/nginx: master
tcp6 &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> :::80 :::* LISTEN 692698/nginx: master
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>如果无法通过 SSH 访问集群的节点，可以试试 &lt;code>kubectl exec&lt;/code> 进入到 busybox 容器，然后使用 &lt;code>ip&lt;/code> 和 &lt;code>netstat&lt;/code> 命令。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;em>太棒了！&lt;/em>&lt;/p>
&lt;p>现在我们已经介绍了容器间的通信，接下来看看 Pod 与 Pod 直接如何建立通信。&lt;/p>
&lt;h2 id="检查集群中-pod-到-pod-的流量">检查集群中 pod 到 pod 的流量&lt;/h2>
&lt;p>当说起 pod 间通信时，会有两种可能：&lt;/p>
&lt;ol>
&lt;li>Pod 流量流向同一节点上的 pod。&lt;/li>
&lt;li>Pod 流量流量另一个节点上的 pod。&lt;/li>
&lt;/ol>
&lt;p>为了使整个设置正常工作，我们需要之前讨论过的虚拟接口和以太网桥接。&lt;/p>
&lt;p>在继续之前，我们先讨论下他们的功能以及为什么他们时必需的。&lt;/p>
&lt;p>&lt;strong>要完成 pod 与其他 pod 的通信，它必须先访问节点的根命名空间。&lt;/strong>&lt;/p>
&lt;p>这是使用连接 pod 和根命名空间的虚拟以太网对来实现的。&lt;/p>
&lt;p>这些&lt;a href="https://man7.org/linux/man-pages/man4/veth.4.html">虚拟接口设备&lt;/a>（&lt;code>veth&lt;/code> 中的 &lt;code>v&lt;/code>）连接并充当两个命名空间间的隧道。&lt;/p>
&lt;p>使用此 &lt;code>veth&lt;/code> 设备，将一端连接到 pod 的命名空间，另一端连接到根命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427710287189.jpg" alt="">&lt;/p>
&lt;p>这些 CNI 可以替你做，也可以手动操作：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip link add veth1 netns pod-namespace &lt;span class="nb">type&lt;/span> veth peer veth2 netns root
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在 pod 的命名空间有了可以访问根命名空间的隧道。&lt;/p>
&lt;p>&lt;strong>节点上每个新建的 pod 都会设置如下所示的 veth 对。&lt;/strong>&lt;/p>
&lt;p>创建接口对时其中一部分。&lt;/p>
&lt;p>其他的就是为以太网设备分配地址，并创建默认路由。&lt;/p>
&lt;p>来看下如何在 pod 的命名空间中设置 &lt;code>veth1&lt;/code> 接口：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip addr add 10.244.4.40/24 dev veth1
$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip link &lt;span class="nb">set&lt;/span> veth1 up
$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip route add default via 10.244.4.40
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在节点侧，我们创建另一个 &lt;code>veth2&lt;/code> 对：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip addr add 169.254.132.141/16 dev veth2
$ ip link &lt;span class="nb">set&lt;/span> veth2 up
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以像以前一样检查现有的 &lt;code>veth&lt;/code> 对。&lt;/p>
&lt;p>在 pod 的命名空间中，检查 &lt;code>eth0&lt;/code> 接口的后缀。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip link show &lt;span class="nb">type&lt;/span> veth
3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">1450&lt;/span> qdisc noqueue state UP mode DEFAULT group default
link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种情况下可以使用 &lt;code>grep -A1 ^12&lt;/code> 进行查找（或者滚动到目标所在）：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip link show &lt;span class="nb">type&lt;/span> veth
&lt;span class="c1"># output truncated&lt;/span>
12: cali97e50e215bd@if3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">1450&lt;/span> qdisc noqueue state UP mode DEFAULT group default
link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netns cni-0f226515-e28b-df13-9f16-dd79456825ac
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>也可以使用 &lt;code>ip -n cni-0f226515-e28b-df13-9f16-dd79456825ac link show type veth&lt;/code> 命令。&lt;/p>
&lt;/blockquote>
&lt;p>注意 &lt;code>3: eth0@if12&lt;/code> 和 &lt;code>12: cali97e50e215bd@if3&lt;/code> 接口上的符号。&lt;/p>
&lt;p>在 pod 命名空间中，&lt;code>eth0&lt;/code> 接口连接到根命名空间中编号为 &lt;code>12&lt;/code> 的接口。因此是 &lt;code>@if12&lt;/code>。&lt;/p>
&lt;p>在 &lt;code>veth&lt;/code> 对的另一端，根命名空间连接到 pod 命名空间的 &lt;code>3&lt;/code> 号接口。&lt;/p>
&lt;p>接下来是连接 &lt;code>veth&lt;/code> 对两端的桥接器（bridge）。&lt;/p>
&lt;h2 id="pod-命名空间连接到以太网桥接器">Pod 命名空间连接到以太网桥接器&lt;/h2>
&lt;p>桥接器将位于根命名空间中的虚拟接口的每一端“绑定”。&lt;/p>
&lt;p>&lt;strong>该桥接器将允许流量在虚拟对之间流动，并通过公共根命名空间。&lt;/strong>&lt;/p>
&lt;p>&lt;em>理论时间。&lt;/em>&lt;/p>
&lt;p>以太网桥接器位于&lt;a href="https://en.wikipedia.org/wiki/OSI_model">OSI 网络模型&lt;/a>的第二层。&lt;/p>
&lt;p>&lt;a href="https://ops.tips/blog/using-network-namespaces-and-bridge-to-isolate-servers/">可以将桥接器看作一个虚拟交换机，接受来自不同命名空间和接口的连接。&lt;/a>&lt;/p>
&lt;p>&lt;strong>以太网桥接器允许连接同一个节点上的多个可用网络。&lt;/strong>&lt;/p>
&lt;p>因此，可以使用该设置连接两个接口：从 pod 命名空间的 &lt;code>veth&lt;/code> 连接到同一节点上另一个 pod 的 &lt;code>veth&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427769020626.jpg" alt="">&lt;/p>
&lt;p>我们继续看下以太网桥接器和 veth 对的作用。&lt;/p>
&lt;h2 id="跟踪同一节点上-pod-间的流量">跟踪同一节点上 pod 间的流量&lt;/h2>
&lt;p>假设同一个节点上有两个 pod，Pod-A 想向 Pod-B 发送消息。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>由于目标不是同命名空间的容器，Pod-A 向其默认接口 &lt;code>eth0&lt;/code> 发送数据包。这个接口与 &lt;code>veth&lt;/code> 对的一端绑定，作为隧道。因此数据包将被转发到节点的根命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427770131482.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以太网桥接器作为虚拟交换机，必须以某种方式将目标 pod IP（Pod-B）解析为其 MAC 地址。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427772473425.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>轮到ARP 协议上场了。当帧到达桥接器时，会向所有连接的设备发送 ARP 广播。桥接器喊道&lt;em>谁有 Pod-B 的 IP 地址&lt;/em>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427774225871.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>收到带有连接 Pod-B 接口的 MAC 地址的回复，然后此信息存储在桥接器 ARP 缓存（查找表）中。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427775056174.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IP 和 MAC 地址的映射存储完成后，桥接器在表中查找，并将数据包转发到正确的短点。数据包到达根命名空间中 Pod- B 的 &lt;code>veth&lt;/code>，然后从那快速到达 Pod-B 命名空间内的 &lt;code>eth0&lt;/code> 接口。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427775056174.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>有了这个，Pod-A 和 Pod-B 之间的通信取得了成功。&lt;/p>
&lt;h2 id="跟踪不同节点上-pod-间的通信">跟踪不同节点上 pod 间的通信&lt;/h2>
&lt;p>对于需要跨不同节点通信的 pod，需要额外的通信跳转。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>前几个步骤保持不变，直到数据包到达根命名空间并需要发送到 Pod- B。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427777182601.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当目标地址不在本地网络中，数据包将被转发到本节点的默认网关。节点上退出或默认网关通常位于 &lt;code>eth0&lt;/code> 接口上 &amp;ndash; 将节点连接到网络的物理接口。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427777968858.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>这次并不会发生 ARP 解析，因为源和目标 IP 在不同网络上。&lt;/strong>&lt;/p>
&lt;p>检查使用位运算（Bitwise）操作完成。&lt;/p>
&lt;p>当目标 IP 不在当前网络上时，数据包将被转发到节点的默认网关。&lt;/p>
&lt;h3 id="位运算的工作原理">位运算的工作原理&lt;/h3>
&lt;p>在确定数据包的转发位置时，源节点必须执行位运算。&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">这也被称为与操作。&lt;/a>&lt;/p>
&lt;p>作为复习，位与操作产生如下结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了 1 与 1 以外的都是 false。&lt;/p>
&lt;p>如果源节点的 IP 为 192.168.1.1，子网掩码为 /24，目标 IP 为 172.16.1.1/16，则按位与操作将确认他们不在同一网络上。&lt;/p>
&lt;p>这意味着目标 IP 与数据包的源在不同的网络上，因此数据包将在默认网关中转发。&lt;/p>
&lt;p>&lt;em>数学时间。&lt;/em>&lt;/p>
&lt;p>我们必须从二进制文件中的 32 位地址执行与操作开始。&lt;/p>
&lt;p>先找出源和目标 IP 的网络。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">| Type | Binary | Converted |
| ---------------- | ----------------------------------- | ------------------ |
| Src. IP Address | 11000000.10101000.00000001.00000001 | 192.168.1.1 |
| Src. Subnet Mask | 11111111.11111111.11111111.00000000 | 255.255.255.0(/24) |
| Src. Network | 11000000.10101000.00000001.00000000 | 192.168.1.0 |
| | | |
| Dst. IP Address | 10101100.00010000.00000001.00000001 | 172.16.1.1 |
| Dst. Subnet Mask | 11111111.11111111.00000000.00000000 | 255.255.0.0(/16) |
| Dst. Network | 10101100.00010000.00000000.00000000 | 172.16.0.0 |
&lt;/code>&lt;/pre>&lt;/div>&lt;p>位运算操作后，需要将目标 IP 与数据包源节点的子网进行比较。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">| Type | Binary | Converted |
| ---------------- | ----------------------------------- | ------------------ |
| Dst. IP Address | 10101100.00010000.00000001.00000001 | 172.16.1.1 |
| Src. Subnet Mask | 11111111.11111111.11111111.00000000 | 255.255.255.0(/24) |
| Network Result | 10101100.00010000.00000001.00000000 | 172.16.1.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>进行位比较后，ARP 会检查其查询表来查找默认网关的 MAC 地址。&lt;/p>
&lt;p>如果有条目，将立即转发数据包。&lt;/p>
&lt;p>否则，先进行广播以确定网关的 MAC 地址。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>数据包现在路由到另一个节点的默认接口，我们叫它 Node-B。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428091589748.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以相反的顺序。数据包现在位与 Node-B 的根命名空间，并到达桥接器，这里会进行 ARP 解析。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428095883798.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>收到带有连接 Pod-B 的接口 MAC地址的回复。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428097041936.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这次桥接器通过 Pod-B 的 &lt;code>veth&lt;/code> 设备将帧转发，并到达 Pod-B 自己的命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428097041936.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>此时应该已经熟悉了 pod 之间的流量如何流转，接下来再探索下 CNI 如何创建上述内容。&lt;/p>
&lt;h2 id="容器网络接口---cni">容器网络接口 - CNI&lt;/h2>
&lt;p>&lt;a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">容器网络接口（CNI）关注当前节点的网络。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428099347551.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>可以将 CNI 看作网络插件在解决 Kubernetes &lt;em>某些&lt;/em> 需求时要遵循的一套规则。&lt;/strong>&lt;/p>
&lt;p>然而，它不仅仅与 Kubernetes 或者特定网络插件关联。&lt;/p>
&lt;p>可以使用如下 CNI：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.tigera.io/project-calico/">Calico&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cilium.io/">Cilium&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/flannel-io/flannel">Flannel&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.weave.works/docs/net/latest/overview/">Weave Net&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containernetworking/cni#3rd-party-plugins">其他网络插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>他们都实现相同的 CNI 标准。&lt;/p>
&lt;p>如果没有 CNI，你需要手动完成如下操作：&lt;/p>
&lt;ul>
&lt;li>创建 pod（容器）的网络命名空间&lt;/li>
&lt;li>创建接口&lt;/li>
&lt;li>创建 veth 对&lt;/li>
&lt;li>设置命名空间网络&lt;/li>
&lt;li>设置静态路由&lt;/li>
&lt;li>配置以太网桥接器&lt;/li>
&lt;li>分配 IP 地址&lt;/li>
&lt;li>创建 NAT 规则&lt;/li>
&lt;/ul>
&lt;p>还有太多其他需要手动完成的工作。&lt;/p>
&lt;p>更不用说删除或重新启动 pod 时删除或调整上述所有内容了。&lt;/p>
&lt;p>CNI 必须支持&lt;a href="https://github.com/containernetworking/cni/blob/master/SPEC.md#cni-operations">四个不同的操作&lt;/a>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ADD&lt;/strong> - 将容器添加到网络&lt;/li>
&lt;li>&lt;strong>DEL&lt;/strong> - 从网络中删除容器&lt;/li>
&lt;li>&lt;strong>CHECK&lt;/strong> - 如果容器的网络出现问题，则返回错误&lt;/li>
&lt;li>&lt;strong>VERSION&lt;/strong> - 显示插件的版本&lt;/li>
&lt;/ul>
&lt;p>&lt;em>让我们在实践中看看它是如何工作的。&lt;/em>&lt;/p>
&lt;p>当 pod 分配到特定节点时，kubelet 本身不会初始化网络。&lt;/p>
&lt;p>相反，它将任务交给了 CNI。&lt;/p>
&lt;p>&lt;strong>然后，它指定了配置，并以 JSON 格式将其发送给 CNI 插件。&lt;/strong>&lt;/p>
&lt;p>可以在节点的 &lt;code>/etc/cni/net.d&lt;/code> 目录中，找到当前 CNI 的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat 10-calico.conflist
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;k8s-pod-network&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;cniVersion&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;0.3.1&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;plugins&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;calico&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;datastore_type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;kubernetes&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;mtu&amp;#34;&lt;/span>: 0,
&lt;span class="s2">&amp;#34;nodename_file_optional&amp;#34;&lt;/span>: false,
&lt;span class="s2">&amp;#34;log_level&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Info&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;log_file_path&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/var/log/calico/cni/cni.log&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;ipam&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span> &lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;calico-ipam&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;assign_ipv4&amp;#34;&lt;/span> : &lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;assign_ipv6&amp;#34;&lt;/span> : &lt;span class="s2">&amp;#34;false&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;container_settings&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;allow_ip_forwarding&amp;#34;&lt;/span>: &lt;span class="nb">false&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;policy&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;k8s&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;kubernetes&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;k8s_api_root&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;https://10.96.0.1:443&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;kubeconfig&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/etc/cni/net.d/calico-kubeconfig&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;bandwidth&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;capabilities&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bandwidth&amp;#34;&lt;/span>: true&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;portmap&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;snat&amp;#34;&lt;/span>: true, &lt;span class="s2">&amp;#34;capabilities&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;portMappings&amp;#34;&lt;/span>: true&lt;span class="o">}}&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>每个插件都使用不同类型的配置来设置网络。&lt;/strong>&lt;/p>
&lt;p>例如，Calico 使用 BGP 路由协议配对的第 3 层网络来连接 pod。&lt;/p>
&lt;p>Cilium 在第 3 到 7 层使用 eBPF 配置覆盖网络。&lt;/p>
&lt;p>与 Calico 一起，Cilium 支持设置网络策略来限制流量。&lt;/p>
&lt;p>&lt;em>那该如何选择呢？&lt;/em>&lt;/p>
&lt;p>这取决于。&lt;/p>
&lt;p>CNI 主要有两组。&lt;/p>
&lt;p>&lt;strong>第一组中，可以找到使用基本网络设置（也称为扁平网络）的CNI&lt;/strong>，并将集群 IP 池 中的IP 地址分配给 pod。&lt;/p>
&lt;p>这可能会因为快速用尽可用的 IP 地址而成为负担。&lt;/p>
&lt;p>&lt;strong>相反，另一种方法是使用覆盖网络。&lt;/strong>&lt;/p>
&lt;p>简而言之，覆盖网络是主（底层）网络之上的辅助网络。&lt;/p>
&lt;p>&lt;strong>覆盖网络的工作原理是封装来自底层网络的所有数据包，这些数据包指向另一个节点上的 pod。&lt;/strong>&lt;/p>
&lt;p>覆盖网络的一项流行技术是 &lt;a href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN">VXLAN&lt;/a>，它允许在 L3 网络上隧道传输 L2 域。&lt;/p>
&lt;p>&lt;em>那么哪种更好？&lt;/em>&lt;/p>
&lt;p>&lt;strong>没有唯一的答案，通常取决于你的需求。&lt;/strong>&lt;/p>
&lt;p>&lt;em>你是在构建一个拥有数万个节点的大集群吗？&lt;/em>&lt;/p>
&lt;p>可能覆盖网络更好。&lt;/p>
&lt;p>&lt;em>你是否在意更简单的设置和在嵌套网络中不失去检查网络流量的能力。&lt;/em>&lt;/p>
&lt;p>扁平网络更适合你。&lt;/p>
&lt;p>现在已经讨论了 CNI，让我们继续探索 Pod 到服务（service）的通信是如何完成的。&lt;/p>
&lt;h2 id="检查-pod-到服务的流量">检查 pod 到服务的流量&lt;/h2>
&lt;p>由于 Kubernetes 环境下 pod 的动态特性，分配给 pod 的 IP 地址不是静态的。&lt;/p>
&lt;p>&lt;strong>这些 IP 地址是短暂的，每次创建或者删除 pod 时都会发生变化。&lt;/strong>&lt;/p>
&lt;p>服务解决了这个问题，为连接到一组 pod 提供了稳定的机制。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428122010963.jpg" alt="">&lt;/p>
&lt;p>默认情况下，在 Kubernetes 中创建服务时，会&lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">为其预定并分配虚拟 IP &lt;/a>。&lt;/p>
&lt;p>使用选择器将服务于目标 pod 进行管理。&lt;/p>
&lt;p>&lt;em>当删除 pod 并添加新 pod 时会发生什么？&lt;/em>&lt;/p>
&lt;p>&lt;strong>该服务的虚拟 IP 保持不变。&lt;/strong>&lt;/p>
&lt;p>然而，无需敢于，流量将到达新创建的 pod。&lt;/p>
&lt;p>换句话说，Kubernetes 中的服务类似于负载均衡器。&lt;/p>
&lt;p>&lt;em>但他们时如何工作的？&lt;/em>&lt;/p>
&lt;h2 id="使用-netfilter-和-iptables-拦截和重写流量">使用 Netfilter 和 Iptables 拦截和重写流量&lt;/h2>
&lt;p>Kubernetes 中的服务基于两个 Linux 内核组件：&lt;/p>
&lt;ol>
&lt;li>Netfilter&lt;/li>
&lt;li>Iptables&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Netfilter 是一个框架，允许配置数据包过滤、创建 NAT或端口翻译规则，并管理网络中的流量。&lt;/strong>&lt;/p>
&lt;p>此外，它还屏蔽和阻止不请自来的连接访问服务。&lt;/p>
&lt;p>&lt;strong>另一方面，Iptables 是一个用户空间程序，允许你配置 Linux 内核防火墙的 IP 数据包过滤器规则。&lt;/strong>&lt;/p>
&lt;p>iptables 使用不同的 Netfilter 模块实现。&lt;/p>
&lt;p>你可以使用 iptables CLI 实时更改过滤规则，并将其插入 netfilters 的挂点。&lt;/p>
&lt;p>过滤器组织在不同的表中，其中包含处理网络流量数据包的链。&lt;/p>
&lt;p>每个协议都使用不同的内核模块和程序。&lt;/p>
&lt;blockquote>
&lt;p>当提到 iptables 时，通常说的是 IPV4。对于 IPV6 的规则，CLI 是 ip6tables。&lt;/p>
&lt;/blockquote>
&lt;p>Iptables 有五种类型的链，每种链都直接映射到 Netfilter 钩子。&lt;/p>
&lt;p>从 iptables 角度看是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>PRE_ROUTING&lt;/code>&lt;/li>
&lt;li>&lt;code>INPUT&lt;/code>&lt;/li>
&lt;li>&lt;code>FORWARD&lt;/code>&lt;/li>
&lt;li>&lt;code>OUTPUT&lt;/code>&lt;/li>
&lt;li>&lt;code>POST_ROUTING&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>对应映射到 Netfilter 钩子：&lt;/p>
&lt;ul>
&lt;li>&lt;code>NF_IP_PRE_ROUTING&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_LOCAL_IN&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_FORWARD&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_LOCAL_OUT&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_POST_ROUTING&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>当数据包到达时，根据所处的阶段，会“出发” Netfilter 钩子，该钩子应用特定的 iptables 过滤。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428137183275.jpg" alt="">&lt;/p>
&lt;p>&lt;em>哎呀，看起来很复杂！&lt;/em>&lt;/p>
&lt;p>不过不需要担心。&lt;/p>
&lt;p>这就是为什么我们使用 Kubernetes，上面的所有内容都是通过使用服务来抽象的，一个简单的 YAML 定义就可以自动完成这些规则的设置。&lt;/p>
&lt;p>如果对这些 iptables 规则感兴趣，可以登陆到节点并运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">iptables-save
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用&lt;a href="https://github.com/Nudin/iptable_vis">可视化工具&lt;/a>浏览节点上的 iptables 链。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428153624915.jpg" alt="">&lt;/p>
&lt;p>&lt;em>记住，可能会有数百条规则。想象下手动创建的难度。&lt;/em>&lt;/p>
&lt;p>我们已经解释了相同和不同节点上的 pod 间如何通信。&lt;/p>
&lt;p>在 Pod-to-Service 中，通信的前半部分保持不变。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428154678475.jpg" alt="">&lt;/p>
&lt;p>当 Pod-A 发出请求时，希望到达 Pod-B（这种情况下，Pod-B 位与服务之后），转移的过程中会发生其他变化。&lt;/p>
&lt;p>原始请求从 Pod-A 命名空间中的 &lt;code>eth0&lt;/code> 接口出来。&lt;/p>
&lt;p>从那里穿过 &lt;code>veth&lt;/code> 对，到达根命名空间的以太网桥。&lt;/p>
&lt;p>一旦到达桥接器，数据包立即通过默认网关转发。&lt;/p>
&lt;p>与 Pod-to-Pod 部分一样，主机进行位比较，由于服务的 vIP 不是节点 CIDR 的一部分，数据包将立即通过默认网关转发出去。&lt;/p>
&lt;p>如果查找表中尚没有默认网关的 MAC 地址，则会进行相同的 ARP 解析。&lt;/p>
&lt;p>&lt;em>现在魔法发生了。&lt;/em>&lt;/p>
&lt;p>在数据包经过节点的路由处理之前，Netfilter 钩子 &lt;code>NF_IP_PRE_ROUTING&lt;/code> 被触发并应用一条 iptables 规则。规则进行了 DNAT 转换，重写了 POD-A 数据包的目标 IP 地址。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428159345915.jpg" alt="">&lt;/p>
&lt;p>原来服务 vIP 地址被重写称 POD-B 的IP 地址。&lt;/p>
&lt;p>从那里，路由就像 Pod-to-Pod 直接通信一样。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428160707534.jpg" alt="">&lt;/p>
&lt;p>然而，在所有这些通信之间，使用了第三个功能。&lt;/p>
&lt;p>&lt;a href="https://www.linuxtopia.org/Linux_Firewall_iptables/x1298.html">这个功能被称为 conntrack&lt;/a>，或连接跟踪。&lt;/p>
&lt;p>&lt;strong>Conntrack 将数据包与连接关联起来，并在 Pod-B 发送回响应时跟踪其来源。&lt;/strong>&lt;/p>
&lt;p>NAT 严重依赖 contrack 工作。&lt;/p>
&lt;p>如果没有连接跟踪，它将不知道将包含响应的数据包发送回哪里。&lt;/p>
&lt;p>使用 conntrack 时，数据包的返回路径可以轻松设置相同的源或目标 NAT 更改。&lt;/p>
&lt;p>另一半使用相反的顺序执行。&lt;/p>
&lt;p>Pod-B 接收并处理了请求，现在将数据发送回 Pod-A。&lt;/p>
&lt;p>&lt;em>此时会发生什么？&lt;/em>&lt;/p>
&lt;h2 id="检查服务的响应">检查服务的响应&lt;/h2>
&lt;p>现在 Pod-B 发送响应，将其 IP 地址设置为源地址，Pod-A IP 地址设置为目标地址。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当数据包到达 Pod-A 所在节点的接口时，就会发生另一个 NAT&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428165510048.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这次，使用 conntrack 更改源 IP 地址，iptables 规则执行 SNAT 将 Pod-B IP 地址替换为原始服务的 VIP 地址。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428166224192.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从 Pod-A 来看像是服务发回的响应，而不是 Pod-B。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428166224192.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>其他部分都一样；一旦 SNAT 完成，数据包到达根命名空间中的以太网桥接器，并通过 veth 对转发到 Pod-A。&lt;/p>
&lt;h2 id="回顾">回顾&lt;/h2>
&lt;p>让我们来总结下你在本文中学到的东西：&lt;/p>
&lt;ul>
&lt;li>容器如何在本地或 pod 内通信。&lt;/li>
&lt;li>当 pod 位于相同和不同的节点上时，Pod-to- Pod 如何通信。&lt;/li>
&lt;li>Pod-to-Service - 当 pod 向 Kubernetes 服务背后的 pod 发送流量时。&lt;/li>
&lt;li>Kubernetes 网络工具箱中有效通信所需的命名空间、veth、iptables、链、Netfilter、CNI、覆盖网络以及所有其他内容。&lt;/li>
&lt;/ul></description></item><item><title>Kubernetes 上调试 distroless 容器</title><link>https://atbug.com/debug-distroless-container-on-kubernetes/</link><pubDate>Wed, 03 Nov 2021 07:40:40 +0800</pubDate><guid>https://atbug.com/debug-distroless-container-on-kubernetes/</guid><description>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>本文内容：&lt;/p>
&lt;ul>
&lt;li>介绍 distroless 镜像、作用以及简单的使用&lt;/li>
&lt;li>如何针对 distroless 容器的进行调试&lt;/li>
&lt;li>临时容器(v.1.18+)的使用&lt;/li>
&lt;/ul>
&lt;h2 id="distroless-镜像">Distroless 镜像&lt;/h2>
&lt;p>Distroless 容器，顾名思义使用 &lt;a href="https://github.com/GoogleContainerTools/distroless">Distroless 镜像&lt;/a>作为基础镜像运行的容器。&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;Distroless&amp;rdquo; 镜像只包含了你的应用程序以及其运行时所需要的依赖。不包含你能在标准 Linxu 发行版里的可以找到的包管理器、shells 或者其他程序。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/GoogleContainerTools/distroless">GoogleContainerTools/distroless&lt;/a> 针对不同语言提供了 distroless 镜像：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/base/README.md">gcr.io/distroless/static-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/base/README.md">gcr.io/distroless/base-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/java/README.md">gcr.io/distroless/java-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/cc/README.md">gcr.io/distroless/cc-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/nodejs/README.md">gcr.io/distroless/nodejs-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/experimental/python3/README.md">gcr.io/distroless/python3-debian11&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="distroless-镜像有什么用">Distroless 镜像有什么用？&lt;/h2>
&lt;p>那些可能是构建镜像时需要的，但大部分并不是运行时需要的。这也是为什么&lt;a href="https://mp.weixin.qq.com/s/Y3GQI3hg5I8MHOV4iwVqiQ">上篇文章介绍 Buildpacks&lt;/a> 时说的一个 builder 的 stack 镜像包含构建时基础镜像和运行时基础镜像，这样可以做到镜像的最小化。&lt;/p>
&lt;p>其实控制体积并不是 distroless 镜像的主要作用。将运行时容器中的内容限制为应用程序所需的依赖，此外不应该安装任何东西。这种方式可能极大的提升容器的安全性，也是 distroless 镜像的最重要作用。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/11/02/16357706125816.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>这里并不会再深入探究 distroless 镜像，而是如何调试 distroless 容器&lt;/strong>&lt;/p>
&lt;p>没有了包管理器，镜像构建完成后就不能再使用类似 &lt;code>apt&lt;/code>、&lt;code>yum&lt;/code> 的包管理工具；没有了 &lt;code>shell&lt;/code>，容器运行后无法再进入容器。&lt;/p>
&lt;p>&lt;em>“就像一个没有任何门的房间，也无法安装门。”&lt;/em> Distroless 镜像在提升容器安全性的同时，也为调试增加了难度。&lt;/p>
&lt;h2 id="使用-distroless-镜像">使用 distroless 镜像&lt;/h2>
&lt;p>写个很简单的 golang 应用：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">defaultHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello world!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">defaultHandler&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如使用 &lt;code>gcr.io/distroless/base-debian11&lt;/code> 作为 golang 应用的基础镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> golang:1.12 as build-env&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /go/src/app&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /go/src/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go get -d -v ./...&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go build -o /go/bin/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> gcr.io/distroless/base-debian11&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build-env /go/bin/app /&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/app&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用镜像创建 deployment&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl create deploy golang-distroless --image addozhang/golang-distroless-example:latest
$ kubectl get po
NAME READY STATUS RESTARTS AGE
golang-distroless-784bb4875-srmmr 1/1 Running &lt;span class="m">0&lt;/span> 3m2s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>尝试进入容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl &lt;span class="nb">exec&lt;/span> -it golang-distroless-784bb4875-srmmr -- sh
error: Internal error occurred: error executing &lt;span class="nb">command&lt;/span> in container: failed to &lt;span class="nb">exec&lt;/span> in container: failed to start &lt;span class="nb">exec&lt;/span> &lt;span class="s2">&amp;#34;b76e800eafa85d39f909f39fcee4a4ba9fc2f37d5f674aa6620690b8e2939203&amp;#34;&lt;/span>: OCI runtime &lt;span class="nb">exec&lt;/span> failed: &lt;span class="nb">exec&lt;/span> failed: container_linux.go:380: starting container process caused: exec: &lt;span class="s2">&amp;#34;sh&amp;#34;&lt;/span>: executable file not found in &lt;span class="nv">$PATH&lt;/span>: unknown
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何调试-distroless-容器">如何调试 Distroless 容器&lt;/h2>
&lt;h3 id="1-使用-distroless-debug-镜像">1. 使用 distroless debug 镜像&lt;/h3>
&lt;p>GoogleContainerTools 为每个 distroless 镜像都提供了 &lt;code>debug&lt;/code> tag，&lt;strong>适合在开发阶段进行调试&lt;/strong>。如何使用？替换容器的 base 镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> golang:1.12 as build-env&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /go/src/app&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /go/src/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go get -d -v ./...&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go build -o /go/bin/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> gcr.io/distroless/base-debian11:debug # use debug tag here&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build-env /go/bin/app /&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/app&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重新构建镜像并部署，得益于&lt;code>debug&lt;/code>镜像中提供了 busybox shell 让我们可以 exec 到容器中。&lt;/p>
&lt;h3 id="2-debug-容器与共享进程命名空间">2. debug 容器与共享进程命名空间&lt;/h3>
&lt;p>同一个 pod 中可以运行多个容器，通过设置 &lt;code>pod.spec.shareProcessNamespace&lt;/code> 为 &lt;code>true&lt;/code>，来让同一个 Pod 中的&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/">多容器共享同一个进程命名空间&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>Share a single process namespace between all of the containers in a pod.
When this is set containers will be able to view and signal processes from
other containers in the same pod, and the first process in each container
will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both
be set. Optional: Default to false.&lt;/p>
&lt;/blockquote>
&lt;p>添加一个使用 &lt;code>ubuntu&lt;/code> 镜像的 &lt;code>debug&lt;/code> 容器，这里为了测试（后面解释）我们为原容器添加 &lt;code>securityContext.runAsUser: 1000&lt;/code>，模拟两个容器使用不同的 UID 运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">strategy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">shareProcessNamespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">addozhang/golang-distroless-example:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless-example&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">securityContext&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runAsUser&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1000&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">debug&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;sleep&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1d&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">securityContext&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capabilities&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">add&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">SYS_PTRACE&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更新 deployment 之后：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get po
NAME READY STATUS RESTARTS AGE
golang-distroless-85c4896c45-rkjwn 2/2 Running &lt;span class="m">0&lt;/span> 3m12s
$ kubectl get po -o json &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.items[].spec.containers[].name&amp;#39;&lt;/span>
golang-distroless-example
debug
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后通过 debug 容器来进入到 pod 中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl &lt;span class="nb">exec&lt;/span> -it golang-distroless-85c4896c45-rkjwn -c debug -- sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在容器中执行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ps -ef
UID PID PPID C STIME TTY TIME CMD
root &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:54 ? 00:00:00 /pause &lt;span class="c1"># infra 容器&lt;/span>
&lt;span class="m">1000&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:54 ? 00:00:00 /app &lt;span class="c1"># 原容器，UID 为 1000&lt;/span>
root &lt;span class="m">19&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:55 ? 00:00:00 sleep 1d &lt;span class="c1"># debug 容器&lt;/span>
root &lt;span class="m">25&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:55 pts/0 00:00:00 sh
root &lt;span class="m">32&lt;/span> &lt;span class="m">25&lt;/span> &lt;span class="m">0&lt;/span> 14:55 pts/0 00:00:00 ps -ef
&lt;/code>&lt;/pre>&lt;/div>&lt;p>尝试访问 进程 &lt;code>7&lt;/code> 的进程空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat /proc/7/environ
$ cat: /proc/7/environ: Permission denied
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们需要为 &lt;code>debug&lt;/code> 容器加上：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">securityContext&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capabilities&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">add&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">SYS_PTRACE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后再访问就正常了：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat /proc/7/environ
&lt;span class="nv">PATH&lt;/span>&lt;span class="o">=&lt;/span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME&lt;span class="o">=&lt;/span>golang-distroless-58b6c5f455-v9zkvSSL_CERT_FILE&lt;span class="o">=&lt;/span>/etc/ssl/certs/ca-certificates.crtKUBERNETES_PORT_443_TCP&lt;span class="o">=&lt;/span>tcp://10.43.0.1:443KUBERNETES_PORT_443_TCP_PROTO&lt;span class="o">=&lt;/span>&lt;span class="nv">tcpKUBERNETES_PORT_443_TCP_PORT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">443KUBERNETES_PORT_443_TCP_ADDR&lt;/span>&lt;span class="o">=&lt;/span>10.43.0.1KUBERNETES_SERVICE_HOST&lt;span class="o">=&lt;/span>10.43.0.1KUBERNETES_SERVICE_PORT&lt;span class="o">=&lt;/span>&lt;span class="nv">443KUBERNETES_SERVICE_PORT_HTTPS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">443KUBERNETES_PORT&lt;/span>&lt;span class="o">=&lt;/span>tcp://10.43.0.1:443HOME&lt;span class="o">=&lt;/span>/root
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样我们也可以访问进程的文件系统：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">$ &lt;span class="nb">cd&lt;/span> /proc/7/root
$ ls
app bin boot dev etc home lib lib64 proc root run sbin sys tmp usr var
&lt;/code>&lt;/pre>&lt;/div>&lt;p>无需修改容器的基础镜像，使用 &lt;code>pod.spec.shareProcessNamespace: true&lt;/code> 配合安全配置中增加 &lt;code>SYS_PTRACE&lt;/code> 特性，为 debug 容器赋予完整的 shell 访问来调试应用。但是修改 YAML 和安全配置只适合在测试环境使用，到了生产环境这些都是不允许的。&lt;/p>
&lt;p>我们就需要用到 &lt;code>kubectl debug&lt;/code> 了。&lt;/p>
&lt;h3 id="3-kubectl-debug">3. Kubectl debug&lt;/h3>
&lt;p>针对不同的资源 &lt;code>kubectl debug&lt;/code> 可以进行不同操作：&lt;/p>
&lt;ul>
&lt;li>负载：创建一个正在运行的 Pod 的拷贝，并可以修改部分属性。比如在拷贝中使用新版本的tag。&lt;/li>
&lt;li>负载：为运行中的 Pod 增加一个临时容器（下面介绍），使用临时容器中的工具调试，无需重启 Pod。&lt;/li>
&lt;li>节点：在节点上创建一个 Pod 运行在&lt;strong>节点的 host 命名空间&lt;/strong>，可以访问节点的文件系统。&lt;/li>
&lt;/ul>
&lt;h4 id="31-临时容器">3.1 临时容器&lt;/h4>
&lt;p>从 Kubernetes 1.18 之后开始，可以使用 &lt;code>kubectl&lt;/code> 为运行的 pod 添加一个临时容器。这个命令还处于 &lt;code>alpha&lt;/code> 阶段，因此需要在&lt;a href="k3d%20cluster%20create%20test%20--k3s-arg%20%22--kube-apiserver-arg=feature-gates=EphemeralContainers=true%22@">“feature gate”&lt;/a>中打开。&lt;/p>
&lt;p>在使用 k3d 创建 k3s 集群时，打开 &lt;code>EphemeralContainers&lt;/code> feature：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ k3d cluster create &lt;span class="nb">test&lt;/span> --k3s-arg &lt;span class="s2">&amp;#34;--kube-apiserver-arg=feature-gates=EphemeralContainers=true&amp;#34;&lt;/span>@
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后创建临时容器，创建完成后会直接进入容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl debug golang-distroless-85c4896c45-rkjwn -it --image&lt;span class="o">=&lt;/span>ubuntu --image-pull-policy&lt;span class="o">=&lt;/span>IfNotPresent
&lt;span class="c1">#临时容器 shell&lt;/span>
$ apt update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt install -y curl
$ curl localhost:8080
Hello world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/11/02/20211102110330.png" alt="临时容器">&lt;/p>
&lt;p>值得注意的是，临时容器无法与原容器共享进程命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ps -ef
UID PID PPID C STIME TTY TIME CMD
root &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 02:59 pts/0 00:00:00 bash
root &lt;span class="m">3042&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> 03:02 pts/0 00:00:00 ps -ef
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以通过添加参数 &lt;code>--target=[container]&lt;/code> 来将临时容器挂接到目标容器。这里与 &lt;code>pod.spec.shareProcessNamespace&lt;/code> 并不同，&lt;strong>进程号为 1 的进程是目标容器的进程&lt;/strong>，而后者的进程是 infra 容器的进程 &lt;code>/pause&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl debug golang-distroless-85c4896c45-rkjwn -it --image&lt;span class="o">=&lt;/span>ubuntu --image-pull-policy&lt;span class="o">=&lt;/span>IfNotPresent --target&lt;span class="o">=&lt;/span>golang-distroless-example
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：目前的版本还不支持删除临时容器，参考 &lt;a href="https://github.com/kubernetes/kubernetes/issues/84764#issuecomment-872839644">issue&lt;/a>，支持的版本：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/11/02/20211102111319.png" alt="">&lt;/p>
&lt;h4 id="32-拷贝-pod-并添加容器">3.2 拷贝 Pod 并添加容器&lt;/h4>
&lt;p>除了添加临时容器以外，另一种方式就是创建一个 Pod 的拷贝，并添加一个容器。&lt;strong>注意这里的是普通容器，不是临时容器。&lt;/strong> 注意这里加上了 &lt;code>--share-processes&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl debug golang-distroless-85c4896c45-rkjwn -it --image&lt;span class="o">=&lt;/span>ubuntu --image-pull-policy&lt;span class="o">=&lt;/span>IfNotPresent --share-processes --copy-to&lt;span class="o">=&lt;/span>golang-distroless-debug
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意这里加上了 &lt;code>--share-processes&lt;/code>，会自动加上 &lt;code>pod.spec.shareProcessNamespace=true&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get po golang-distroless-debug -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.spec.shareProcessNamespace}&amp;#39;&lt;/span>
&lt;span class="nb">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：使用 &lt;code>kubectl debug&lt;/code> 调试，并不能为 pod 自动加上 &lt;code>SYS_PTRACE&lt;/code> 安全特性，这就意味着如果容器使用的 UID 不一致，就无法访问进程空间。&lt;/strong> 截止发文，&lt;a href="https://github.com/kubernetes/kubernetes/issues/97103#issuecomment-899382147">计划在 &lt;code>1.23&lt;/code> 中支持&lt;/a>。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>目前上面所有的都不适合在生产环境使用，无法在不修改 Pod 定义的情况下进行调试。&lt;/p>
&lt;p>期望 Kubernetes 1.23 版本之后 &lt;code>debug&lt;/code> 功能添加 &lt;code>SYS_PTRACE&lt;/code> 的支持。到时候，再尝试一下。&lt;/p></description></item><item><title>极狐GitLab SaaS 内测轻度体验</title><link>https://atbug.com/jihu-gitlab-experience/</link><pubDate>Fri, 01 Oct 2021 08:18:09 +0800</pubDate><guid>https://atbug.com/jihu-gitlab-experience/</guid><description>
&lt;p>感谢极狐团队为 &lt;a href="https://gitlab.cn/">GitLab（SaaS）&lt;/a>本地化的努力，同时也感谢小马哥提供的内测资格。&lt;/p>
&lt;p>最近突然想到了个点子，需要使用一个私有的镜像仓库。极狐GitLab 有提供容器镜像库，正好和 CICD 一起做个轻度体验。&lt;/p>
&lt;h2 id="容器镜像库-container-registry">容器镜像库 Container Registry&lt;/h2>
&lt;p>文档介绍在&lt;a href="https://gitlab.cn/help/user/packages/container_registry/index">这里&lt;/a>，目前还是英文。（应该本地化的工作量很大，文档还没翻译。）&lt;/p>
&lt;p>容器镜像库可以作为独立镜像仓库使用（为什么要这么用，卖个关子下篇文章见），就是使用 docker 命令将构建好的镜像推送到 容器镜像库。&lt;/p>
&lt;p>当然也可以同 CICD 流水线结合使用，后文也会介绍。&lt;/p>
&lt;h3 id="独立使用">独立使用&lt;/h3>
&lt;p>本地登录 Container Registry 有两种验证方式：&lt;/p>
&lt;ul>
&lt;li>使用用户名和密码&lt;/li>
&lt;li>开启了&lt;a href="https://gitlab.cn/help/user/profile/account/two_factor_authentication">双重身份验证&lt;/a>，可以使用访问&lt;a href="https://gitlab.cn/help/user/profile/personal_access_tokens">个人访问令牌&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>其实，不管是否开始双重验证，都建议使用访问令牌。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker login registry.gitlab.cn
&lt;span class="c1">#根据提示输入用户名和密码或者令牌&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>image 的名字&lt;a href="https://docs.gitlab.com/ee/user/packages/container_registry/#image-naming-convention">最多有三层&lt;/a>，即 &lt;code>registry.example.com/[namespace]&lt;/code> 之后的内容最多有 3 层。比如下面的 image 名字 &lt;code>myproject/my/image&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">registry.example.com/mynamespace/myproject/my/image:rc1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其次 image 名字的第一层必须是镜像名，如上面的 &lt;code>myproject&lt;/code>。&lt;/p>
&lt;p>尝试将 tekton 的镜像推送上去：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker tag gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/controller:v0.28.1 registry.gitlab.cn/addozhang/registry-mirror/tekton-pipeline/controller:v0.28.1
docker push registry.gitlab.cn/addozhang/registry-mirror/tekton-pipeline/controller:v0.28.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/01/20211001070532.png" alt="">&lt;/p>
&lt;p>&lt;strong>请忽略发布时间，原镜像的 &lt;code>Created&lt;/code> 字段就有问题。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/01/20211001070622.png" alt="">&lt;/p>
&lt;p>同样可以使用 REST API 进行访问：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl --location --request GET &lt;span class="s1">&amp;#39;https://gitlab.cn/api/v4/projects/addozhang%2Fregistry-mirror/registry/repositories/155/tags&amp;#39;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--header &lt;span class="s1">&amp;#39;PRIVATE-TOKEN: TOKEN_HERE&amp;#39;&lt;/span>
&lt;span class="o">[{&lt;/span>&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;v0.28.1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;path&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;addozhang/registry-mirror/tekton-pipeline/controller:v0.28.1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;location&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;registry.gitlab.cn/addozhang/registry-mirror/tekton-pipeline/controller:v0.28.1&amp;#34;&lt;/span>&lt;span class="o">}]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-cicd-构建和推送">使用 CICD 构建和推送&lt;/h2>
&lt;p>见下文。&lt;/p>
&lt;h2 id="cicd">CICD&lt;/h2>
&lt;p>我将之前 github 的使用的测试 tekton 的项目镜像到了&lt;a href="https://gitlab.cn/addozhang/tekton-test">这里&lt;/a>，并添加了一个 &lt;code>.gitlab-ci.yml&lt;/code> 的&lt;a href="https://gitlab.cn/addozhang/tekton-test/-/blob/main/.gitlab-ci.yml">流水线定义文件&lt;/a>。&lt;/p>
&lt;p>有了&lt;a href="https://gitlab.cn/help/ci/yaml/index.md">官方的文档&lt;/a>，以及参考&lt;a href="https://gitlab.com/gitlab-org/gitlab-foss/-/tree/master/lib/gitlab/ci/templates">官方提供各种的模板&lt;/a>，流水线的定义上手很快。&lt;/p>
&lt;p>整个流水线包含了两个 stage：Java 代码的编译打包和镜像的构建。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/01/20211001063858.png" alt="2021-10-01-06-38-58">&lt;/p>
&lt;p>如上图，最新的一次使用了 &lt;a href="https://gitlab.cn/help/ci/yaml/index.md%23cache">&lt;code>cache&lt;/code> 功能&lt;/a>将 &lt;code>.m2/repository&lt;/code> 缓存；而前两次使用了缓存（这里的构建耗时差异很大，不知道是不是因为晚上资源比较少？）。Java 项目会将依赖包保存在本地库中，使用 &lt;code>cache&lt;/code> 功能可以提升构建的效率。&lt;/p>
&lt;h3 id="流水线-dag">流水线 DAG&lt;/h3>
&lt;p>使用 &lt;code>needs&lt;/code> 可以控制同 stage 下作业的构建顺序，否则同 stage 下作业的执行是并行的。同时有了 &lt;code>needs&lt;/code> 还可以构建出 DAG，前提是最少需要 3 个作业，因此我又加了一个作业。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">cache&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">.m2/repository&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">variables&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">MAVEN_OPTS&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-Dhttps.protocols=TLSv1.2 -Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=WARN -Dorg.slf4j.simpleLogger.showDateTime=true -Djava.awt.headless=true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">stages&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">image&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">post-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">maven-build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maven:3-jdk-8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">artifacts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">target/*.jar&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">mvn install -DskipTests&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">docker-build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker:19.03.12&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">image&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">needs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">maven-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dependencies&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">maven-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">docker:19.03.12-dind&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">variables&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">IMAGE_TAG&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">$CI_REGISTRY_IMAGE:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">docker build -t $IMAGE_TAG .&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">docker push $IMAGE_TAG&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">done&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">post-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">needs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">docker-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">echo &amp;#34;All Done!&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>感觉图有点简陋，后期应该会优化。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/01/20211001072045.png" alt="">&lt;/p>
&lt;h3 id="作业依赖">作业依赖&lt;/h3>
&lt;p>前面的流水线定义中，为了传递 maven 构建的 jar，使用了 &lt;code>artifacts&lt;/code> 和 &lt;code>dependencies&lt;/code> 进行了传递。&lt;/p>
&lt;p>难道是我理解错了？鼠标悬停并没有显示做依赖的作业。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/01/20211001072018.png" alt="">&lt;/p>
&lt;h3 id="流水线触发">流水线触发&lt;/h3>
&lt;p>除了 push 代码触发，还可以创建触发器通过 Web API 进行触发。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -X POST &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -F &lt;span class="nv">token&lt;/span>&lt;span class="o">=&lt;/span>TOKEN_HERE &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -F &lt;span class="nv">ref&lt;/span>&lt;span class="o">=&lt;/span>main &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> https://gitlab.cn/api/v4/projects/9766/trigger/pipeline
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;id&amp;#34;&lt;/span>:19252,&lt;span class="s2">&amp;#34;project_id&amp;#34;&lt;/span>:9766,&lt;span class="s2">&amp;#34;sha&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;5dde144d584b76fe6d3b63a4a9beb789762d1a2d&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;ref&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;main&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;status&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;created&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;created_at&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;2021-10-01T07:37:42.806+08:00&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;updated_at&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;2021-10-01T07:37:42.806+08:00&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;web_url&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;https://gitlab.cn/addozhang/tekton-test/-/pipelines/19252&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;before_sha&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;0000000000000000000000000000000000000000&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;tag&amp;#34;&lt;/span>:false,&lt;span class="s2">&amp;#34;yaml_errors&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;user&amp;#34;&lt;/span>:&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;id&amp;#34;&lt;/span>:432,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;addozhang&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;username&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;addozhang&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;state&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;active&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;avatar_url&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;web_url&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;https://gitlab.cn/addozhang&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span>,&lt;span class="s2">&amp;#34;started_at&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;finished_at&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;committed_at&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;duration&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;queued_duration&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;coverage&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;detailed_status&amp;#34;&lt;/span>:&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;icon&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;status_created&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;text&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;created&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;label&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;created&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;group&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;created&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;tooltip&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;created&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;has_details&amp;#34;&lt;/span>:true,&lt;span class="s2">&amp;#34;details_path&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;/addozhang/tekton-test/-/pipelines/19252&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;illustration&amp;#34;&lt;/span>:null,&lt;span class="s2">&amp;#34;favicon&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;/assets/ci_favicons/favicon_status_created-4b975aa976d24e5a3ea7cd9a5713e6ce2cd9afd08b910415e96675de35f64955.png&amp;#34;&lt;/span>&lt;span class="o">}}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>由于之前任职的公司内部也有用 Gitlab，也有过 Github Action 和 Tektoncd 的使用经验，所以体验下来并还没有任何阻碍。这也得益于文档的完善，以及极狐团队的努力，希望极狐可以做得更好。&lt;/p>
&lt;p>文中使用 &lt;code>registry-mirror&lt;/code> 做了仓库名，大家也能猜到点什么，敬请关注一下篇。&lt;/p></description></item></channel></rss>