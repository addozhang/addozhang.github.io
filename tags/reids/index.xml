<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>reids on 乱世浮生</title><link>https://atbug.com/tags/reids/</link><description>Recent content in reids on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 13 Dec 2016 16:54:41 +0000</lastBuildDate><atom:link href="https://atbug.com/tags/reids/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis清理缓存</title><link>https://atbug.com/clean-speicified-keys-in-redis/</link><pubDate>Tue, 13 Dec 2016 16:54:41 +0000</pubDate><guid>https://atbug.com/clean-speicified-keys-in-redis/</guid><description>
最近有个需求需要主动的去清理部分缓存，考虑的原子性的问题，用Lua脚本进行实现。 Lua脚本 local count = 0 for _,k in ipairs(redis.call(&amp;#39;KEYS&amp;#39;, ARGV[1])) do redis.call(&amp;#39;DEL&amp;#39;, k) count = count + 1 end return count shell运行 redis-cli --eval file.lua ,[KEY PATTERN] #sample: 清理所有key以Test开头的记录 redis-cli --eval clear.lua , Test* Java Jedis jedis = new Jedis(&amp;#34;127.0.0.1&amp;#34;, 6379); URL resource = Resources.getResource(&amp;#34;META-INF/scripts/clear.lua&amp;#34;); String lua = Resources.toString(resource, Charsets.UTF_8); Object eval = jedis.eval(lua, 0, &amp;#34;Name*&amp;#34;); System.out.println(eval);</description></item></channel></rss>