<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Container on 乱世浮生</title><link>https://atbug.com/tags/container/</link><description>Recent content in Container on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 17 Dec 2021 09:13:59 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/container/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenFaaS - 以自己的方式运行容器化函数</title><link>https://atbug.com/openfaas-case-study-zh/</link><pubDate>Fri, 17 Dec 2021 09:13:59 +0800</pubDate><guid>https://atbug.com/openfaas-case-study-zh/</guid><description>
&lt;p>&lt;strong>译者注：&lt;/strong>
本文篇幅较长，有助于了解 FaaS 和 OpenFaaS。作者分别从开发人员和运维人员的视角来了解 OpenFaaS，对了解新的技术是个很好的方式。&lt;/p>
&lt;p>本文翻译自 &lt;a href="https://twitter.com/iximiuz">Ivan Velichko&lt;/a> 的 &lt;a href="https://iximiuz.com/en/posts/openfaas-case-study/">OpenFaaS - Run Containerized Functions On Your Own Terms&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>长期以来，&lt;em>无服务器（serverless）&lt;/em> 对我来说无非就是 AWS Lambda 的代名词。Lambda 提供了一种方便的途径，可以将任意代码附加到平台事件（云实例的状态变更、DynamoDB 记录的更新或新的 SNS 消息）中。但是，我时不时会想到某个逻辑，但其又没大到足以有自己的服务，同时有不适合任何现有服务的范围。因此，我经常将其放入函数中，以便日后使用 CLI 命令或者 HTTP 调用来调用它。&lt;/p>
&lt;p>几年前，我来开了 AWS，自那以后，我一直怀念部署无服务器功能的便利性。因此，当我得知 &lt;a href="https://www.openfaas.com">OpenFaaS&lt;/a>
项目时惊喜万分。它将在 Kubernetes 集群上部署函数变得简单，甚至仅需要 Containerd 就可以部署到虚拟机上。&lt;/p>
&lt;p>有兴趣？那么继续！&lt;/p>
&lt;h2 id="无服务器与-faas">无服务器与 FaaS&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Serverless_computing">无服务器&lt;/a> 已成为一个流行词，目前其实际含义扔不够清晰。&lt;/p>
&lt;p>许多现代平台被视为 &lt;em>无服务器&lt;/em> 平台。在 AWS Fargate 或 GCP Cloud Run 上部署容器化服务？无服务器！在 Heroku 上运行应用程序？也可能是无服务器的。&lt;/p>
&lt;p>同时，我更喜欢将 &lt;a href="https://en.wikipedia.org/wiki/Function_as_a_service">FaaS&lt;/a> 视为一种具体的设计模式。按照 FaaS 范式，可以部署代码片段（响应某些外部时间执行的&lt;em>函数&lt;/em>）。这些函数与事件驱动程序中的回调类似，但是是运行在其他人的的服务器上。由于操作的是函数而不是服务器，顾名思义 FaaS 是无服务器的。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/20211217-at-001929.png" alt="">
&lt;em>&lt;a href="https://twitter.com/iximiuz/status/1465273596033609736?ref_src=twsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1465273596033609736%257Ctwgr%255E%257Ctwcon%255Es1_&amp;amp;ref_url=https%253A%252F%252Fiximiuz.com%252Fen%252Fposts%252Fopenfaas-case-study%252F">source&lt;/a>&lt;/em>&lt;/p>
&lt;p>&lt;strong>OpenFaaS 项目旨在将 Kubernetes 集群或者独立的虚拟机等低级基础设施转化为管理无服务器函数的高级平台。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>站在开发人员的角度&lt;/strong>，这样一个平台看起来是真的无服务器的 &amp;ndash; 你只需要知道特定的 CLI/UI/API 来处理 &lt;em>函数&lt;/em> 抽象。但&lt;strong>站在运维的角度&lt;/strong>，需要了解 OpenFaaS 如何使用 &lt;em>服务器&lt;/em> 来运行这些函数。&lt;/p>
&lt;p>就我而言，我经常既是开发又是运维，下面我将尝试从二者展开说明。然而，我认为在评估 UX 时，我们应该明确区分它们。&lt;/p>
&lt;h2 id="开发人员眼中的-openfaas">开发人员眼中的 OpenFaaS&lt;/h2>
&lt;p>OpenFaaS 创建于 2016 年，现在网上也有大量的教程。这里不会重复介绍，但可以通过以下链接了解：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.openfaas.com/deployment/">How to deploy OpenFaaS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/cli/templates/">Create Functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/cli/build/">Build Functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/cli/templates/#nodejs-12-node12-of-watchdog-template">Writing a Node.js function - step-by-step guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>相反，我将描述我所理解的 OpenFaaS。我希望有助于一些需要评估该技术是否解决其问题的人，以及那些希望更有效地使用该技术的人。&lt;/p>
&lt;h3 id="函数运行时">函数运行时&lt;/h3>
&lt;p>在进入正式编码之前，有必要了解下其未来的执行环境（又名运行时）。或者，简单说：&lt;/p>
&lt;ul>
&lt;li>如何启动函数&lt;/li>
&lt;li>如何组织 I/O 操作&lt;/li>
&lt;li>如何重置 / 终止函数&lt;/li>
&lt;li>如何隔离函数和调用&lt;/li>
&lt;/ul>
&lt;p>OpenFaaS 自带多个运行时模式，这些模式针对不同的场景定制。因此，不同的场景下上述问题的答案会略有不同。&lt;/p>
&lt;p>&lt;strong>OpenFaaS 函数在容器中运行&lt;/strong>，并且每个容器必须遵守&lt;a href="https://docs.openfaas.com/reference/workloads/">简单的约定&lt;/a> ：它作为监听在预设端口（默认为 &lt;em>8080&lt;/em>）上的 HTTP 服务器，临时存储并且是无状态的。&lt;/p>
&lt;p>然而，OpenFaaS 通过 &lt;em>函数 watchdog&lt;/em>（译者注：watchdog 不做翻译）模式避免了用户编写此类服务器。&lt;em>函数 watchdog&lt;/em> 是一种轻量级 HTTP 服务器，可以感知如何执行实际函数业务逻辑。因此，安装在容器中的所有内容加上作为入口点的 watchdog，就构成了函数的运行时环境。&lt;/p>
&lt;h4 id="经典-watchdog">经典 watchdog&lt;/h4>
&lt;p>从&lt;strong>最简单&lt;/strong>的开始，或者又是被称为&lt;a href="https://github.com/openfaas/classic-watchdog">&lt;em>经典&lt;/em> watchdog&lt;/a>：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396730767429.png" alt="">&lt;/p>
&lt;p>这种模式下，watchdog 启动了监听在 &lt;em>8080&lt;/em> 端口的轻量级 HTTP 服务器，每个进来的请求都会：&lt;/p>
&lt;ul>
&lt;li>读取请求头和请求体&lt;/li>
&lt;li>fork 或者 exec 包含实际函数的可执行文件&lt;/li>
&lt;li>将请求头和请求体写入到函数进程的 &lt;em>stdin&lt;/em>&lt;/li>
&lt;li>等待函数进程的退出（或者超市）&lt;/li>
&lt;li>读取函数进程的 &lt;em>stdout&lt;/em> 和 &lt;em>stderr&lt;/em>&lt;/li>
&lt;li>在 HTTP 响应中将去读的字节发送回调用方&lt;/li>
&lt;/ul>
&lt;p>上述逻辑类似于传统的 &lt;a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">通用网关接口（CGI）&lt;/a>。一方面，每次函数调用都启动单独的进程看起来不够高效，而另一方面，它确实超级方便，因为 &lt;strong>任何使用 &lt;em>stdio&lt;/em> 流进行 I/O 处理的程序（包括最喜欢的 CLI 工具）都可以部署为 OpenFaaS 函数&lt;/strong>。&lt;/p>
&lt;p>提起&lt;strong>隔离&lt;/strong>，我们有必要区分下&lt;em>函数&lt;/em>和&lt;em>调用&lt;/em>：&lt;/p>
&lt;ul>
&lt;li>OpenFaaS 中的不同函数始终分布在不同的容器中&lt;/li>
&lt;li>一个函数可以有一个或多个容器 —— 取决于缩放选项&lt;/li>
&lt;li>同一函数的独立调用可能会最终进入同一个容器&lt;/li>
&lt;li>同一函数的独立调用将始终使用不同的进程进行&lt;/li>
&lt;/ul>
&lt;h4 id="反向代理-watchdog">反向代理 watchdog&lt;/h4>
&lt;p>&lt;em>注意：使用 OpenFaaS 官方术语，本节讨论在 HTTP 模式下运行的 &lt;a href="https://github.com/openfaas/of-watchdog">of-watchdog&lt;/a>。但我个人认为称之为反向代理 watchdog 更加形象。&lt;/em>&lt;/p>
&lt;p>如果 &lt;strong>经典&lt;/strong> 运行时类似于 CGI，那么这个运行时模式类似于后来的 &lt;a href="https://en.wikipedia.org/wiki/FastCGI">FastCGI&lt;/a>。运行时希望在 watchdog 后面有一个长期运行的 HTTP 服务器，而不是每次函数调用时创建新的进程。这本质上是 &lt;a href="https://github.com/openfaas/of-watchdog/blob/a0289419078824f0a070860f84a6b383eb4f2169/README.md#1-http-modehttp">将 watchdog 组件变成反向代理&lt;/a>：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396740301372.png" alt="">&lt;/p>
&lt;p>当容器启动时，&lt;strong>反向代理&lt;/strong> watchdog 也会创建一个监听在 &lt;em>8080&lt;/em> 端口的轻量级 HTTP 服务器。然而，与 &lt;strong>经典&lt;/strong> watchdog 不同的是&lt;strong>反向代理&lt;/strong>watchdog 只创建一次函数的进程，并将其当成（长期运行的）上游服务器。然后，函数调用转变成到该上游的 HTTP 请求。&lt;/p>
&lt;p>然而，&lt;strong>反向代理&lt;/strong>模式并不为了取代&lt;strong>经典&lt;/strong>模式。&lt;strong>经典&lt;/strong>模式的强项在于其函数的编写非常简单。这也是没有 HTTP 服务器的代码的唯一选择。比如使用 Cobol、bash 或者 PowerShell 脚本等等编写的函数。&lt;/p>
&lt;p>何时该使用&lt;strong>反向代理&lt;/strong>运行时模式：&lt;/p>
&lt;ul>
&lt;li>函数需要在两次调用之间保持状态：
&lt;ul>
&lt;li>缓存&lt;/li>
&lt;li>持久连接（例如，保持从函数到数据库的连接打开）&lt;/li>
&lt;li>有状态函数 🥴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个函数启动一个进程可能开销很大，为每个调用带来了延迟&lt;/li>
&lt;li>你想运行一个（微）服务作为函数 🤔&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>根据 OpenFaaS 的创建者 &lt;a href="https://twitter.com/alexellisuk">Alex Ellis&lt;/a> 的解释，&lt;em>FaaS&lt;/em>，特别是 OpenFaaS，可以被视为在不依赖服务器抽象的情况下 &lt;a href="https://blog.alexellis.io/introducing-functions-as-a-service/">部署微服务的简化方式&lt;/a>。即 FaaS 是无服务器架构的规范示例。&lt;/p>
&lt;/blockquote>
&lt;p>因此，使用反向代理的方式，函数可以被看作是部署微服务的固执的方式。方便、快速、简单。但使用有状态函数时，要留意由于多个调用可能在同一个进程中结束而导致的警告：&lt;/p>
&lt;ul>
&lt;li>在一个进程中结束的并发调用可能会触发代码中的竞争条件（例如，一个带有全局变量的 Go 函数，而全局变量没有锁的保护）。&lt;/li>
&lt;li>在一个进程中结束的后续调用可能会导致交叉调用数据泄露（当然，就像传统微服务一样）。&lt;/li>
&lt;li>由于该进程在两次调用之间被复用，因此代码中的任何内存泄漏都不会被缓解。&lt;/li>
&lt;/ul>
&lt;h4 id="其他运行时模式">其他运行时模式&lt;/h4>
&lt;p>&lt;strong>经典&lt;strong>运行时模式在将函数结果发送回调用方之前缓冲了函数的整个响应。但如果响应的大小超出了容器的内存怎么办？OpenFaaS 提供了&lt;/strong>响应流&lt;/strong>&lt;a href="https://github.com/openfaas/of-watchdog/blob/a0289419078824f0a070860f84a6b383eb4f2169/README.md#3-streaming-fork-modestreaming---default">另一种运行时模式，该模式仍然为每个调用创建进程，但添加了&lt;/a>。&lt;/p>
&lt;p>另一个又去的场景是从函数中提供静态文件服务。&lt;a href="https://github.com/openfaas/of-watchdog/blob/a0289419078824f0a070860f84a6b383eb4f2169/README.md#4-static-modestatic">OpenFaaS 也有解决方案&lt;/a>。&lt;/p>
&lt;p>这可能是所有的内置运行时模式。但如果仍未满足需求，OpenFaaS 是一个开源项目！看下现有的watchdog（&lt;a href="https://github.com/openfaas/classic-watchdog">1&lt;/a> &amp;amp; &lt;a href="https://github.com/openfaas/of-watchdog">2&lt;/a>），简洁明了。因此，可以随时提交 PR 或者 issue，让整个社区因你的贡献收益。&lt;/p>
&lt;h3 id="编写函数">编写函数&lt;/h3>
&lt;p>此时，我们已经了解函数如何在配备了函数 watchdog 的容器中运行。那么最小的函数是什么样子的？&lt;/p>
&lt;p>下面的示例将简单的 shell 脚本封装到 OpenFaaS 函数中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># WARNING: Not for Production - No Security Hardening! #&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># This FROM is just to get the watchdog executable.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> ghcr.io/openfaas/classic-watchdog:0.2.0 as watchdog&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># FROM this line the actual runtime definion starts.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> alpine:latest&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Mandatory step - put the watchdog.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>watchdog /fwatchdog /usr/bin/fwatchdog&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Optionally - install extra packages, libs, tools, etc.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Function&amp;#39;s payload - script echoing its STDIN, a bit transformed.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;#!/bin/sh&amp;#39;&lt;/span> &amp;gt; /echo.sh&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;cat | rev | tr &amp;#34;[:lower:]&amp;#34; &amp;#34;[:upper:]&amp;#34;&amp;#39;&lt;/span> &amp;gt;&amp;gt; /echo.sh&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> chmod +x /echo.sh&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Point the watchdog to the actual thingy to run.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">fprocess&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/echo.sh&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Start the watchdog server.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;fwatchdog&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当构建、部署和调用时，上面的函数作为 &lt;em>回显服务器&lt;/em>，倒转并大写其输入。&lt;/p>
&lt;p>稍微高级点的例子：一个 Node.js &lt;em>Hello World&lt;/em> 脚本作为函数：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># WARNING: Not for Production - No Security Hardening! #&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> ghcr.io/openfaas/classic-watchdog:0.2.0 as watchdog&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> node:17-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>watchdog /fwatchdog /usr/bin/fwatchdog&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;console.log(&amp;#34;Hello World!&amp;#34;)&amp;#39;&lt;/span> &amp;gt; index.js&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">fprocess&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node index.js&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;fwatchdog&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此，要编写一个简单的函数，只需要在 Dockerfile 中加入：&lt;/p>
&lt;ul>
&lt;li>实际脚本（或可执行文件）&lt;/li>
&lt;li>它的所有依赖项——软件包、操作系统库等&lt;/li>
&lt;li>首选的 watchdog&lt;/li>
&lt;/ul>
&lt;p>然后将 watchdog 指向该脚本（或可执行文件），并将 watchdog 作为入口。有点酷，因为：&lt;/p>
&lt;ul>
&lt;li>可以完全控制函数未来的运行时&lt;/li>
&lt;li>可以部署任何可以在容器中作为函数运行的东西&lt;/li>
&lt;/ul>
&lt;p>但上述方法有个明显的缺点 &amp;ndash; 一个生产就绪的 Dockerfile 可能有上百行。如果我只想运行一个简单的 Node.js/Python 脚本或者一个小的 Go 程序作为函数，要怎么处理 Dockerfile？就不能有一个占位符来粘贴代码片段？&lt;/p>
&lt;h4 id="功能模板">功能模板&lt;/h4>
&lt;p>OpenFaaS 的美妙之处在于，我们可以两者兼而有之 —— 使用 Dockerfile 进行低级修补或目标语言编写高级脚本！得益于丰富的功能模板库！&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ faas-cli template store list
NAME SOURCE DESCRIPTION
csharp openfaas Classic C# template
dockerfile openfaas Classic Dockerfile template
go openfaas Classic Golang template
java8 openfaas Java &lt;span class="m">8&lt;/span> template
...
node14 openfaas HTTP-based Node &lt;span class="m">14&lt;/span> template
node12 openfaas HTTP-based Node &lt;span class="m">12&lt;/span> template
node openfaas Classic NodeJS &lt;span class="m">8&lt;/span> template
php7 openfaas Classic PHP &lt;span class="m">7&lt;/span> template
python openfaas Classic Python 2.7 template
python3 openfaas Classic Python 3.6 template
...
python3-flask openfaas Python 3.7 Flask template
python3-http openfaas Python 3.7 with Flask and HTTP
...
golang-http openfaas Golang HTTP template
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述功能模板由 OpenFaaS 作者和社区精心只做。典型的模板附带一个复杂的 Dockerfile，指向虚拟处理程序函数。当引导新函数时，通过 &lt;code>faas-cli new&lt;/code> 命令来使用这些模板。例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ faas-cli new --lang python my-fn
Folder: my-fn created.
Function created in folder: my-fn
Stack file written: my-fn.yml
$ cat my-fn/handler.py
def handle&lt;span class="o">(&lt;/span>req&lt;span class="o">)&lt;/span>:
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34; PUT YOUR BUSINESS LOGIC HERE &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">return&lt;/span> req
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此，对于模板，编写函数的工作可以归结为简单地将业务逻辑放入响应的处理程序文件中。&lt;/p>
&lt;p>使用模板时，了解使用那种 &lt;em>watchdog&lt;/em> 和 &lt;em>模式&lt;/em> 很重要：&lt;/p>
&lt;ul>
&lt;li>使用&lt;strong>经典的&lt;/strong>类似 CGI 的 watchdog，处理程序通常被编写为接受和返回纯字符串的函数（例如：&lt;a href="https://github.com/openfaas/templates/blob/d8893afe3d1072840174911859c6f5db2986e814/template/python3/function/handler.py">python3&lt;/a>、&lt;a href="https://github.com/openfaas/templates/blob/d8893afe3d1072840174911859c6f5db2986e814/template/php7/function/src/Handler.php">php7&lt;/a>）&lt;/li>
&lt;li>在 &lt;strong>HTTP 模式下&lt;/strong>，使用 &lt;strong>of-watchdog&lt;/strong>时，处理程序看起来更像 HTTP 处理程序接受请求并返回响应结构（例如：&lt;a href="https://github.com/openfaas/python-flask-template/blob/12db680950b42c7cfcc7d21ba036bd1397d62eb7/template/python3-http/function/handler.py">python3-http&lt;/a>，&lt;a href="https://github.com/openfaas/templates/blob/d8893afe3d1072840174911859c6f5db2986e814/template/node17/function/handler.js">node17&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h4 id="函数商店">函数商店&lt;/h4>
&lt;p>你的最佳函数是什么？对，你不需要写。OpenFaaS 接受这种想法，并带来了&lt;a href="https://github.com/openfaas/store">函数商店&lt;/a>（经过社区测试并根据过往经验选择的 OpenFaaS 函数精选索引）。&lt;/p>
&lt;p>该商店包含一些有趣的函数，可以一键部署到现有的 OpenFaaS 中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ faas-cli store list
FUNCTION DESCRIPTION
NodeInfo Get info about the machine that you&lt;span class="s1">&amp;#39;r...
&lt;/span>&lt;span class="s1">alpine An Alpine Linux shell, set the &amp;#34;fproc...
&lt;/span>&lt;span class="s1">env Print the environment variables prese...
&lt;/span>&lt;span class="s1">sleep Simulate a 2s duration or pass an X-S...
&lt;/span>&lt;span class="s1">shasum Generate a shasum for the given input
&lt;/span>&lt;span class="s1">Figlet Generate ASCII logos with the figlet CLI
&lt;/span>&lt;span class="s1">curl Use curl for network diagnostics, pas...
&lt;/span>&lt;span class="s1">SentimentAnalysis Python function provides a rating on ...
&lt;/span>&lt;span class="s1">hey HTTP load generator, ApacheBench (ab)...
&lt;/span>&lt;span class="s1">nslookup Query the nameserver for the IP addre...
&lt;/span>&lt;span class="s1">SSL/TLS cert info Returns SSL/TLS certificate informati...
&lt;/span>&lt;span class="s1">Colorization Turn black and white photos to color ...
&lt;/span>&lt;span class="s1">Inception This is a forked version of the work ...
&lt;/span>&lt;span class="s1">Have I Been Pwned The Have I Been Pwned function lets y...
&lt;/span>&lt;span class="s1">Face Detection with Pigo Detect faces in images using the Pigo...
&lt;/span>&lt;span class="s1">Tesseract OCR This function brings OCR - Optical Ch...
&lt;/span>&lt;span class="s1">Dockerhub Stats Golang function gives the count of re...
&lt;/span>&lt;span class="s1">QR Code Generator - Go QR Code generator using Go
&lt;/span>&lt;span class="s1">Nmap Security Scanner Tool for network discovery and securi...
&lt;/span>&lt;span class="s1">ASCII Cows Generate a random ASCII cow
&lt;/span>&lt;span class="s1">YouTube Video Downloader Download YouTube videos as a function
&lt;/span>&lt;span class="s1">OpenFaaS Text-to-Speech Generate an MP3 of text using Google&amp;#39;&lt;/span>...
Docker Image Manifest Query Query an image on the Docker Hub &lt;span class="k">for&lt;/span> ...
face-detect with OpenCV Detect faces in images. Send a URL as...
Face blur by Endre Simo Blur out faces detected in JPEGs. Inv...
Left-Pad left-pad on OpenFaaS
normalisecolor Automatically fix white-balance in ph...
mememachine Turn any image into a meme.
Business Strategy Generator Generates a Business Strategy &lt;span class="o">(&lt;/span>using ...
Image EXIF Reader Reads EXIF information from an URL or...
Open NSFW Model Score images &lt;span class="k">for&lt;/span> NSFW &lt;span class="o">(&lt;/span>nudity&lt;span class="o">)&lt;/span> content.
Identicon Generator Create an identicon from a provided s...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些函数实际上是存储在 Docker Hub 或者 Quay 等公共库的容器镜像，可以自由复用。&lt;/p>
&lt;p>场景示例：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>env&lt;/code> 函数调试函数接收的HTTP标头&lt;/li>
&lt;li>使用 &lt;code>curl&lt;/code> 函数从 OpenFaaS 部署内部测试连接&lt;/li>
&lt;li>从运行多个副本的函数中使用 &lt;code>hey&lt;/code> 来增加负载&lt;/li>
&lt;/ul>
&lt;h3 id="函数的构建和部署">函数的构建和部署&lt;/h3>
&lt;p>由于函数是在容器中运行的，因此需要有人为这些容器构建镜像。无论你喜不喜欢，这都是开发人员的事情。OpenFaaS 提供了方便的 &lt;code>faas-cli build&lt;/code> 命令，但没有服务器端构建。因此，要么需要（在安装 Docker 的机器上）手动运行 &lt;code>faas-cli build&lt;/code>，要么使用 CI/CD 完成。&lt;/p>
&lt;p>接下来，构建好的镜像需要通过 &lt;code>faas-cli push&lt;/code> 到仓库。显然，这种仓库也应该可以从 OpenFaaS 服务器端访问。否则，使 用&lt;code>faas-cli deploy&lt;/code> 部署函数时会失败。&lt;/p>
&lt;p>开发人员的工作流程如下：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396975427765.png" alt="">&lt;/p>
&lt;h3 id="调用函数">调用函数&lt;/h3>
&lt;p>函数部署后，可以通过向 &lt;code>$API_HOST:$API_PORT/function/&amp;lt;fn-name&amp;gt;&lt;/code> 端点发送 GET、POST、PUT 或者 DELET HTTP 请求来调用它。常见的调用方式有：&lt;/p>
&lt;ul>
&lt;li>各种钩子（webhook）&lt;/li>
&lt;li>&lt;code>faas-cli invoke&lt;/code>&lt;/li>
&lt;li>&lt;strong>event connectors&lt;/strong>！&lt;/li>
&lt;/ul>
&lt;p>前两个选项相当简单。使用函数作为作为 webhook 处理器（GitHub、IFTTT 等）很方便，每个函数开发人员都已经安装了 &lt;code>faas-cli&lt;/code>，因此可以成为日常脚本编写的组成部分。&lt;/p>
&lt;h4 id="那什么是事件连接器">那什么是事件连接器？&lt;/h4>
&lt;p>在本文开头是我对 AWS Lambda 与 AWS 平台事件紧密集成的温暖回忆。请记住，可以在响应新 SQS/SNS 消息、新的 Kinesis 记录、EC2 实例生命周期等事件时调用 Lambda。OpenFaaS 函数是否存在类似的东西呢？&lt;/p>
&lt;p>显然，OpenFaaS 无法开箱即用地与任何生态系统集成。然而，它提供了一种名为&lt;a href="https://docs.openfaas.com/reference/triggers/#event-connector-pattern">&lt;strong>事件连接器&lt;/strong>&lt;/a>模式的通用解决方案。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396992441046.png" alt="">&lt;/p>
&lt;p>官方支持的连接器：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/openfaas/cron-connector">Cron connector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openfaas/mqtt-connector">MQTT connector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openfaas/nats-connector">NATS connector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/reference/triggers/#apache-kafka-openfaas-pro">Kafka connector&lt;/a> (需要&lt;strong>专业版&lt;/strong>订阅)&lt;/li>
&lt;/ul>
&lt;p>OpenFaaS 还提供了很小的&lt;a href="https://github.com/openfaas/connector-sdk">&lt;strong>连接器-sdk&lt;/strong>&lt;/a>库来简化连接器的开发。&lt;/p>
&lt;h2 id="运维眼中的-openfaas">运维眼中的 OpenFaaS&lt;/h2>
&lt;p>开发眼中的 OpenFaaS 是个黑盒，提供简单的 API 来部署和调用函数。然而，作为运维可能会从了解 一点 OpenFaaS 内部原理中受益。&lt;/p>
&lt;h3 id="openfaas-通用架构">OpenFaaS 通用架构&lt;/h3>
&lt;p>OpenFaaS 有一个简单但强大的架构，允许使用不同的基础设施作为后端。如果已经有了 Kubernetes 集群，可以通过&lt;a href="https://docs.openfaas.com/deployment/kubernetes/">在上面部署 OpenFaaS&lt;/a> 轻松将其变成 &lt;a href="https://docs.openfaas.com/deployment/kubernetes/">FaaS&lt;/a> 解决方案。但是如果旧的虚拟（或物理）机，仍然可以在上面安装 OpenFaaS，并获得差不多功能的更小的 FaaS 解决方案。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396997846325.png" alt="">&lt;/p>
&lt;p>上面的架构中唯一面向用户的组件是 &lt;a href="https://github.com/openfaas/faas/tree/fe152ba69c591d584b1f183f9f5f209e29a9b049/gateway">API 网关&lt;/a>。OpenFaaS 的 API 网关：&lt;/p>
&lt;ul>
&lt;li>暴露 API 来管理和调用函数&lt;/li>
&lt;li>提供内置的 UI 来管理函数&lt;/li>
&lt;li>处理函数的自动缩放&lt;/li>
&lt;li>预计后面会有兼容的 OpenFaaS 提供商&lt;/li>
&lt;/ul>
&lt;p>因此，当开发人员运行 &lt;code>faas-cli deploy&lt;/code>、&lt;code>faas-cli list&lt;/code> 或使用 &lt;code>curl $API_URL/function/foobar&lt;/code> 调用函数等内容时，请求将发送到上述的 API 网关。&lt;/p>
&lt;p>上图中的另一个重要组成部分是  &lt;a href="https://github.com/openfaas/faas-provider">faas-provider&lt;/a>。它不是一个具体的组件，而更像是接口。任何实现&lt;a href="https://github.com/openfaas/faas-provider/blob/36474d89ca995ea0a7c064493258d9edec88fe3f/serve.go#L32-L96">（非常简洁）的提供商 API&lt;/a> 的软件都可以成为提供商。OpenFaaS 提供商：&lt;/p>
&lt;ul>
&lt;li>管理功能（部署、列表、缩放、删除）&lt;/li>
&lt;li>调用函数&lt;/li>
&lt;li>暴露一些系统信息&lt;/li>
&lt;/ul>
&lt;p>两个最注明的提供商是 &lt;a href="https://github.com/openfaas/faas-netes">faas-netes&lt;/a>（Kubernetes 上的 OpenFaaS）和 &lt;a href="https://github.com/openfaas/faasd">faasd&lt;/a>（Containerd 上的 OpenFaaS）。下面，将介绍他们的实现。&lt;/p>
&lt;h3 id="kubernetes-上的-openfaasfaas-nets">Kubernetes 上的 OpenFaaS（faas-nets）&lt;/h3>
&lt;p>&lt;a href="https://github.com/openfaas/faas-netes">当部署在 Kubernetes 上时&lt;/a>，OpenFaaS 利用了该平台开箱即用的强大原语。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16397005465805.png" alt="">&lt;/p>
&lt;p>关键要点：&lt;/p>
&lt;ul>
&lt;li>API 网关成为标准（部署+服务）对。因此，可以随心所欲地扩展它。也可以随心所欲地把它暴露出来&lt;/li>
&lt;li>每个函数也成为（部署+服务）对。可能不会直接处理函数，但对于 faas-netes，缩放变得就像调整相应的副本数一样简单&lt;/li>
&lt;li>高可用性和开箱即用的水平缩放 - 同一功能的 pod 可以（而且应该）跨多个集群节点运行。&lt;/li>
&lt;li>Kubernetes 作为一个数据库工作；例如，当运行 &lt;code>faas-cli list&lt;/code> 等命令来获取当前部署的函数列表时，faas-netes 只会将其转换为相应的 Kubernetes API 查询&lt;/li>
&lt;/ul>
&lt;h3 id="containerd-上的-openfaasfaasd">Containerd 上的 OpenFaaS（faasd）&lt;/h3>
&lt;p>对于没有使用 Kubernetes 集群的人来说，OpenFaaS 提供了名为 &lt;a href="https://github.com/openfaas/faasd">faasd&lt;/a> 的替代轻量级提供商。它可以安装在（虚拟或物理）服务器上，，并利用 &lt;a href="https://iximiuz.com/en/posts/containerd-command-line-clients/">containerd&lt;/a> 来管理容器。&lt;a href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#containerd">正如我之前写的那样&lt;/a>，容器是一个在 Docker 和 Kubernetes 下使用的较低级别的容器管理器。结合 &lt;a href="https://github.com/containernetworking/plugins">CNI 插件&lt;/a>，它成为编写容器调度器的构建组件，OpenFaaS 的 faasd 是个很好的讲究案例：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16397012181479.png" alt="">&lt;/p>
&lt;p>关键要点：&lt;/p>
&lt;ul>
&lt;li>被设计为在 IoT 设备上或 VM 中运行&lt;/li>
&lt;li>使用 containerd 的原生 &lt;code>pause&lt;/code> （通过&lt;em>cgroup freezers&lt;/em>）和超快速函数冷启动快速扩展到零&lt;/li>
&lt;li>&lt;a href="https://metal.equinix.com/proximity/?wchannelid=ujj9b20qi5&amp;amp;wmediaid=hkkw4b4o5n">它可以在每台服务器上运行比 faas-netes 多十倍的函数&lt;/a>，并且可以有效地使用更便宜的硬件，包括树莓派&lt;/li>
&lt;li>containerd 和 faasd 作为 systemd 服务进行管理，因此会自动处理日志、重启等&lt;/li>
&lt;li>没有 Kubernetes DNS，但 faasd 确保 DNS 在函数之间共享以简化互操作&lt;/li>
&lt;li>containerd 扮演着数据库的角色（比如 &lt;code>faas-cli list&lt;/code> 变成了类似 &lt;code>ctr container list&lt;/code>的操作 ），所以如果服务器挂了，所有状态就会丢失，每个函数都需要重新部署&lt;/li>
&lt;li>没有开箱即用的高可用性或水平扩展（参见 &lt;a href="https://github.com/openfaas/faasd/issues/225">issue/225&lt;/a>）&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>对你所使用的软件有个好的心智模型是是有益的，它可以提高开发效率，防止单例场景的发生，并简化了故障排查。&lt;/p>
&lt;p>以 OpenFaaS 为例，区分开发人员和运维人员对系统的看法可能是个很好的思路。从&lt;strong>开发人员角度来看&lt;/strong>，这是一个简单而强大的无服务器解决方案，主要关注 FaaS 场景。该解决方案由一个用于管理和调用函数的简洁 API、一个涵盖开发人员工作流的命令行工具以及一个函数模板库组成。无服务器函数以不同的运行时模式（类 CGI、反向代理）在容器中运行，并提供不同的隔离和状态保障。&lt;/p>
&lt;p>从&lt;strong>运维人员的角度来看&lt;/strong>，OpenFaaS 是一个具有灵活架构的模块化系统，可以部署在不同类型的基础设施之上：从树莓派到裸机或虚拟机、以及成熟的 Kubernetes、OpenShift 或 Docker Swarm 集群。当然，每种选择都有其优缺点，需要详细评估取舍。但即使现有选项都不合适，简单的 &lt;em>faas-provider&lt;/em> 抽象允许开发自己的后端来运行无服务器功能。&lt;/p>
&lt;p>上述内容主要集中在 OpenFaaS 基础知识上。但是 OpenFaaS 也有一些高级功能。通过以下链接进一步了解：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.openfaas.com/reference/async/">使用 NATS 消息传递系统的异步函数调用&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/architecture/autoscaling/">使用 Prometheus 和 AlertManager 自动缩放功能&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openfaas/faas-middleware/tree/ace4eb24749c0814850a56b23b0015232dd41c2a/concurrency-limiter">函数调用限制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openfaas.gumroad.com/l/serverless-for-everyone-else">使用 docker-compose 通过 faasd 运行有状态的工作负载&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="资源">资源&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.openfaas.com/">OpenFaaS 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.alexellis.io/deploy-serverless-faasd-with-cloud-init/">一堆清晰的 OpenFaaS 用例&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.alexellis.io/cli-functions-with-openfaas/">使用 OpenFaaS 将任何 CLI 转换为函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openfaas.com/blog/introducing-faasd/">faasd 介绍、动机、主要用例&lt;/a>&lt;/li>
&lt;li>📖&lt;a href="https://openfaas.gumroad.com/l/serverless-for-everyone-else">面向其他人的无服务器&lt;/a>- 尽管有通用名称，但它是 faasd 的一个非常详细的指南&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>作者介绍：
Ivan Velichko
Software Engineer at heart, SRE at day job, Tech Storyteller at night.&lt;/p>
&lt;/blockquote></description></item></channel></rss>