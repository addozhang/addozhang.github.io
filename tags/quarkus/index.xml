<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quarkus on 乱世浮生</title><link>https://atbug.com/tags/quarkus/</link><description>Recent content in Quarkus on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 26 May 2021 07:37:04 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/quarkus/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Quarkus 和 MicroProfile 实现微服务特性</title><link>https://atbug.com/microservicilities-quarkus/</link><pubDate>Wed, 26 May 2021 07:37:04 +0800</pubDate><guid>https://atbug.com/microservicilities-quarkus/</guid><description>
&lt;p>Quarkus 的文章之前写过三篇了，讲过了 Quarkus 的小而快。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/YcEqFm3oxlsEvJ3ckRbQyA">Hello, Quarkus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dq3hQrXE4XWH-MyjBAGMEw">应&amp;quot;云&amp;quot;而生的 Java 框架 Quarkus：构建本机可执行文件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/1eqjYC36O3qm1XDw84aAPA">谁说 Java 不能用来跑 Serverless？&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一直在酝酿写一篇 Quarkus 生态相关的，因为最近一直在忙 Meetup 的事情而搁浅。正好看到了这篇文章，就拿来翻译一下，补全云原生中的“微服务”这一块。&lt;/p>
&lt;p>本文译自&lt;a href="https://www.infoq.com/articles/microservicilities-quarkus">《Implementing Microservicilities with Quarkus and MicroProfile》&lt;/a> 。&lt;/p>
&lt;hr>
&lt;h2 id="为什么要使用微服务特性">为什么要使用微服务特性？&lt;/h2>
&lt;p>在微服务架构中，一个应用程序是由几个相互连接的服务组成的，这些服务一起工作来实现所需的业务功能。&lt;/p>
&lt;p>因此，典型的企业微服务架构如下所示：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855266680.jpg" alt="">&lt;/p>
&lt;p>刚开始，使用微服务架构实现应用程序看起来很容易。&lt;/p>
&lt;p>但是，因为有了单体架构没有一些新的挑战，因此做起来并不容器&lt;/p>
&lt;p>举几个例子，比如容错、服务发现、扩展性、日志记录和跟踪。&lt;/p>
&lt;p>为了解决这些挑战，每个微服务都应实现我们在 Red Hat 所说的“微服务特性”。&lt;/p>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 该术语是指除业务逻辑以外，服务还必须实现来解决的跨领域关注点清单，如下图所示：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855419604.jpg" alt="">&lt;/p>
&lt;p>可以用任何语言（Java、Go、JavaScript）或任何框架（Spring Boot、Quarkus）实现业务逻辑，但是围绕业务逻辑，应实现以下关注点：&lt;/p>
&lt;p>&lt;strong>API&lt;/strong>：可通过一组定义的 API 操作来访问该服务。例如，对于 RESTful Web API，HTTP 用作协议。此外，可以使用诸如 Swagger 之类的工具来记录 API 。
&lt;strong>服务发现（Discovery）&lt;/strong>：服务需要发现其他服务。&lt;/p>
&lt;p>&lt;strong>调用服务（Invocation）&lt;/strong>：发现服务后，需要使用一组参数对其进行调用，并选择性地返回响应。&lt;/p>
&lt;p>&lt;strong>弹性（Elasticity）&lt;/strong>：微服务架构的重要特征之一是每个服务都是弹性的，这意味着可以根据系统的关键程度或当前的工作量等参数独立地进行缩放。（译者注：这里的弹性只是资源的弹性）&lt;/p>
&lt;p>&lt;strong>弹性（Resiliency）&lt;/strong>：在微服务架构中，我们在开发时应牢记失败，尤其是在与其他服务进行通信时。在单体应用中，整个应用程序处于启动或关闭状态。但是，当此应用程序分解为微服务体系结构时，该应用程序由多个服务组成，并且所有这些服务都通过网络互连，这意味着该应用程序的某些部分可能正在运行，而其他部分可能会失败。遏制故障对避免通过其他服务传播错误很重要。弹性（或应用程序弹性）是应用程序/服务对问题做出反应并仍然提供最佳结果的能力。（译者注：这里的弹性与容错相关，对失败处理的弹性）&lt;/p>
&lt;p>&lt;strong>管道（Pipeline）&lt;/strong>：服务应独立部署，而无需进行任何形式的编排。因此，每个服务应具有自己的部署管道。&lt;/p>
&lt;p>&lt;strong>身份验证（Authentication）&lt;/strong>：关于微服务体系结构中的安全性的关键方面之一是如何对内部服务之间的调用进行身份验证/授权。Web 令牌（通常是令牌）是在内部服务中安全地表示声明的首选方式。&lt;/p>
&lt;p>&lt;strong>日志记录（Logging）&lt;/strong>：在单体应用程序中，日志记录很简单，因为该应用程序的所有组件都在同一节点上运行。然后现在组件以服务的形式分布在多个节点上，因此，要拥有完整的日志记录视图，需要一个统一的日志记录系统/数据收集器。&lt;/p>
&lt;p>&lt;strong>监控（Monitoring）&lt;/strong>：衡量系统的性能、了解应用程序的整体运行状况，以及在出现问题时发出警报是保持基于微服务的应用程序正确运行的关键方面。监控是控制应用程序的关键方面。&lt;/p>
&lt;p>&lt;strong>跟踪（Tracing）&lt;/strong>：跟踪用于可视化程序的流程和数据进度。作为开发人员/运维人员，当我们需要检查用户在整个应用程序中的行程时，这特别有用。&lt;/p>
&lt;p>Kubernetes正在成为部署微服务的实际工具。这是一个用于自动化、编排、扩展和管理容器的开源系统。&lt;/p>
&lt;p>使用 Kubernetes 时，十个微服务特性中只有三个被涵盖。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855537970.jpg" alt="">&lt;/p>
&lt;p>**服务发现 **是通过 &lt;em>Kubernetes 服务&lt;/em>的概念实现的。它提供了一种使用稳定的虚拟 IP 和 DNS 名称将 Kubernetes Pod 分组（作为一个整体）的方法。发现服务只是使用 Kubernetes 的服务名作为 hostname 进行请求。&lt;/p>
&lt;p>使用 Kubernetes 可以很容易地&lt;strong>调用服务&lt;/strong>，因为平台本身提供了调用任何服务所需的网络。&lt;/p>
&lt;p>从一开始，Kubernetes 就一直在考虑&lt;strong>弹性&lt;/strong>（或可伸缩性），例如运行时&lt;code>kubectl scale deployment myservice --replicas=5 command&lt;/code>，myservice deployment 可伸缩至五个副本或实例。Kubernetes 平台负责寻找合适的节点，部署服务并始终保持所需数量的副本并正常运行。&lt;/p>
&lt;p>但是其余的微服务特性又如何呢？Kubernetes 仅涵盖其中的三个，那么我们如何实现剩下的呢？&lt;/p>
&lt;p>根据所使用的语言或框架，可以遵循的策略很多。但是在本文中，我们将了解如何使用 &lt;a href="https://quarkus.io/">Quarkus&lt;/a> 实现其中的一些&lt;a href="https://quarkus.io/">策略&lt;/a>。&lt;/p>
&lt;h2 id="什么是-quarkus">什么是 Quarkus？&lt;/h2>
&lt;p>&lt;a href="https://quarkus.io/">Quarkus&lt;/a> 是针对 Java 虚拟机（JVM）和本机编译的全栈 Kubernetes 本地 Java 框架，专门针对容器优化 Java，使其成为无服务器（Serverless）、云和 Kubernetes 环境的高效平台。&lt;/p>
&lt;p>Instead of reinventing the wheel, Quarkus uses well-known enterprise-grade frameworks backed by standards/specifications and makes them compilable to a binary using &lt;a href="https://www.graalvm.org/">GraalVM&lt;/a>.
Quarkus不用重新发明轮子，而是使用以标准/规范为后盾的知名企业级框架，并使用 &lt;a href="https://www.graalvm.org/">GraalVM&lt;/a> 将其编译为二进制&lt;a href="https://www.graalvm.org/">文件&lt;/a>。&lt;/p>
&lt;h2 id="什么是-microprofile">什么是 MicroProfile？&lt;/h2>
&lt;p>Quarkus 与 &lt;a href="https://microprofile.io/">MicroProfile&lt;/a> 规范集成，从而将企业 Java 生态系统迁移到微服务体系结构中。&lt;/p>
&lt;p>在下图中，我们看到了构成 MicroProfile 规范的所有 API。某些 API（例如 CDI、JSON-P 和 JAX-RS）基于 &lt;a href="https://jakarta.ee/">Jakarta EE&lt;/a>（以前的 Java EE）规范。其余的由 Java 社区开发。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855657899.jpg" alt="">&lt;/p>
&lt;p>Let’s implement API, invocation, resilience, authentication, logging, monitoring, and tracing microservicilities using Quarkus.
让我们使用Quarkus实现API、调用、弹性、身份验证、日志记录、监视和跟踪微服务特性。&lt;/p>
&lt;h2 id="如何使用-quarkus-实现微服务特性">如何使用 Quarkus 实现微服务特性&lt;/h2>
&lt;h3 id="入门">入门&lt;/h3>
&lt;p>开始使用 Quarkus 的最快方法是通过在&lt;a href="https://code.quarkus.io/">开始页面&lt;/a>中选择所需的依赖。对于当前示例，选择如下依赖关系以满足微服务需求：&lt;/p>
&lt;p>API：RESTEasy JAX-RS、RESTEasy JSON-B、OpenAPI
调用：REST Client JSON-B
弹性：Fault Tolerance
认证：JWT
记录：GELF
监控：Micrometer metrics
跟踪：OpenTracing&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855795760.jpg" alt="">&lt;/p>
&lt;p>我们可以手动选择各自的依赖关系，或浏览以下链接 &lt;a href="https://code.quarkus.io/?a=microservicilities-quarkus&amp;amp;e=resteasy&amp;amp;e=resteasy-jsonb&amp;amp;e=rest-client-jsonb&amp;amp;e=smallrye-jwt&amp;amp;e=smallrye-openapi&amp;amp;e=logging-gelf&amp;amp;e=smallrye-fault-tolerance&amp;amp;e=micrometer&amp;amp;e=smallrye-opentracing">Quarkus 微服务特性生成器&lt;/a>，所有这些都会被选中。然后按“生成应用程序”按钮以下载包含支架应用程序的zip文件。&lt;/p>
&lt;h3 id="服务">服务&lt;/h3>
&lt;p>对于当前示例，仅使用两个服务生成了一个非常简单的应用程序。一个名为“&lt;em>评级服务 rating service&lt;/em>”的服务返回给定书籍的评级，而另一个名为“&lt;em>书籍服务 book service&lt;/em>”的服务则返回一本书的信息及其评级。服务之间的所有调用都必须经过身份验证。&lt;/p>
&lt;p>在下图中，我们看到了整个系统的概述：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855936882.jpg" alt="">&lt;/p>
&lt;p>&lt;em>评级服务&lt;/em>已经开发并作为 Linux 容器提供。通过运行以下命令，在端口 9090 上启动服务：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --rm -ti -p 9090:8080
quay.io/lordofthejars/rating-service:1.0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>要验证服务，请向 http://localhost:9090/rate/1 发出请求&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl localhost:8080/rate/1 -vv
&amp;gt; GET /rate/1 HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; User-Agent: curl/7.64.1
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 &lt;span class="m">401&lt;/span> Unauthorized
&amp;lt; www-authenticate: Bearer &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span>
&amp;lt; Content-Length: &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回的状态码是 &lt;code>401 Unauthorized&lt;/code> 因为没有在请求中携带令牌（JWT）提供授权信息。只有带有 &lt;em>group &lt;code>Echoer&lt;/code>&lt;/em> 有效令牌才能访问评级服务。&lt;/p>
&lt;h3 id="api">API&lt;/h3>
&lt;p>Quarkus 使用众所周知的 JAX-RS 规范来定义 RESTful Web API。在幕后，Quarkus 使用 RESTEasy 实现直接与 Vert.X 框架一起使用，而无需使用 Servlet 技术。&lt;/p>
&lt;p>让我们为实现最常见操作的图书服务定义一个 API：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Consumes&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.DELETE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.GET&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.POST&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Path&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.PathParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Produces&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.QueryParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.MediaType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.Response&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.UriBuilder&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/book&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">BookResource&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="nd">@POST&lt;/span>
&lt;span class="nd">@Consumes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">getBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Book&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">created&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">UriBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">fromResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">BookResource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">book&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">bookId&lt;/span>&lt;span class="o">))&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">())&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@DELETE&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">delete&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">noContent&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;search&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">searchBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@QueryParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;description&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">description&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">ok&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">books&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先要注意的是，定义了四个不同的端点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GET /book/{bookId}&lt;/code> 使用 GET HTTP 方法返回带有其评级的图书信息。return 元素会自动解编为 JSON。&lt;/li>
&lt;li>&lt;code>POST /book&lt;/code> 使用 POST HTTP 方法插入一本书作为正文内容。正文内容会自动从 JSON 编组到 Java 对象。&lt;/li>
&lt;li>&lt;code>DELETE /book/{bookId}&lt;/code> 使用 DELETE HTTP 方法通过书的 ID 删除书。&lt;/li>
&lt;li>&lt;code>GET /book/search?description={description}&lt;/code> 按书名搜索书籍。&lt;/li>
&lt;/ul>
&lt;p>注意的第二件事是返回类型，有时是 Java 对象，有时是 Java 实例 &lt;code>javax.ws.rs.core.Response&lt;/code>。使用 Java 对象时，会将其从 Java 对象序列化为 &lt;code>@Produces&lt;/code> 注解中设置的媒体类型。在此特定服务中，输出为 JSON 文档。通过该 &lt;code>Response&lt;/code> 对象，我们可以对返回给调用方的内容进行细粒度的控制。可以设置 HTTP 状态代码、标头或返回给调用方的内容。取决于使用场景，是偏爱一种方法而不是另一种方法。&lt;/p>
&lt;h3 id="调用">调用&lt;/h3>
&lt;p>在定义了用于访问&lt;em>图书服务&lt;/em>的 API 之后，是时候开发一段代码来调用&lt;em>评级服务&lt;/em>以检索图书的评级了。&lt;/p>
&lt;p>Quarkus 使用 &lt;a href="https://github.com/eclipse/microprofile-rest-client">MicroProfile Rest Client&lt;/a> 规范来访问外部（HTTP）服务。它提供了一种类型安全的方法，以通过某些 JAX-RS 2.0 API 通过 HTTP 调用 RESTful 服务，以实现一致性和更易于重用。&lt;/p>
&lt;p>要创建的第一个元素是一个使用 JAX-RS 批注表示远程服务的接口。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.GET&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Path&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.PathParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Produces&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.MediaType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.rest.client.inject.RegisterRestClient&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/rate&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RegisterRestClient&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">RatingService&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the getRate() method is called, a remote HTTP call is invoked at /rate/{bookId} replacing the bookId with the value set in the method parameter. It is important to annotate the interface with the @RegisterRestClient annotation.
Then the RatingService interface needs to be injected into BookResource to execute the remote calls.
当 &lt;code>getRate() &lt;/code>方法被调用时，远程 HTTP 请求在调用 &lt;code>/rate/{bookId}&lt;/code> 替换 &lt;code>bookId&lt;/code> 用在该方法中的参数值集合。用 &lt;code>@RegisterRestClient&lt;/code> 注解对接口进行注解很重要。&lt;/p>
&lt;p>然后 &lt;code>RatingService&lt;/code> 需要将接口注入 &lt;code>BookResource&lt;/code> 以执行远程调用。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.rest.client.inject.RestClient&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@RestClient&lt;/span>
&lt;span class="n">RatingService&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Book&lt;/span> &lt;span class="n">book&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The @RestClient annotation injects a proxied instance of the interface, providing the implementation of the client.
The last thing is to configure the service location (the hostname part). In Quarkus, the configuration properties are set in src/main/resources/application.properties file. To configure the location of the service, we need to use the fully qualified name of the Rest Client interface with URL as key, and the location as a value:
该 &lt;code>@RestClient&lt;/code> 注解注入界面的代理实例，提供客户端的实现。&lt;/p>
&lt;p>最后一件事是配置服务位置（&lt;em>hostname&lt;/em> 部分）。在 Quarkus 中，配置属性在 &lt;code>src/main/resources/application.properties&lt;/code> 文件中设置。要配置服务的位置，我们需要使用 Rest Client 接口的标准名称，其中 URL 作为键，而 location 作为值：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.acme.RatingService/mp-rest/url=http://localhost:9090
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在正确访问&lt;em>评估服务&lt;/em>而没有 &lt;code>401 Unauthorized&lt;/code> 问题之前，必须解决相互认证问题。&lt;/p>
&lt;h3 id="身份验证">身份验证&lt;/h3>
&lt;p>基于令牌的身份验证机制允许系统基于安全令牌对身份进行身份验证、授权和验证。Quarkus 与 &lt;a href="https://github.com/eclipse/microprofile-jwt-auth">MicroProfile JWT RBAC 安全&lt;/a>规范集成在一起，以使用 JWT 令牌保护服务。&lt;/p>
&lt;p>要使用 MicroProfile JWT RBAC 安全性保护端点，我们只需要使用批注对方法进行 &lt;code>@RolesAllowed&lt;/code> 注解。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RolesAllowed&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Echoer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，我们配置令牌的发行方和公钥的位置，以验证令牌在 &lt;code>application.properties&lt;/code> 文件中的签名：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">mp.jwt.verify.publickey.location=https://raw.githubusercontent.com/redhat-developer-demos/quarkus-tutorial/master/jwt-token/quarkus.jwt.pub
mp.jwt.verify.issuer=https://quarkus.io/using-jwt-rbac
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此扩展名自动验证：令牌有效；发行方是正确的；令牌尚未修改；签名有效；没有过期。&lt;/p>
&lt;p>这两种&lt;em>图书服务&lt;/em>和&lt;em>评级服务&lt;/em>现在是由同一 JWT 发行方和密钥保护，因此服务之间的通信要求验证提供在令牌的有效承载用户 &lt;code>Authentication&lt;/code> 头部。&lt;/p>
&lt;p>&lt;em>评级服务&lt;/em>启动和运行，让我们开始用下面的命令&lt;em>图书服务&lt;/em>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">./mvnw compile quarkus:dev
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we can make a request to get book information providing a valid JSON Web Token as a bearer token.
The generation of the token is out of the scope of this article, and a token has been already generated:
最后，我们可以请求获取提供有效 JSON Web 令牌作为承载令牌的图书信息。&lt;/p>
&lt;p>令牌的生成不在本文的讨论范围之内，并且已经生成了令牌：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856429022.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">curl -H &amp;#34;Authorization: Bearer eyJraWQiOiJcL3ByaXZhdGVLZXkucGVtIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJqZG9lLXVzaW5nLWp3dC1yYmFjIiwiYXVkIjoidXNpbmctand0LXJiYWMiLCJ1cG4iOiJqZG9lQHF1YXJrdXMuaW8iLCJiaXJ0aGRhdGUiOiIyMDAxLTA3LTEzIiwiYXV0aF90aW1lIjoxNTcwMDk0MTcxLCJpc3MiOiJodHRwczpcL1wvcXVhcmt1cy5pb1wvdXNpbmctand0LXJiYWMiLCJyb2xlTWFwcGluZ3MiOnsiZ3JvdXAyIjoiR3JvdXAyTWFwcGVkUm9sZSIsImdyb3VwMSI6Ikdyb3VwMU1hcHBlZFJvbGUifSwiZ3JvdXBzIjpbIkVjaG9lciIsIlRlc3RlciIsIlN1YnNjcmliZXIiLCJncm91cDIiXSwicHJlZmVycmVkX3VzZXJuYW1lIjoiamRvZSIsImV4cCI6MjIwMDgxNDE3MSwiaWF0IjoxNTcwMDk0MTcxLCJqdGkiOiJhLTEyMyJ9.Hzr41h3_uewy-g2B-sonOiBObtcpkgzqmF4bT3cO58v45AIOiegl7HIx7QgEZHRO4PdUtR34x9W23VJY7NJ545ucpCuKnEV1uRlspJyQevfI-mSRg1bHlMmdDt661-V3KmQES8WX2B2uqirykO5fCeCp3womboilzCq4VtxbmM2qgf6ag8rUNnTCLuCgEoulGwTn0F5lCrom-7dJOTryW1KI0qUWHMMwl4TX5cLmqJLgBzJapzc5_yEfgQZ9qXzvsT8zeOWSKKPLm7LFVt2YihkXa80lWcjewwt61rfQkpmqSzAHL0QIs7CsM9GfnoYc0j9po83-P3GJiBMMFmn-vg&amp;#34; localhost:8080/book/1 -v
&lt;/code>&lt;/pre>&lt;/div>&lt;p>响应又是 forbidden 错误：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&amp;lt; HTTP/1.1 401 Unauthorized
&amp;lt; Content-Length: 0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可能想知道为什么在提供有效令牌后仍然出现此错误。如果我们检查图书服务的控制台，就会发现抛出了以下异常：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.jboss.resteasy.client.exception.ResteasyWebApplicationException: Unknown error, status code 401
at org.jboss.resteasy.client.exception.WebApplicationExceptionWrapper.wrap(WebApplicationExceptionWrapper.java:107)
at org.jboss.resteasy.microprofile.client.DefaultResponseExceptionMapper.toThrowable(DefaultResponseExceptionMapper.java:21)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发生此异常的原因是，我们已获得身份验证并有权访问&lt;em>图书服务&lt;/em>，但承载令牌尚未传播到&lt;em>评级服务&lt;/em>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856618998.jpg" alt="">&lt;/p>
&lt;p>为了自动将 &lt;code>Authorization&lt;/code> 标头从传入请求传播到其余客户端请求，需要进行两次修改。&lt;/p>
&lt;p>第一个修改是修改 Rest Client 界面，并使用对其进行注解 &lt;code>org.eclipse.microprofile.rest.client.inject.RegisterClientHeaders&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/rate&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RegisterRestClient&lt;/span>
&lt;span class="nd">@RegisterClientHeaders&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">RatingService&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二个修改是配置在请求之间传播哪些标头。这是在 &lt;code>application.properties&lt;/code> 文件中设置的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"> org.eclipse.microprofile.rest.client.propagateHeaders=Authorization
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行与之前相同的 curl 命令，我们将获得正确的输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&amp;lt; HTTP/1.1 &lt;span class="m">200&lt;/span> OK
&amp;lt; Content-Length: &lt;span class="m">39&lt;/span>
&amp;lt; Content-Type: application/json
&amp;lt;
* Connection &lt;span class="c1">#0 to host localhost left intact&lt;/span>
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:2,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 2&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:1&lt;span class="o">}&lt;/span>* Closing connection &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="弹性">弹性&lt;/h3>
&lt;p>在微服务架构中，具有容错能力很重要，这样可以避免故障从一个服务传播到该服务的所有直接和间接调用方。Quarkus 将 &lt;a href="https://github.com/eclipse/microprofile-fault-tolerance">MicroProfile Fault Tolerance&lt;/a> 规范与以下用于处理故障的注释集成在一起：&lt;/p>
&lt;p>●    &lt;code>@Timeout&lt;/code>：定义抛出异常之前执行的最长时间。
●    &lt;code>@Retry&lt;/code>：如果调用失败，请再次重试执行。
●    &lt;code>@Bulkhead&lt;/code>：限制并发执行，以使该区域中的故障不会使整个系统过载。
●    &lt;code>@CircuitBreaker&lt;/code>：执行反复失败时，将自动进行快速故障切换。
●    &lt;code>@Fallback&lt;/code>：执行失败时，提供备用解决方案/默认值。&lt;/p>
&lt;p>让我们添加三次重试，其中重试之间的延迟计时器为一秒，以防访问&lt;em>评级服务&lt;/em>时发生错误。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Retry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxRetries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，停止&lt;em>评级服务&lt;/em>并执行请求。引发以下异常：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.jboss.resteasy.spi.UnhandledException: javax.ws.rs.ProcessingException: RESTEASY004655: Unable to invoke request:
org.apache.http.conn.HttpHostConnectException: Connect to localhost:9090 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused
&lt;/code>&lt;/pre>&lt;/div>&lt;p>显然，这里存在错误，但是请注意，由于执行了三次重试（延迟一秒），因此引发异常之前，经过了三秒钟。&lt;/p>
&lt;p>在这种情况下，&lt;em>评级服务&lt;/em>已关闭，因此无法进行恢复，但是在一个实际示例中，&lt;em>评级服务&lt;/em>可能仅在短时间内就恢复了，或者部署了该服务的多个副本，因此可以简单地重试操作可能足以恢复并提供有效的响应。&lt;/p>
&lt;p>但是，当引发异常时重试次数不够时，我们可以将错误传播给调用方，也可以为调用提供替代值。这种选择可以是对另一个系统的调用（即分布式缓存）或静态值。&lt;/p>
&lt;p>对于此用例，当与评级服务的连接失败时，将返回评级值 0。&lt;/p>
&lt;p>要实现回退逻辑，首先要做的是实现将 &lt;code>org.eclipse.microprofile.faulttolerance.FallbackHandler&lt;/code> 返回类型设置为与回退策略方法提供的替代类型相同的接口。对于这种情况，将 &lt;code>Rate&lt;/code> 返回默认对象。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.faulttolerance.ExecutionContext&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.faulttolerance.FallbackHandler&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">RatingServiceFallback&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">FallbackHandler&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rate&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="nf">handle&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ExecutionContext&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Rate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">rate&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rate&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后要做的是用注解对 &lt;code>getRating()&lt;/code> 方法进行 &lt;code>@org.eclipse.microprofile.faulttolerance.Fallback&lt;/code> 注解，以配置无法恢复时要执行的回退类。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Retry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxRetries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Fallback&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RatingServiceFallback&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果重复与以前相同的请求，则不会引发任何异常，但是有效值的输出将 rating 字段设置为 0。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">* Connection #0 to host localhost left intact
{&amp;#34;bookId&amp;#34;:2,&amp;#34;name&amp;#34;:&amp;#34;Book 2&amp;#34;,&amp;#34;rating&amp;#34;:0}* Closing connection 0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>规范提供的任何其他策略都可以使用相同的方法。例如，对于断路器模式：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@CircuitBreaker&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">requestVolumeThreshold&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">4&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">failureRatio&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">75&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在四个连续调用的滚动窗口中发生了三个（&lt;em>4 x 0.75&lt;/em>）故障，则电路将断开 1000 ms，然后恢复到半断开状态。如果在半开时调用成功，则将其再次关闭。否则，它将保持打开状态&lt;/p>
&lt;h3 id="日志记录">日志记录&lt;/h3>
&lt;p>在微服务架构中，建议将所有服务的日志收集在一个统一的日志中，以更有效地使用和理解。&lt;/p>
&lt;p>一种解决方案是使用 &lt;a href="https://www.fluentd.org/">Fluentd&lt;/a>，它是 &lt;a href="https://www.fluentd.org/">Kubernetes&lt;/a> 中用于统一日志记录层的开源数据收集器。Quarkus 使用 Graylog 扩展日志格式（GELF）与 Fluentd 集成。&lt;/p>
&lt;p>集成真的很简单。首先，与其他任何 Quarkus 应用程序一样使用日志逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.jboss.logging.Logger&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Logger&lt;/span> &lt;span class="n">LOG&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getLogger&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">BookResource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RolesAllowed&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Echoer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">LOG&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Get Book&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，启用 GELF 格式并设置 Fluentd 服务器位置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">quarkus.log.handler.gelf.enabled=true
quarkus.log.handler.gelf.host=localhost
quarkus.log.handler.gelf.port=12201
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，我们可以向记录的端点发出请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出方面没有任何变化，但是日志行已传输到 Fluentd。如果使用 &lt;a href="https://www.elastic.co/kibana">Kibana&lt;/a> 可视化数据，我们将看到存储的日志行：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856876241.jpg" alt="">&lt;/p>
&lt;h3 id="监控">监控&lt;/h3>
&lt;p>Monitoring is another &amp;ldquo;microservicilitie&amp;rdquo; that needs to be implemented in our microservice architecture. Quarkus integrates with &lt;a href="https://micrometer.io/">Micrometer&lt;/a> for application monitoring. Micrometer provides a single entry point to the most popular monitoring systems, allowing you to instrument your JVM-based application code without vendor lock-in.&lt;/p>
&lt;p>For this example, &lt;a href="https://prometheus.io/">Prometheus&lt;/a> format is used as monitoring output but Micrometer (and Quarkus) also supports other formats like Azure Monitor, Stackdriver, SignalFx, StatsD, and DataDog.&lt;/p>
&lt;p>You can register the following Maven dependency to provide Prometheus output:
监控是另一个需要在我们的微服务架构中实现的 “微服务特性”。Quarkus 与 &lt;a href="https://micrometer.io/">Micrometer&lt;/a> 集成在一起以进行应用程序监控。Micrometer 提供了最流行的监控系统的单个入口点，使你无需供应商锁定即可检测基于 JVM 的应用程序代码。&lt;/p>
&lt;p>对于此示例，监控输出采用 &lt;a href="https://prometheus.io/">Prometheus&lt;/a> 格式，但 Micrometer（和 Quarkus）还支持其他格式，例如 Azure Monitor、Stackdriver、SignalFx、StatsD 和 DataDog。&lt;/p>
&lt;p>你可以注册以下 Maven 依赖项以提供 Prometheus 输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.quarkus&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>quarkus-micrometer-registry-prometheus&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，Micrometer 扩展注册了一些与系统，JVM 或 HTTP 相关的度量。收集的指标的一个子集在 &lt;code>/q/metrics&lt;/code> 端点处可用，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl localhost:8080/q/metrics
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;runnable&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 22.0
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;blocked&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 0.0
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;waiting&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 10.0
http_server_bytes_read_count 1.0
http_server_bytes_read_sum 0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，也可以使用 Micrometer API 来实现特定于应用程序的指标。
让我们实现一个自定义指标，该指标用于衡量评价最高的图书。&lt;/p>
&lt;p>使用 &lt;code>io.micrometer.core.instrument.MeterRegistry&lt;/code> 该类可以完成指标（在这种情况下为量规）的注册。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">MeterRegistry&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">LongAccumulator&lt;/span> &lt;span class="n">highestRating&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LongAccumulator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">BookResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MeterRegistry&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">registry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">registry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">gauge&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;book.rating.max&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">BookResource&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">highestRatingBook&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求一下，并验证量规是否正确更新。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
curl localhost:8080/q/metrics
&lt;span class="c1"># HELP book_rating_max&lt;/span>
&lt;span class="c1"># TYPE book_rating_max gauge&lt;/span>
book_rating_max 3.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还可以设置一个计时器来记录从&lt;em>评级服务&lt;/em>获取评级信息所花费的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">Supplier&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rate&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">rateSupplier&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">};&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">timer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;book.rating.test&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">wrap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">rateSupplier&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求一下，并验证收集评价​​所花费的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"># HELP book_rating_test_seconds
# TYPE book_rating_test_seconds summary
book_rating_test_seconds_count 4.0
book_rating_test_seconds_sum 1.05489108
# HELP book_rating_test_seconds_max
# TYPE book_rating_test_seconds_max gauge
book_rating_test_seconds_max 1.018622001
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Micrometer 使用 &lt;code>MeterFilter&lt;/code> 实例来自定义 &lt;code>MeterRegistry&lt;/code> 实例发出的度量。Micrometer 扩展将检测 &lt;code>MeterFilter&lt;/code> CDI bean，并在初始化 &lt;code>MeterRegistry&lt;/code> 实例时使用它们。&lt;/p>
&lt;p>例如，我们可以定义一个通用标签来设置运行应用程序的环境（产品、测试、预发布等）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Singleton&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MicrometerCustomConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Produces&lt;/span>
&lt;span class="nd">@Singleton&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">MeterFilter&lt;/span> &lt;span class="nf">configureAllRegistries&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">MeterFilter&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">commonTags&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Arrays&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">asList&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">Tag&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">of&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;env&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;prod&amp;#34;&lt;/span>&lt;span class="o">)));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发送新请求并验证指标是否已标记。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">http_client_requests_seconds_max{clientName=&amp;#34;localhost&amp;#34;,env=&amp;#34;prod&amp;#34;,method=&amp;#34;GET&amp;#34;,outcome=&amp;#34;SUCCESS&amp;#34;,status=&amp;#34;200&amp;#34;,uri=&amp;#34;/rate/2&amp;#34;,} 0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意 &lt;code>env&lt;/code> 包含值为 &lt;code>prod&lt;/code> 的标签。&lt;/p>
&lt;h3 id="跟踪">跟踪&lt;/h3>
&lt;p>Quarkus 应用程序利用 &lt;a href="https://opentracing.io/">OpenTracing&lt;/a> 规范为交互式 Web 应用程序提供分布式跟踪。&lt;/p>
&lt;p>让我们配置 OpenTracing 以连接到 Jaeger 服务器，将 book-service 设置为服务名称以标识跟踪：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">quarkus.jaeger.enabled=true
quarkus.jaeger.endpoint=http://localhost:14268/api/traces
quarkus.jaeger.service-name=book-service
quarkus.jaeger.sampler-type=const
quarkus.jaeger.sampler-param=1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在发一个请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1 &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问Jaeger UI以验证是否跟踪了该调用：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219857070960.jpg" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>与开发整体应用程序相比，开发和实现微服务体系结构更具挑战性。我们认为，微服务可以驱动你根据应用程序基础结构正确地开发服务。&lt;/p>
&lt;p>此处介绍的大多数微服务（API 和管道除外）是新的，或者在整体应用中实现方式有所不同。原因是现在应用程序被分解成几部分，所有部分都在网络中互连。&lt;/p>
&lt;p>如果你May 26, 2021打算开发微服务并将其部署到 Kubernetes，那么 Quarkus 是一个很好的解决方案，因为它可以与 Kubernetes 顺利集成。实施大多数微服务很简单，只需要几行代码。&lt;/p>
&lt;p>本文演示的源代码可以在 &lt;a href="https://github.com/lordofthejars/microservicilities-quarkus">github&lt;/a> 上找到。&lt;/p>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219857200384.jpg" alt="">&lt;/p>
&lt;p>Alex Soto 是 Red Hat 开发人员经验总监。他对 Java 世界，软件自动化充满热情，并且他相信开源软件模型。Soto 是 &lt;a href="https://www.manning.com/books/testing-java-microservices">Manning&lt;/a> 的合著者 | &lt;a href="https://www.manning.com/books/testing-java-microservices">测试 Java 微服务&lt;/a>和 &lt;a href="https://www.oreilly.com/library/view/quarkus-cookbook/9781492062646/">O&amp;rsquo;Reilly Quarkus Cookbook&lt;/a> 和几个开源项目的贡献者。自 2017 年以来一直是 Java 冠军，他还是 Salle URL University 的国际演讲者和老师。你可以在 Twitter （Alex Soto）上关注他，以随时了解 Kubernetes 和 Java 世界中正在发生的事情。&lt;/p></description></item><item><title>Quarkus：谁说 Java 不能用来跑 Serverless？</title><link>https://atbug.com/quarkus-enable-java-running-in-serverless/</link><pubDate>Sat, 24 Apr 2021 09:16:05 +0800</pubDate><guid>https://atbug.com/quarkus-enable-java-running-in-serverless/</guid><description>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/24/whynotjava.png" alt="why-not-java">&lt;/p>
&lt;p>想到这个标题的时候，我第一时间想到的就是星爷的《唐伯虎点秋香》的这一幕。&lt;/p>
&lt;p>当讨论起世界上最好的开发语言是什么的时候，Java 的粉丝们总会遇到这种场景：&lt;/p>
&lt;blockquote>
&lt;p>吹：“Java 语法简单，容易上手！”
黑：“Java 启动慢，性能差，耗资源！”
吹：“Java 有世界上最多的程序员！”
黑：“Java 启动慢，性能差，耗资源！”
吹：“Java 生态好！”
黑：“Java 启动慢，性能差，耗资源！”
吹：“滚！”&lt;/p>
&lt;/blockquote>
&lt;p>今天我们继续说说 Quarkus，应“云”而生的 Java 框架。今天算是第三篇了，没看过的同学可以回顾一下：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/YcEqFm3oxlsEvJ3ckRbQyA">Hello, Quarkus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dq3hQrXE4XWH-MyjBAGMEw">应&amp;quot;云&amp;quot;而生的 Java 框架 Quarkus：构建本机可执行文件&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>上一篇的结尾预告：试试 Quarkus 在 ArgoCD 中的应用，看下 Serverless 上的使用体验。不过不想用 ArgoCD 了，因为这 workflow 这种场景实在体现不出 Quarkus 到底有多快。但又想做 Serverless，那就想到了 Knative Serving 了。&lt;/p>
&lt;p>其实，还有一个原因是比较懒，上次的镜像还可以直接拿来用。&lt;/p>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>废话不多说，先上结论。Quarkus 与 Spring 首个请求的响应耗时：&lt;strong>2.5s vs 5.7s&lt;/strong>。&lt;/p>
&lt;p>&lt;em>注：为了忽略拉取镜像的时间差异，提前 pull 镜像。&lt;/em>&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/24/cleanshot-20210424-at-0831012x.png" alt="">&lt;/p>
&lt;h2 id="验证">验证&lt;/h2>
&lt;h3 id="环境准备">环境准备&lt;/h3>
&lt;ul>
&lt;li>Kubernetes 1.18+ via minikube&lt;/li>
&lt;li>Istio 1.9.2&lt;/li>
&lt;li>Knative 0.22.0&lt;/li>
&lt;li>Knative CLI （brew 安装）&lt;/li>
&lt;li>watch （brew 安装）&lt;/li>
&lt;/ul>
&lt;p>环境的安装准备参考官方的文档。&lt;/p>
&lt;h4 id="镜像">镜像&lt;/h4>
&lt;p>资源镜像就使用&lt;a href="https://mp.weixin.qq.com/s/Dq3hQrXE4XWH-MyjBAGMEw">上一篇文章&lt;/a>构建的，但需要做下调整：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker tag quarkus/quarkus-getting-started:distroless dev.local/quarkus/quarkus-getting-started:distroless
docker tag spring/spring-getting-started:latest dev.local/spring/spring-getting-started:latest
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注：knative 会忽略 &lt;code>dev.local&lt;/code> 镜像的预加载，不会在创建 knative service 的时候拉取。&lt;/p>
&lt;p>然后使用 &lt;code>minikube image load&lt;/code> 加载到 minikube环境中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube image load dev.local/quarkus/quarkus-getting-started:distroless
minikube image load dev.local/spring/spring-getting-started:latest
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="knative-配置可选">knative 配置（可选）&lt;/h4>
&lt;p>修改 &lt;code>istio-system&lt;/code> namespace 下的 configmap &lt;code>config-domain&lt;/code>，增加新的 domain：&lt;code>nip.io&lt;/code>&lt;/p>
&lt;p>注：这个操作纯属个人喜好，不喜欢那个 &lt;code>example.com&lt;/code>，可跳过。&lt;/p>
&lt;h4 id="获取-istio-ingress-地址">获取 Istio Ingress 地址&lt;/h4>
&lt;p>使用命令获取 Ingress 的访问方式，这里 &lt;code>http2/80&lt;/code> 后的 &lt;code>http://192.168.64.2:31608&lt;/code> 就是我们需要的，记下这个 ip 和端口。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube service list
&lt;span class="p">|&lt;/span>------------------&lt;span class="p">|&lt;/span>----------------------------&lt;span class="p">|&lt;/span>-------------------&lt;span class="p">|&lt;/span>---------------------------&lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> NAMESPACE &lt;span class="p">|&lt;/span> NAME &lt;span class="p">|&lt;/span> TARGET PORT &lt;span class="p">|&lt;/span> URL &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span>------------------&lt;span class="p">|&lt;/span>----------------------------&lt;span class="p">|&lt;/span>-------------------&lt;span class="p">|&lt;/span>---------------------------&lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> default &lt;span class="p">|&lt;/span> kubernetes &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> istio-system &lt;span class="p">|&lt;/span> istio-egressgateway &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> istio-system &lt;span class="p">|&lt;/span> istio-ingressgateway &lt;span class="p">|&lt;/span> status-port/15021 &lt;span class="p">|&lt;/span> http://192.168.64.2:32431 &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> http2/80 &lt;span class="p">|&lt;/span> http://192.168.64.2:31608 &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> https/443 &lt;span class="p">|&lt;/span> http://192.168.64.2:31795 &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> tcp/31400 &lt;span class="p">|&lt;/span> http://192.168.64.2:31369 &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> tls/15443 &lt;span class="p">|&lt;/span> http://192.168.64.2:30293 &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> istio-system &lt;span class="p">|&lt;/span> istiod &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> istio-system &lt;span class="p">|&lt;/span> knative-local-gateway &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-eventing &lt;span class="p">|&lt;/span> broker-filter &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-eventing &lt;span class="p">|&lt;/span> broker-ingress &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-eventing &lt;span class="p">|&lt;/span> eventing-webhook &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-eventing &lt;span class="p">|&lt;/span> imc-dispatcher &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-serving &lt;span class="p">|&lt;/span> activator-service &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-serving &lt;span class="p">|&lt;/span> autoscaler &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-serving &lt;span class="p">|&lt;/span> autoscaler-bucket-00-of-01 &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-serving &lt;span class="p">|&lt;/span> autoscaler-hpa &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-serving &lt;span class="p">|&lt;/span> controller &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-serving &lt;span class="p">|&lt;/span> istio-webhook &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> knative-serving &lt;span class="p">|&lt;/span> webhook &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> kube-system &lt;span class="p">|&lt;/span> kube-dns &lt;span class="p">|&lt;/span> No node port &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span>------------------&lt;span class="p">|&lt;/span>----------------------------&lt;span class="p">|&lt;/span>-------------------&lt;span class="p">|&lt;/span>---------------------------&lt;span class="p">|&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建-knative-service">创建 Knative service&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="c">#quarkus&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">serving.knative.dev/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hello-quarkus&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dev.local/quarkus/quarkus-getting-started:distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Never&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c">#spring&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">serving.knative.dev/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hello-spring&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dev.local/spring/spring-getting-started:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Never&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 cli &lt;code>kn&lt;/code> 命令查看下 service 的信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kn service describe hello-quarkus -n default
Name: hello-quarkus
Namespace: default
Age: 21s
URL: http://hello-quarkus.default.nip.io
Revisions:
100% @latest &lt;span class="o">(&lt;/span>hello-quarkus-00001&lt;span class="o">)&lt;/span> &lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>21s&lt;span class="o">)&lt;/span>
Image: dev.local/quarkus/quarkus-getting-started:distroless
Conditions:
OK TYPE AGE REASON
++ Ready 9s
++ ConfigurationsReady 10s
++ RoutesReady 9s
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kn service describe hello-spring -n default
Name: hello-spring
Namespace: default
Age: 44s
URL: http://hello-spring.default.nip.io
Revisions:
100% @latest &lt;span class="o">(&lt;/span>hello-spring-00001&lt;span class="o">)&lt;/span> &lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>44s&lt;span class="o">)&lt;/span>
Image: dev.local/spring/spring-getting-started:latest
Conditions:
OK TYPE AGE REASON
++ Ready 31s
++ ConfigurationsReady 32s
++ RoutesReady 31s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从描述信息中可以拿到服务的访问地址，分别是 &lt;code>http://hello-quarkus.default.nip.io&lt;/code> 和 &lt;code>http://hello-spring.default.nip.io&lt;/code>。&lt;/p>
&lt;p>接下来就需要在本地主机的 hosts 中加入解析：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">192.168.64.2 hello-quarkus.default.nip.io
192.168.64.2 hello-spring.default.nip.io
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>上面操作完之后，就可以使用下面的地址访问服务了。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="http://hello-quarkus.default.nip.io:31608/hello/greeting/quarkus">http://hello-quarkus.default.nip.io:31608/hello/greeting/quarkus&lt;/a>
&lt;a href="http://hello-spring.default.nip.io:31608/hello/greeting/spring">http://hello-spring.default.nip.io:31608/hello/greeting/spring&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在测试的过程中，可以通过 &lt;code>watch -n 1 'kubectl get po -n default | grep hello'&lt;/code> 命令来查看 pod 的创建和销毁。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/24/20210424-090756.gif" alt="2021-04-24 09.07.56">&lt;/p></description></item><item><title>应“云”而生的 Java 框架：构建本机可执行文件</title><link>https://atbug.com/quarkus-build-native-executable-file/</link><pubDate>Sat, 17 Apr 2021 09:08:40 +0800</pubDate><guid>https://atbug.com/quarkus-build-native-executable-file/</guid><description>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/17/16186233244243.jpg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>电影《功夫》中，火云邪神有句话：“天下武功无坚不摧，唯快不破。”&lt;/p>
&lt;/blockquote>
&lt;p>在 &lt;a href="https://mp.weixin.qq.com/s/YcEqFm3oxlsEvJ3ckRbQyA">上一篇文章&lt;/a> 中，我们写了第一个 Quarkus 应用，并尝试着构建了 &lt;code>legacy-jar&lt;/code> 和 &lt;code>fast-jar&lt;/code>。&lt;/p>
&lt;p>今天来看一下 Quarkus 构建出来的本机可执行文件到底比 Spring 应用能快多少，&lt;strong>生态的成熟度不在这里讨论&lt;/strong>。&lt;/p>
&lt;h2 id="tldr">TLDR&lt;/h2>
&lt;p>先上结论， 与只有一个 Controller 的Spring Web 应用做下对比。&lt;/p>
&lt;h3 id="应用启动时间0012s-vs-2294s">应用启动时间：0.012s vs 2.294s&lt;/h3>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/17/cleanshot-20210417-at-0900292x.png" alt="CleanShot 2021-04-17 at 09.00.29@2x">&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/17/cleanshot-20210417-at-0915282x.png" alt="CleanShot 2021-04-17 at 09.15.28@2x">&lt;/p>
&lt;h3 id="镜像大小49mb-vs-237-mb">镜像大小：49MB vs 237 MB&lt;/h3>
&lt;p>Spring 应用镜像使用 &lt;code>openjdk:11.0-jre-slim&lt;/code> 作为 base 镜像，大小为 220MB。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
spring/spring-getting-started latest 5f47030c5c3f &lt;span class="m">6&lt;/span> minutes ago 237MB
quarkus/quarkus-getting-started distroless2 fe973c5ac172 &lt;span class="m">24&lt;/span> minutes ago 49MB
quarkus/quarkus-getting-started distroless 6fe27dd44e86 &lt;span class="m">31&lt;/span> minutes ago 51MB
quarkus/quarkus-getting-started ubi 8f86f5915715 &lt;span class="m">58&lt;/span> minutes ago 132MB
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java-应用容器化的困境">Java 应用容器化的困境&lt;/h2>
&lt;p>云原生世界中，应用容器化是个显著的特点。Java 应用容器化时面临了如下问题：&lt;/p>
&lt;ul>
&lt;li>应用启动慢：其实这是 Java 应用的问题。Java 应用占用内存多；JVM 虚拟机启动时需要做环境的初始化、预加载大量的类、初始化线程等等。启动耗时视应用情况需要几秒，甚至可达分钟级。较长的启动耗时，也抑制了水平伸缩性。即使在 Serverless 这种响应耗时要求不高的场景，也会被嫌弃。&lt;/li>
&lt;li>镜像过大：其实使用了镜像的分层设计，常见的一个 SpringCloud 应用的 über-jar 包可能都有 7、80MB。&lt;/li>
&lt;li>空间占用：虽然用了镜像分层，但积少成多，也会增加存储成本。&lt;/li>
&lt;/ul>
&lt;h2 id="quarkus-与本机映像native-image">Quarkus 与本机映像（native image）&lt;/h2>
&lt;p>Quarkus 的开发遵从了容器优先的原则：&lt;/p>
&lt;ul>
&lt;li>支持 Graal/SubstrateVM&lt;/li>
&lt;li>构建时处理元数据&lt;/li>
&lt;li>减少反射的使用&lt;/li>
&lt;li>本机映像预启动&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>本机映像是将 Java 代码提前编译为可执行文件（称为本机映像）的技术。该可执行文件包括应用程序类、其依赖项中的类、运行时库类以及 JDK 中的静态链接本机代码。它不是在 Java VM 上运行，而是包括必要的组件，例如内存管理，线程调度等，这些组件来自另一个运行时系统 “Substrate VM”。“Substrate VM” 是运行时组件（例如反优化器，垃圾收集器，线程调度等）的名称。与 JVM 相比，生成的程序具有更快的启动时间和更低的运行时内存开销。&lt;/p>
&lt;/blockquote>
&lt;h2 id="如何构建本机映像">如何构建本机映像&lt;/h2>
&lt;p>环境配置参考&lt;a href="https://mp.weixin.qq.com/s/YcEqFm3oxlsEvJ3ckRbQyA">上一篇文章&lt;/a>，可以直接&lt;a href="https://github.com/addozhang/quarkus-getting-started">从这里下载源码&lt;/a>。&lt;/p>
&lt;h3 id="配置-graalvm">配置 GraalVM&lt;/h3>
&lt;p>之前我们使用了&lt;a href="https://sdkman.io/"> sdkman&lt;/a> 进行 GraalVM 安装。设置 &lt;code>GRAALVM_HOME&lt;/code> 环境变量：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nb">export&lt;/span> &lt;span class="nv">GRAALVM_HOME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>sdk home java 21.0.0.2.r11-grl&lt;span class="sb">`&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>gu&lt;/code> 安装 &lt;code>native-image&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="si">${&lt;/span>&lt;span class="nv">GRAALVM_HOME&lt;/span>&lt;span class="si">}&lt;/span>/bin/gu install native-image
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="构建本机可执行文件">构建本机可执行文件&lt;/h3>
&lt;p>在源码的 &lt;code>pom.xml&lt;/code> 中，我们可以看到如下的 &lt;code>profile&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;profiles&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;profile&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;id&amp;gt;&lt;/span>native&lt;span class="nt">&amp;lt;/id&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;properties&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;quarkus.package.type&amp;gt;&lt;/span>native&lt;span class="nt">&amp;lt;/quarkus.package.type&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/profile&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/profiles&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们使用这个 profile 进行本机可执行文件的构建，整个构建耗时 &lt;strong>几分钟&lt;/strong> 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">./mvnw package -Pnative
&lt;/code>&lt;/pre>&lt;/div>&lt;p>部分构建日志：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ quarkus-getting-started ---
[INFO]
[INFO] --- quarkus-maven-plugin:1.13.0.Final:build (default) @ quarkus-getting-started ---
[INFO] [org.jboss.threads] JBoss Threads version 3.2.0.Final
[INFO] [io.quarkus.deployment.pkg.steps.JarResultBuildStep] Building native image source jar: /Users/addo/Workspaces/private_w/quarkus-getting-started/target/quarkus-getting-started-1.0.0-SNAPSHOT-native-image-source-jar/quarkus-getting-started-1.0.0-SNAPSHOT-runner.jar
[INFO] [io.quarkus.deployment.pkg.steps.NativeImageBuildStep] Building native image from /Users/addo/Workspaces/private_w/quarkus-getting-started/target/quarkus-getting-started-1.0.0-SNAPSHOT-native-image-source-jar/quarkus-getting-started-1.0.0-SNAPSHOT-runner.jar
[INFO] [io.quarkus.deployment.pkg.steps.NativeImageBuildContainerRunner] Using docker to run the native image builder
[INFO] [io.quarkus.deployment.pkg.steps.NativeImageBuildContainerRunner] Checking image status quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11
21.0.0-java11: Pulling from quarkus/ubi-quarkus-native-image
Digest: sha256:becf08de869e707beaa5e57444b533ef93ebef15aad90c92ac660ddf7cea2b11
Status: Image is up to date for quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11
quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11
[INFO] [io.quarkus.deployment.pkg.steps.NativeImageBuildStep] Running Quarkus native-image plugin on GraalVM Version 21.0.0 (Java Version 11.0.10+8-jvmci-21.0-b06)
[INFO] [io.quarkus.deployment.pkg.steps.NativeImageBuildRunner] docker run --env LANG=C --rm -v /Users/addo/Workspaces/private_w/quarkus-getting-started/target/quarkus-getting-started-1.0.0-SNAPSHOT-native-image-source-jar:/project:z quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11 -J-Dsun.nio.ch.maxUpdateArraySize=100 -J-Djava.util.logging.manager=org.jboss.logmanager.LogManager -J-Dvertx.logger-delegate-factory-class-name=io.quarkus.vertx.core.runtime.VertxLogDelegateFactory -J-Dvertx.disableDnsResolver=true -J-Dio.netty.leakDetection.level=DISABLED -J-Dio.netty.allocator.maxOrder=1 -J-Duser.language=en -J-Duser.country=CN -J-Dfile.encoding=UTF-8 --initialize-at-build-time= -H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy\$BySpaceAndTime -H:+JNI -H:+AllowFoldMethods -jar quarkus-getting-started-1.0.0-SNAPSHOT-runner.jar -H:FallbackThreshold=0 -H:+ReportExceptionStackTraces -J-Xmx5g -H:-AddAllCharsets -H:EnableURLProtocols=http --no-server -H:-UseServiceLoaderFeature -H:+StackTrace quarkus-getting-started-1.0.0-SNAPSHOT-runner
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] classlist: 5,859.24 ms, 0.96 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (cap): 633.34 ms, 0.94 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] setup: 2,468.19 ms, 0.94 GB
00:06:00,437 INFO [org.jbo.threads] JBoss Threads version 3.2.0.Final
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (clinit): 516.65 ms, 2.23 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (typeflow): 12,642.02 ms, 2.23 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (objects): 11,340.37 ms, 2.23 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (features): 525.87 ms, 2.23 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] analysis: 26,032.67 ms, 2.23 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] universe: 1,394.06 ms, 2.16 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (parse): 2,690.38 ms, 2.16 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (inline): 4,336.77 ms, 2.73 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] (compile): 17,580.03 ms, 2.71 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] compile: 26,152.06 ms, 2.71 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] image: 3,288.43 ms, 2.70 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] write: 1,904.64 ms, 2.70 GB
[quarkus-getting-started-1.0.0-SNAPSHOT-runner:25] [total]: 67,414.16 ms, 2.70 GB
[WARNING] [io.quarkus.deployment.pkg.steps.NativeImageBuildStep] objcopy executable not found in PATH. Debug symbols will not be separated from executable.
[WARNING] [io.quarkus.deployment.pkg.steps.NativeImageBuildStep] That will result in a larger native image with debug symbols embedded in it.
[INFO] [io.quarkus.deployment.QuarkusAugmentor] Quarkus augmentation completed in 74739ms
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 01:21 min
[INFO] Finished at: 2021-04-17T08:06:47+08:00
[INFO] ------------------------------------------------------------------------
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>假如构建时出现类似 &lt;code>Caused by: java.lang.RuntimeException: Image generation failed. Exit code was 137 which indicates an out of memory error. Consider increasing the Xmx value for native image generation by setting the &amp;quot;quarkus.native.native-image-xmx&amp;quot; property&lt;/code> 这种报错。需要调整下 Docker 的设置，比如笔者使用的 macOS，打开 Docker Desktop &amp;gt; Preference &amp;gt; Resource &amp;gt; Advanced，将内存从默认的 2GB 调大，比如 8GB。&lt;/p>
&lt;p>从构建日志可以看出，构建的过程是在 &lt;code>quay.io/quarkus/ubi-quarkus-native-image&lt;/code> 的容器中完成的。虽然异常提示调整 &amp;ldquo;quarkus.native.native-image-xmx&amp;rdquo; ，其实是容器内存太小导致的。&lt;/p>
&lt;/blockquote>
&lt;p>构建成功后，可以在 &lt;code>target&lt;/code> 中找到 &lt;code>quarkus-getting-started-1.0.0-SNAPSHOT-runner&lt;/code>。这是一个可执行文件，大小为 28MB。&lt;/p>
&lt;p>尝试执行该文件，收到 &lt;code>zsh: exec format error: ./target/quarkus-getting-started-1.0.0-SNAPSHOT-runner&lt;/code> 错误。因为这是一个 Linux 可执行文件，因此我们需要在容器中运行。&lt;/p>
&lt;h3 id="构建本机镜像">构建本机镜像&lt;/h3>
&lt;p>在源文件的 &lt;code>src/main/docker&lt;/code> 目录中，我们可以找到 &lt;code>Dockerfile.native&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> registry.access.redhat.com/ubi8/ubi-minimal:8.3&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /work/&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> chown &lt;span class="m">1001&lt;/span> /work &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod &lt;span class="s2">&amp;#34;g+rwX&amp;#34;&lt;/span> /work &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chown 1001:root /work&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --chown&lt;span class="o">=&lt;/span>1001:root target/*-runner /work/application&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">EXPOSE&lt;/span>&lt;span class="s"> 8080&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">USER&lt;/span>&lt;span class="s"> 1001&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;./application&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;-Dquarkus.http.host=0.0.0.0&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="运行镜像">运行镜像&lt;/h3>
&lt;p>本地运行一下，可以看出启动只需要 &lt;code>0.013s&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --rm -p 8080:8080 quarkus/quarkus-getting-started:latest
__ ____ __ _____ ___ __ ____ ______
--/ __ &lt;span class="se">\/&lt;/span> / / / _ &lt;span class="p">|&lt;/span> / _ &lt;span class="se">\/&lt;/span> //_/ / / / __/
-/ /_/ / /_/ / __ &lt;span class="p">|&lt;/span>/ , _/ ,&amp;lt; / /_/ /&lt;span class="se">\ \
&lt;/span>&lt;span class="se">&lt;/span>--&lt;span class="se">\_&lt;/span>__&lt;span class="se">\_\_&lt;/span>___/_/ &lt;span class="p">|&lt;/span>_/_/&lt;span class="p">|&lt;/span>_/_/&lt;span class="p">|&lt;/span>_&lt;span class="p">|&lt;/span>&lt;span class="se">\_&lt;/span>___/___/
2021-04-17 00:22:27,146 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> quarkus-getting-started 1.0.0-SNAPSHOT native &lt;span class="o">(&lt;/span>powered by Quarkus 1.13.0.Final&lt;span class="o">)&lt;/span> started in 0.013s. Listening on: http://0.0.0.0:8080
2021-04-17 00:22:27,147 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> Profile prod activated.
2021-04-17 00:22:27,147 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> Installed features: &lt;span class="o">[&lt;/span>cdi, resteasy&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试一下端点：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">http :8080/hello/greeting/quarkus
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
Content-Length: &lt;span class="m">14&lt;/span>
Content-Type: text/plain&lt;span class="p">;&lt;/span>&lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>UTF-8
Hello, quarkus
&lt;/code>&lt;/pre>&lt;/div>&lt;p>看下镜像的信息，大小为 132MB，其中 base 镜像 &lt;code>ubi-minimal&lt;/code> 就占了 103 MB。感觉还是有点大，是否继续精简一下？&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
quarkus/quarkus-getting-started latest 8f86f5915715 &lt;span class="m">4&lt;/span> minutes ago 132MB
registry.access.redhat.com/ubi8/ubi-minimal 8.3 604ddd554fec &lt;span class="m">2&lt;/span> weeks ago 103MB
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="镜像瘦身">镜像瘦身&lt;/h3>
&lt;p>在 &lt;code>src/main/docker&lt;/code> 中还有个名为 &lt;code>Dockerfile.native-distroless&lt;/code> 的Dockerfile，里面使用了 &lt;code>quay.io/quarkus/quarkus-distroless-image:1.0&lt;/code> 作为 base 镜像&lt;/p>
&lt;p>使用这个Dockerfile进行构建，得到的镜像就小很多，只有 51MB：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
quarkus/quarkus-getting-started distroless 6fe27dd44e86 &lt;span class="m">33&lt;/span> seconds ago 51MB
quarkus/quarkus-getting-started ubi 8f86f5915715 &lt;span class="m">27&lt;/span> minutes ago 132MB
quay.io/quarkus/quarkus-distroless-image 1.0 062663862a83 &lt;span class="m">6&lt;/span> days ago 21.3MB
registry.access.redhat.com/ubi8/ubi-minimal 8.3 604ddd554fec &lt;span class="m">2&lt;/span> weeks ago 103MB
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行成功：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --rm -p 8080:8080 quarkus/quarkus-getting-started:distroless
__ ____ __ _____ ___ __ ____ ______
--/ __ &lt;span class="se">\/&lt;/span> / / / _ &lt;span class="p">|&lt;/span> / _ &lt;span class="se">\/&lt;/span> //_/ / / / __/
-/ /_/ / /_/ / __ &lt;span class="p">|&lt;/span>/ , _/ ,&amp;lt; / /_/ /&lt;span class="se">\ \
&lt;/span>&lt;span class="se">&lt;/span>--&lt;span class="se">\_&lt;/span>__&lt;span class="se">\_\_&lt;/span>___/_/ &lt;span class="p">|&lt;/span>_/_/&lt;span class="p">|&lt;/span>_/_/&lt;span class="p">|&lt;/span>_&lt;span class="p">|&lt;/span>&lt;span class="se">\_&lt;/span>___/___/
2021-04-17 00:51:26,070 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> quarkus-getting-started 1.0.0-SNAPSHOT native &lt;span class="o">(&lt;/span>powered by Quarkus 1.13.0.Final&lt;span class="o">)&lt;/span> started in 0.013s. Listening on: http://0.0.0.0:8080
2021-04-17 00:51:26,071 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> Profile prod activated.
2021-04-17 00:51:26,071 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> Installed features: &lt;span class="o">[&lt;/span>cdi, resteasy&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>极致瘦身，参考了&lt;a href="https://capgemini.github.io/development/Introduction-to-Quarkus-Supersonic-Subatomic-Java/#distroless-images">这里&lt;/a>，我们创建 &lt;code>Dockerfile.native-distroless2&lt;/code>。&lt;/p>
&lt;p>最终镜像的大小为 49MB，与官方提供的 distroless base 镜像只小了 2MB。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
quarkus/quarkus-getting-started distroless2 fe973c5ac172 &lt;span class="m">3&lt;/span> seconds ago 49MB
&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面对比，用来构建 Spring 应用的 base 镜像 &lt;code>openjdk:11.0-jre-slim&lt;/code> 已经有 220MB，这还没算上应用的大小。即使是 &lt;code>openjdk:17-alpine3.13&lt;/code> 也有 182 MB。&lt;/p>
&lt;h2 id="next">NEXT&lt;/h2>
&lt;p>下一回，我们试试 Quarkus 在 ArgoCD 中的应用，看下 Serverless 上的使用体验如何。&lt;/p></description></item><item><title>应“云”而生的 Java 框架：Hello, Quarkus</title><link>https://atbug.com/hello-quarkus/</link><pubDate>Mon, 05 Apr 2021 21:08:40 +0800</pubDate><guid>https://atbug.com/hello-quarkus/</guid><description>
&lt;p>Wikipedia上有关 Quarkus 的信息还很少，只有一句简单的介绍：&lt;/p>
&lt;blockquote>
&lt;p>Quarkus 是专为 OpenJDK HotSpot 和 GraalVM 定制的全栈 Kubernetes 原生 Java 应用程序框架。与如 Spring 之类的其他框架相比，它提供了较小的内存占用并缩短了启动时间。它允许结合命令式和非阻塞响应式编程。&lt;/p>
&lt;/blockquote>
&lt;p>从 Quarkus 的&lt;a href="https://quarkus.io/">官网&lt;/a>，可以看到其有几个特性：&lt;/p>
&lt;ul>
&lt;li>容器优先&lt;/li>
&lt;li>统一了命令式和响应式编程&lt;/li>
&lt;li>开发者友好&lt;/li>
&lt;li>最佳品种的库及标准&lt;/li>
&lt;/ul>
&lt;p>更多 Quarkus 可以参考&lt;a href="https://quarkus.io/">官网&lt;/a>的介绍及文档。今天主要就是跑一下 Quarkus 的 &lt;code>Hello world&lt;/code>。&lt;/p>
&lt;p>放一张官网的图：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/05/16176279246527.jpg" alt="">&lt;/p>
&lt;h2 id="环境准备">环境准备&lt;/h2>
&lt;ul>
&lt;li>基于 Java 11 的 GraalVM&lt;/li>
&lt;li>Maven 3.6.2+&lt;/li>
&lt;/ul>
&lt;p>笔者使用的是 macos 10.15.4，GraalVM 和 Maven 建议通过 &lt;a href="https://sdkman.io">sdkman&lt;/a> 进行安装。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ sdk install java 21.0.0.2.r11-grl &lt;span class="c1">#如果已使用其他 java 版本，可以使用命令 sdk use java 21.0.0.2.r11-grl 进行切换&lt;/span>
$ sdk install maven 3.6.3
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="验证安装">验证安装&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ java -version
openjdk version &lt;span class="s2">&amp;#34;11.0.10&amp;#34;&lt;/span> 2021-01-19
OpenJDK Runtime Environment GraalVM CE 21.0.0.2 &lt;span class="o">(&lt;/span>build 11.0.10+8-jvmci-21.0-b06&lt;span class="o">)&lt;/span>
OpenJDK 64-Bit Server VM GraalVM CE 21.0.0.2 &lt;span class="o">(&lt;/span>build 11.0.10+8-jvmci-21.0-b06, mixed mode, sharing&lt;span class="o">)&lt;/span>
$ mvn -version
Apache Maven 3.6.3 &lt;span class="o">(&lt;/span>cecedd343002696d0abb50b32b541b8a6ba2883f&lt;span class="o">)&lt;/span>
Maven home: /Users/addo/.sdkman/candidates/maven/current
Java version: 11.0.10, vendor: GraalVM Community, runtime: /Users/addo/.sdkman/candidates/java/21.0.0.2.r11-grl
Default locale: en_CN, platform encoding: UTF-8
OS name: &lt;span class="s2">&amp;#34;mac os x&amp;#34;&lt;/span>, version: &lt;span class="s2">&amp;#34;10.15.4&amp;#34;&lt;/span>, arch: &lt;span class="s2">&amp;#34;x86_64&amp;#34;&lt;/span>, family: &lt;span class="s2">&amp;#34;mac&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速开始">快速开始&lt;/h2>
&lt;h3 id="创建项目">创建项目&lt;/h3>
&lt;p>创建 quarkus 项目最快的方式是通过 &lt;code>quarkus-maven-plugin&lt;/code> 来创建，使用如下的命令快速可以创建&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ mvn io.quarkus:quarkus-maven-plugin:1.13.0.Final:create &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -DprojectGroupId&lt;span class="o">=&lt;/span>com.atbug.quickstart &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -DprojectArtifactId&lt;span class="o">=&lt;/span>quarkus-getting-started &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -DclassName&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;com.atbug.quickstart.GreetingResource&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -Dpath&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/hello&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>./quarkus-getting-started&lt;/code> 中提供了：&lt;/p>
&lt;ul>
&lt;li>maven 的项目结构&lt;/li>
&lt;li>&lt;code>com.atbug.quickstart.GreetingResource&lt;/code> 暴露了 &lt;code>/hello&lt;/code> 端点，通过 &lt;code>JAX-RS&lt;/code> 注解实现&lt;/li>
&lt;li>相关的单元测试&lt;/li>
&lt;li>应用启动后可以通过 &lt;code>http://localhost:8080&lt;/code> 打开的启动页面&lt;/li>
&lt;li>&lt;code>src/main/docker&lt;/code> 下提供了 &lt;code>native&lt;/code> 和 &lt;code>jvm&lt;/code> 风格的 Dockerfile&lt;/li>
&lt;li>应用配置文件&lt;/li>
&lt;/ul>
&lt;h3 id="运行应用">运行应用&lt;/h3>
&lt;p>执行 &lt;code>./mvnw compile quarkus:dev&lt;/code> 命令可启动应用&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">__ ____ __ _____ ___ __ ____ ______
--/ __ &lt;span class="se">\/&lt;/span> / / / _ &lt;span class="p">|&lt;/span> / _ &lt;span class="se">\/&lt;/span> //_/ / / / __/
-/ /_/ / /_/ / __ &lt;span class="p">|&lt;/span>/ , _/ ,&amp;lt; / /_/ /&lt;span class="se">\ \
&lt;/span>&lt;span class="se">&lt;/span>--&lt;span class="se">\_&lt;/span>__&lt;span class="se">\_\_&lt;/span>___/_/ &lt;span class="p">|&lt;/span>_/_/&lt;span class="p">|&lt;/span>_/_/&lt;span class="p">|&lt;/span>_&lt;span class="p">|&lt;/span>&lt;span class="se">\_&lt;/span>___/___/
2021-04-05 19:48:36,419 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>Quarkus Main Thread&lt;span class="o">)&lt;/span> quarkus-getting-started 1.0.0-SNAPSHOT on JVM &lt;span class="o">(&lt;/span>powered by Quarkus 1.13.0.Final&lt;span class="o">)&lt;/span> started in 2.135s. Listening on: http://localhost:8080
2021-04-05 19:48:36,448 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>Quarkus Main Thread&lt;span class="o">)&lt;/span> Profile dev activated. Live Coding activated.
2021-04-05 19:48:36,448 INFO &lt;span class="o">[&lt;/span>io.quarkus&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>Quarkus Main Thread&lt;span class="o">)&lt;/span> Installed features: &lt;span class="o">[&lt;/span>cdi, resteasy&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问 &lt;code>/hello&lt;/code> 断点&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ http :8080/hello
HTTP/1.1 200 OK
Content-Length: 5
Content-Type: text/plain;charset=UTF-8
Hello
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>笔者通过 &lt;code>httpie&lt;/code> 进行访问，可以通过 &lt;code>brew install httpie&lt;/code> 进行安装，推荐使用。&lt;/p>
&lt;/blockquote>
&lt;h4 id="增加新的断点">增加新的断点&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">TEXT_PLAIN&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/greeting/{name}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">greeting&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Hello, &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注：&lt;code>PathParam&lt;/code> 来自 &lt;code>org.jboss.resteasy.annotations.jaxrs.PathParam&lt;/code>&lt;/p>
&lt;p>测试：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ http :8080/hello/greeting/Quarkus
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
Content-Length: &lt;span class="m">14&lt;/span>
Content-Type: text/plain&lt;span class="p">;&lt;/span>&lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>UTF-8
Hello, Quarkus
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为新的端点增加单元测试&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="nd">@Test&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">testGreetingEndpoint&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">uuid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">UUID&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">randomUUID&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">given&lt;/span>&lt;span class="o">()&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">pathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">uuid&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">when&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/hello/greeting/{name}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">then&lt;/span>&lt;span class="o">()&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">statusCode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">200&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">body&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">is&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello, &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">uuid&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 &lt;code>./mvnw test&lt;/code> 运行单元测试&lt;/p>
&lt;blockquote>
&lt;p>注意这里使用 intellij 运行单元测试的话，会报错。需要修改 Java Compiler 的配置，添加额外的命令行参数 &lt;code>-parameters&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/05/16176241035940.jpg" alt="">&lt;/p>
&lt;/blockquote>
&lt;h3 id="打包">打包&lt;/h3>
&lt;p>与通常的 maven 项目打包方式一样，执行 &lt;code>./mvnw package&lt;/code>，在 &lt;code>target&lt;/code> 目录中：&lt;/p>
&lt;ul>
&lt;li>&lt;code>quarkus-getting-started-1.0.0-SNAPSHOT.jar&lt;/code> 仅包含了项目编译的类和资源文件，是不可执行的 jar&lt;/li>
&lt;li>&lt;code>quarkus-app&lt;/code> 目录中包含了可执行的 jar 文件 &lt;code>quarkus-run.jar&lt;/code> ，&lt;strong>但是&lt;/strong>，其并不是一个 &lt;code>über-jar&lt;/code>，项目的依赖库都位于 &lt;code>lib&lt;/code>目录中。&lt;/li>
&lt;/ul>
&lt;p>可以通过执行 &lt;code>java -jar target/quarkus-app/quarkus-run.jar&lt;/code> 在启动应用。&lt;/p>
&lt;blockquote>
&lt;p>这意味着假如你想在容器中运行，需要部署整个 &lt;code>quarkus-app&lt;/code> 目录&lt;/p>
&lt;/blockquote>
&lt;h4 id="使用-fast-jar">使用 fast-jar&lt;/h4>
&lt;p>qurakus 的打包方式有两种：&lt;code>legacy-jar&lt;/code> 和 &lt;code>fast-jar&lt;/code>。可以在 &lt;code>application.properties&lt;/code> 文件中进行指定，未显式指定默认为 &lt;code>legacy-jar&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">quarkus.package.type=fast-jar
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>如果要在容器中运行，同样需要部署整个 &lt;code>quarkus-app&lt;/code> 目录
&lt;code>fast-jar&lt;/code> 类型的包比 &lt;code>legacy-jar&lt;/code> 的包启动会快一点点，同时占用的内存也更低。因为 &lt;code>fast-jar&lt;/code> 的包含了依赖包中的类和资源文件的索引，避免在类和资源文件加载时对 classpath 下的包的查找。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>下一篇，试试构建一个原生的可执行文件。&lt;/strong>&lt;/p></description></item></channel></rss>