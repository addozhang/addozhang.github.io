<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>macos on 乱世浮生</title><link>https://atbug.com/tags/macos/</link><description>Recent content in macos on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 26 Dec 2021 12:31:16 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/macos/index.xml" rel="self" type="application/rss+xml"/><item><title>Colima：MacOS 上的极简容器运行时和 Kubernetes（支持 m1）</title><link>https://atbug.com/containers-runtime-on-macos-with-colima/</link><pubDate>Sun, 26 Dec 2021 12:31:16 +0800</pubDate><guid>https://atbug.com/containers-runtime-on-macos-with-colima/</guid><description>
&lt;p>&lt;a href="https://github.com/abiosoft/colima">Colima&lt;/a> 是一个以最小化设置来在MacOS上运行容器运行时，以及 Kubernetes。支持 m1（文末讨论），同样也支持 Linux。&lt;/p>
&lt;p>Colima 的名字取自 Container on Lima。&lt;a href="https://github.com/lima-vm/lima">Lima&lt;/a> 是一个虚拟机工具，可以实现自动的文件共享、端口转发以及 containerd。&lt;/p>
&lt;p>Colima 实际上是通过 Lima 启动了名为 &lt;code>colima&lt;/code> 的虚拟机，使用虚拟机中的 containerd 作为容器运行时。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/26/colima.gif" alt="colima">&lt;/p>
&lt;h2 id="使用">使用&lt;/h2>
&lt;p>Colima 的使用很简单，执行下面的命令就可以创建虚拟机，默认是 Docker 的运行时。&lt;/p>
&lt;p>初次运行需要下载虚拟机镜像创建虚拟机，耗时因网络情况有所差异。之后，启动虚拟机就只需要 30s 左右的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start
INFO&lt;span class="o">[&lt;/span>0000&lt;span class="o">]&lt;/span> starting colima
INFO&lt;span class="o">[&lt;/span>0000&lt;span class="o">]&lt;/span> creating and starting ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>vm
INFO&lt;span class="o">[&lt;/span>0119&lt;span class="o">]&lt;/span> provisioning ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0119&lt;span class="o">]&lt;/span> provisioning in VM ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0133&lt;span class="o">]&lt;/span> restarting VM to &lt;span class="nb">complete&lt;/span> setup ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0133&lt;span class="o">]&lt;/span> stopping ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>vm
INFO&lt;span class="o">[&lt;/span>0136&lt;span class="o">]&lt;/span> starting ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>vm
INFO&lt;span class="o">[&lt;/span>0158&lt;span class="o">]&lt;/span> starting ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0159&lt;span class="o">]&lt;/span> &lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，在宿主机上就可以使用 Docker 相关的命令了：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
docker pull busybox
docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
busybox latest b34806a1af7a &lt;span class="m">2&lt;/span> weeks ago 1.41MB
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用 Lima 的命令行 &lt;code>limact&lt;/code>工具查看虚拟机的情况：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">limactl list
NAME STATUS SSH ARCH CPUS MEMORY DISK DIR
colima Running 127.0.0.1:64505 aarch64 &lt;span class="m">2&lt;/span> 2GiB 60GiB /Users/addo/.lima/colima
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看操作系统信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">uname -a
Darwin Addos-Macbook-Pro.local 21.2.0 Darwin Kernel Version 21.2.0: Sun Nov &lt;span class="m">28&lt;/span> 20:28:41 PST 2021&lt;span class="p">;&lt;/span> root:xnu-8019.61.5~1/RELEASE_ARM64_T6000 arm64
limactl shell colima uname -a
Linux lima-colima 5.13.0-22-generic &lt;span class="c1">#22-Ubuntu SMP Fri Nov 5 13:22:27 UTC 2021 aarch64 aarch64 aarch64 GNU/Linux&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者使用 Colima 的 &lt;code>ssh&lt;/code> 命令进入虚拟机：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># on host&lt;/span>
colima ssh
&lt;span class="c1"># in vm&lt;/span>
uname -a
Linux lima-colima 5.13.0-22-generic &lt;span class="c1">#22-Ubuntu SMP Fri Nov 5 13:22:27 UTC 2021 aarch64 aarch64 aarch64 GNU/Linux&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他运行时">其他运行时&lt;/h3>
&lt;p>也可以在创建的时候通过 &lt;code>--runtime containerd&lt;/code> 参数指定使用 Containerd 作为运行时。此时就需要使用 &lt;code>colima nerdctl&lt;/code> 来使用 &lt;code>nerdctl&lt;/code> 与 Containerd 进行交互。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start --runtime containerd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样，还可以创建一个 k3s 作为 Kubernetes 运行时：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start --with-kubernetes
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="demo">Demo&lt;/h2>
&lt;p>我们尝试启动一个 nginx 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --rm -d --name nginx -p 8080:80 nginx:latest
docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
20d6c56e038b nginx:latest &lt;span class="s2">&amp;#34;/docker-entrypoint.…&amp;#34;&lt;/span> &lt;span class="m">9&lt;/span> seconds ago Up &lt;span class="m">8&lt;/span> seconds 0.0.0.0:8080-&amp;gt;80/tcp, :::8080-&amp;gt;80/tcp nginx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Colima 会自动配置端口转发：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -I http://localhost:8080
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
Server: nginx/1.21.4
Date: Sun, &lt;span class="m">26&lt;/span> Dec &lt;span class="m">2021&lt;/span> 04:17:22 GMT
Content-Type: text/html
Content-Length: &lt;span class="m">615&lt;/span>
Last-Modified: Tue, &lt;span class="m">02&lt;/span> Nov &lt;span class="m">2021&lt;/span> 14:49:22 GMT
Connection: keep-alive
ETag: &lt;span class="s2">&amp;#34;61814ff2-267&amp;#34;&lt;/span>
Accept-Ranges: bytes
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="虚拟机配置">虚拟机配置&lt;/h2>
&lt;p>Colima 启动的虚拟机默认是 2CPU、2GiB 内存 和 60GiB 存储。可以在创建时通过 &lt;code>--cpu&lt;/code> 、&lt;code>--memory&lt;/code> 和 &lt;code>--disk&lt;/code> 来分配更多资源。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start --cpu &lt;span class="m">4&lt;/span> --memory &lt;span class="m">16&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以修改当前虚拟机的配置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima stop
colima start --cpu &lt;span class="m">4&lt;/span> --memory &lt;span class="m">16&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="同类工具比较">同类工具比较&lt;/h2>
&lt;p>其实有不少类似的工具，比如 kind、k3d 和 minikube 三种都是用来创建 Kubernetes 环境。我个人此前用的 k3d 就比较多。&lt;/p>
&lt;p>对于 Docker 容器环境，这三个其实都没有提供。minikube 的虚拟机中也有容器运行时，但是无法单纯安装 Docker 环境。&lt;/p>
&lt;p>对于 Kubernetes 环境来说，这几种都适合，相比 Colima 来说还支持创建多个集群（当前 Colima 最新版本是 0.2.2，多集群的支持也在开发中。估计 0.3.0 会提供，毕竟创建多个虚拟机就能实现）。但使用 Colima 的话，Kubernetes 和 Docker 可以共享镜像（本地镜像）和运行时。&lt;/p>
&lt;h2 id="不足">不足&lt;/h2>
&lt;h3 id="多集群的支持">多集群的支持&lt;/h3>
&lt;p>前面提到，目前还不支持创建多个 Kubernetes 集群，估计 0.3.0 会提供。&lt;/p>
&lt;h3 id="m1-的支持">m1 的支持&lt;/h3>
&lt;p>这里还是要说下 m1，我现在主要用 m1 的电脑，本地的容器运行时用的 Docker Desktop。&lt;/p>
&lt;p>前面我们有留意到虚拟机使用的是 &lt;code>aarch64&lt;/code> 架构系统，&lt;strong>对于某些不支持 arm64 的镜像还是无法运行&lt;/strong>。毕竟 Lima 是原生支持 m1，而不是使用 Rosetta 转译的 Docker Desktop。&lt;/p>
&lt;p>有兴趣的同学可以尝试用 Rosetta 转译 Lima。&lt;/p></description></item><item><title>Monterey 12.0.1 上的 bug</title><link>https://atbug.com/bug-with-m1-pro-and-monterey/</link><pubDate>Thu, 18 Nov 2021 08:54:44 +0800</pubDate><guid>https://atbug.com/bug-with-m1-pro-and-monterey/</guid><description>
&lt;p>最近换上了 MacBook Pro 2021，也慢慢将工作转到新的电脑上。结束了一年多的黑白配，之前工作主力机是我的黑苹果，配置以及 OpenCore 的引导放在&lt;a href="https://github.com/addozhang/HackintoshEFI-Open">这里&lt;/a>了。&lt;/p>
&lt;p>为了稳定性，系统一直停留在了 10.15.4。新的电脑拿到手就是 12.0.1，之前也就在我另一台 2016 款的 macbook pro 上用过几个周的 12.0.0。&lt;/p>
&lt;p>新的系统加上新的架构，不免有有些 bug，今天就说下我所遇到的两个比较棘手的。&lt;/p>
&lt;h3 id="1-安全相关">1. 安全相关&lt;/h3>
&lt;blockquote>
&lt;p>EXC_BAD_ACCESS (SIGKILL (Code Signature Invalid))&lt;/p>
&lt;/blockquote>
&lt;p>公司的&lt;a href="https://github.com/flomesh-io/pipy">核心产品&lt;/a>是用 c++ 开发的，编译之后我都习惯性的放到 &lt;code>/usr/local/bin&lt;/code> 目录中。在新系统中，就出现了上面的错误（从控制台获取），运行的时候进程直接被 kill。&lt;/p>
&lt;p>网上查了下，说&lt;a href="https://apple.stackexchange.com/questions/404553/macos-compiled-binary-runs-in-build-folder-but-reports-killed-9-when-moved-to">与 kernel cache 有关&lt;/a>，重启可解决。&lt;/p>
&lt;blockquote>
&lt;p>This was caused by kernel caching of previously signed binaries and my replacing those binaries with newly compiled binaries which weren&amp;rsquo;t part of a signed package.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>By deleting the existing binaries, rebooting the Mac to clear the kernel cache, and then recopying the new binaries into place, I sorted the issue.&lt;/p>
&lt;/blockquote>
&lt;p>但是每次都要重启有点麻烦，通过与旧电脑中目录对比，最后&lt;strong>将二进制文件直接复制到 &lt;code>/opt/homebrew/bin&lt;/code> 解决&lt;/strong>，这个目录的 ownership 不是 root 的。&lt;/p>
&lt;p>如果问题还会出现，可以做一个软链接将二进制文件链接到 &lt;code>/opt/homebrew/bin&lt;/code> 下。&lt;/p>
&lt;h3 id="2-clang-版本">2. Clang 版本&lt;/h3>
&lt;p>这个问题也是排查了版本，还是使用公司产品的时候遇到的。当处理的 JSON 中包含数组，比如 &lt;code>{&amp;quot;a&amp;quot;: []}&lt;/code>，应用启动失败。从控制台来看，错误码是 &lt;code>EXC_BAD_ACCESS (SIGSEGV)&lt;/code>，报错的堆栈正好是在处理 JSON array。&lt;/p>
&lt;p>有问题的版本：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">Apple clang version 13.0.0 (clang-1300.0.29.3)
Target: arm64-apple-darwin21.1.0
Thread model: posix
InstalledDir: /Library/Developer/CommandLineTools/usr/bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>正常的版本：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">Apple clang version 12.0.0 (clang-1200.0.32.29)
Target: arm64-apple-darwin20.1.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后在构建的时候，将 &lt;code>CMAKE_BUILD_TYPE&lt;/code> 设置为 &lt;code>Debug&lt;/code> 临时解决。Debug 模式下编译器不做任何优化。&lt;/p>
&lt;p>期待系统升级能够修复。&lt;/p></description></item><item><title>Kubernetes学习 — Macos安装Kubernetes</title><link>https://atbug.com/install-kubernetes-on-macos/</link><pubDate>Thu, 17 Aug 2017 09:44:17 +0000</pubDate><guid>https://atbug.com/install-kubernetes-on-macos/</guid><description>
&lt;h1 id="kubernetes">Kubernetes&lt;/h1>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h2 id="macos">macos&lt;/h2>
&lt;h3 id="检查环境">检查环境&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">sysctl -a &lt;span class="p">|&lt;/span> grep machdep.cpu.features &lt;span class="p">|&lt;/span> grep VMX
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装virtualbox">安装VirtualBox&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">http://download.virtualbox.org/virtualbox/5.1.26/Oracle_VM_VirtualBox_Extension_Pack-5.1.26-117224.vbox-extpack
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装minikube">安装minikube&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.21.0/minikube-darwin-amd64 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod +x minikube &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo mv minikube /usr/local/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建集群">创建集群&lt;/h3>
&lt;p>默认使用virtualbox。&lt;/p>
&lt;p>主机的ip是&lt;code>192.168.31.186&lt;/code>， &lt;code>1087&lt;/code>是proxy的端口。需要将ss的http代理监听地址从&lt;code>127.0.0.1&lt;/code>改为主机的ip。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#启动&lt;/span>
minikube start
&lt;span class="c1">#使用私有库&lt;/span>
minikube start --insecure-registry&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.34&amp;#34;&lt;/span>
&lt;span class="c1">#使用proxy，用于获取镜像&lt;/span>
minikube start --docker-env &lt;span class="nv">HTTP_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.186:1087&amp;#34;&lt;/span> --docker-env &lt;span class="nv">HTTPS_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.186:1087&amp;#34;&lt;/span> --docker-env &lt;span class="nv">NO_PROXY&lt;/span>&lt;span class="o">=&lt;/span>192.168.99.0/24
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装kubectl">安装kubectl&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -Lo kubectl http://storage.googleapis.com/kubernetes-release/release/v1.7.3/bin/darwin/amd64/kubectl &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod +x kubectl &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo mv kubectl /usr/local/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="oh-my-zsh-tab-completion">oh-my-zsh tab completion&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">vi ~/.zshrc
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>添加到plugin部分&lt;br>
plugins=(git zsh-completions kubectl)&lt;/p>
&lt;/blockquote>
&lt;h2 id="使用">使用&lt;/h2>
&lt;h3 id="minikube">minikube&lt;/h3>
&lt;h4 id="检查版本">检查版本&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube version
&lt;span class="c1">#minikube version: v0.21.0&lt;/span>
kubectl version
&lt;span class="c1">#Client Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;3&amp;#34;, GitVersion:&amp;#34;v1.3.0&amp;#34;, GitCommit:&amp;#34;283137936a498aed572ee22af6774b6fb6e9fd94&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2016-07-01T19:26:38Z&amp;#34;, GoVersion:&amp;#34;go1.6.2&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;darwin/amd64&amp;#34;}&lt;/span>
&lt;span class="c1">#Server Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;7&amp;#34;, GitVersion:&amp;#34;v1.7.0&amp;#34;, GitCommit:&amp;#34;d3ada0119e776222f11ec7945e6d860061339aad&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2017-07-26T00:12:31Z&amp;#34;, GoVersion:&amp;#34;go1.8.3&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;linux/amd64&amp;#34;}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="获取集群地址">获取集群地址&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube ip
192.168.99.100
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取服务列表">获取服务列表&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube service list
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="打开dashboard">打开dashboard&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube dashboard
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kubectl">kubectl&lt;/h2>
&lt;h4 id="部署dashboard-ui">部署Dashboard UI&lt;/h4>
&lt;p>默认minikube会自动部署dashboard&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="启动proxy">启动proxy&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl proxy
&lt;span class="c1">#Starting to serve on 127.0.0.1:8001&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="获取pod信息">获取pod信息&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get pods --namespace kube-system
NAME READY STATUS RESTARTS AGE
kube-addon-manager-minikube 0/1 Running &lt;span class="m">0&lt;/span> 1h
kubernetes-dashboard-3313488171-90s64 0/1 Running &lt;span class="m">0&lt;/span> 20m
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果STATUS一直处于&lt;strong>ContainerCreating&lt;/strong>状态，应该是pull image失败。默认是去gcr.io拉镜像，被墙了。需要在启动minikube的时候设置docker使用的代理。&lt;/p>
&lt;h4 id="获取pod详细信息">获取pod详细信息&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">kubectl describe pod kubernetes-dashboard-3313488171-90s64 --namespace kube-system
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="查看log">查看log&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl logs -f kubernetes-dashboard-3313488171-90s64
&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>