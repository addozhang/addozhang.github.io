<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OpenRewrite on 乱世浮生</title><link>https://atbug.com/tags/openrewrite/</link><description>Recent content in OpenRewrite on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 05 Apr 2025 23:43:59 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/openrewrite/index.xml" rel="self" type="application/rss+xml"/><item><title>一条命令搞定！存量 Spring REST 服务秒变 MCP 服务</title><link>https://atbug.com/one-command-to-convert-legacy-spring-rest-services-to-mcp-services/</link><pubDate>Sat, 05 Apr 2025 23:43:59 +0800</pubDate><guid>https://atbug.com/one-command-to-convert-legacy-spring-rest-services-to-mcp-services/</guid><description>TL;DR 在 AI 技术浪潮中，MCP 为服务集成带来了创新性思路，LLM 与 MCP 的组合更是为存量 API 服务注入新活力。
本文先阐述基于 Spring AI MCP 开发 MCP 服务的详细步骤，随后引入 OpenRewrite 框架及其 spring-rest-to-mcp 工具，实现 Spring REST 服务到 MCP 服务的自动化转换。
最后，借助示例项目，全方位展示从环境搭建、代码转换到任务编排执行的完整流程，助力开发者快速打通存量 Spring REST 服务对接 MCP 协议的通道，大幅提升服务集成的灵活性与智能化水平 。
背景 在上一篇 超越 API：MCP 如何成为 AI 时代的 “万能适配器”？ 文章发布后，我一直思考一件事。如果将以往的 API 集成看作系统的硬链接，那么 LLM + MCP 无疑是系统的软链接。MCP 的诞生，使我们能在运行时动态连接不同服务，摆脱设计阶段的束缚，实现更为灵活、智能的服务集成模式。</description></item><item><title>OpenRewrite 学习笔记（四）：使用 JavaTemplate 创建复杂 LST</title><link>https://atbug.com/openrewrite-learning-notes-4-creating-complex-lst-with-javatemplate/</link><pubDate>Sun, 19 Jan 2025 11:24:20 +0800</pubDate><guid>https://atbug.com/openrewrite-learning-notes-4-creating-complex-lst-with-javatemplate/</guid><description>LST 是 OpenRewrite 的核心，是 OpenRewrite 实现精准、可控代码修改的关键支柱。本文将介绍如何使用 JavaTemplate 创建复杂的 LST。
背景 在操作代码的过程中，可能需要添加、修改、删除代码片段。比如添加一个变量声明、添加一个方法、修改一个方法体等。这些操作都需要创建 LST（Lossless Semantic Tree）。那如何创建一个变量声明的 LST？
我们需要创建变量声明 J.VariableDeclarations 以及变量 J.VariableDeclarations.NamedVariable，并将其添加到方法体中。看起来很简单，但是在使用构造器初始化对象时需要提供很多参数。何况很多参数自身的初始化也是一个复杂的过程，需要保证类型的属性匹配准确。
实际上不需要这么麻烦，也是 官方不推荐的方式。OpenRewrite 提供了 JavaTemplate 来简化这个过程。
JavaTemplate javaTemplate = JavaTemplate.builder(&amp;#34;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&amp;#34;) .build(); 上面的代码片段中，通过 JavaTemplate 构建了一个变量声名赋值的 LST。使用 JavaTemplate 可以生成格式准确、类型属性完整的 LST，而不需要手动构造。</description></item><item><title>OpenRewrite 学习笔记（三）：重构配方 Recipe 与访问者 Visitor</title><link>https://atbug.com/openrewrite-learning-notes-3-refactoring-recipe-and-visitor/</link><pubDate>Fri, 20 Dec 2024 07:11:14 +0800</pubDate><guid>https://atbug.com/openrewrite-learning-notes-3-refactoring-recipe-and-visitor/</guid><description>今天这篇我们来学习配方 Recipe 和访问者 Visitor，之所以一起介绍这两个是因为在 Recipe 的设计中使用了 访问者模式（Visitor Pattern）。
访问者模式是一种将算法与对象结构分开的软件设计模式。得益于这种分离，在将新操作添加到现有对象结构中时，无需修改对象结构。它是面向对象编程和软件工程中遵循开放/封闭原则的一种方法。
&amp;ndash; 维基百科
配方 Recipes 配方（Recipe）是一组可对 无损语义树（LST） 执行搜索和重构操作的逻辑集合。配方既可以代表一个独立的微小变更，也可以与其他配方组合，形成实现更复杂目标（如框架迁移）的大型改造方案。
OpenRewrite 提供了一个托管环境，用于发现、实例化和配置配方。在实现搜索或重构操作时，配方会委托给访问者（Visitor），由其负责抽象语法树（LST）的遍历和操作。
在第一篇的快速上手中，我们使用了配方 ChangeMethodName 将方法 hello 名改为 gretting。
扫描配方 Scanning Recipe 这是一个特别的 Recipe。如果一个 Recipe 需要生成新的源文件或者需要在进行更改前查看所有源文件，那它必须是 ScanningRecpie。
在实现层面 ScanningRecipe 扩展了 Recipe ，添加两个关键对象：accumulator 和 scanner。
accumulator 是由 Recipe 自身来定义的数据结构，用于存储 Recipe 运行时所需的任何信息。 scanner 是一个用数据来填充 accumulator 的 Visitor #visitor 除了两个对象外，ScanningRecipe 还提供了方法定义 getScanner() 这个方法需要子类来实现，返回值也是一个访问者 Visitor（在后面我们会介绍）。</description></item><item><title>OpenRewrite 学习笔记（二）：无损语义树 LST</title><link>https://atbug.com/openrewrite-lossless-semantic-tree-lst-overview/</link><pubDate>Sun, 08 Dec 2024 13:36:09 +0800</pubDate><guid>https://atbug.com/openrewrite-lossless-semantic-tree-lst-overview/</guid><description>在上一篇文章中我们提到，LST 是 OpenRewrite 实现精准、可控代码修改的关键支柱。本篇将更深入地探讨 OpenRewrite 在代码解析过程中，究竟是如何保留代码原有的精确语义结构的。
什么是 LST LST 是 Lossless Semantic Trees，无损语义树的缩写。
先上总结，说说我对这三个单词的理解：
Lossless 无损：代码解析和结构化过程中不丢失源代码中的任何信息（包括空格、注释、格式等），最终的属性结构中可以保留代码的原始细节。 Semantic（语义）：该树不仅仅是语法分析的产物，还能体现代码片段之间的语义关系。 Trees（树）：以树形结构组织代码元素，使得对代码片段的遍历、查询和变换更为直观且层次清晰。 说起语义树，就不得不提一下 AST。
抽象语法树 AST AST（Abstract Sytax Tree，抽象语法树），又常被称为语法树（Sytax Tree），是以树状的形式来表示编程语言的语法结构。AST 是编译器中广泛使用的的数据结构，用于表示程序代码的结构。
像下面的 AST 图是这段代码（欧几里得算法）的抽象语法树结构展示，树上的每个节点都表示源码中的一种结构。
while b ≠ 0: if a &amp;gt; b: a := a - b else: b := b - a return a 无损语义树 LST OpenRewrite 的 LST（无损语义树）具备一系列独特特性，使得在跨存储库的场景中依然能实现精确的代码搜索和转换：</description></item><item><title>OpenRewrite 学习笔记（一）：基本知识与原理解析</title><link>https://atbug.com/openrewrite-basics-and-principles-overview/</link><pubDate>Sun, 08 Dec 2024 13:31:20 +0800</pubDate><guid>https://atbug.com/openrewrite-basics-and-principles-overview/</guid><description>最近的工作多与系统改造相关，涉及框架与平台的迁移。偶然接触到 OpenRewrite 这款有趣的工具，于是打算整理一些学习笔记，也是对学习过程的记录。后续还会持续探索并更新文章，只是目前尚不确定会写多少篇。
随着软件项目日趋复杂、版本迭代和新技术引进的加快，工程师往往需要对成千上万行的代码进行统一风格化处理、批量重构或版本迁移。然而手动完成这些工作不仅费时费力，而且容易遗漏。大规模场景下，整个过程像是一个大的工程实施，因此就有了 Migration Engineering。
Migration Engineering 迁移工程是一种系统化的工程实践，广泛应用于技术栈更新、代码现代化、架构优化和大规模变更管理。通过自动化工具和流程的结合，它能够在确保质量的同时减少人工介入，从而提高效率，降低风险，并确保代码库在技术演进中保持一致性。
From ChatGPT 为了实现精确可控且可重复的代码自动化重构（Automated Refactoring），出现了多种工具和框架。OpenRewrite 正是其中备受关注的一个，它能帮助开发者在大规模代码重构中以一种结构化、可持续和可扩展的方式对代码进行批量改写和重构，从而提升开发团队的生产力和代码质量。
接下来，和我一起从从基础认识入手，了解什么是 OpenRewrite 以及它所依据的基本原理。
什么是 OpenRewrite OpenRewrite 是由 Moderne 公司开源的自动化重构框架。它的目标是通过一系列可组合的“配方”（官方术语 Recipes，可以理解为重构规则，为了更贴近官方文档的术语，将其翻译为配方。）在无需手动干预的情况下对代码进行有条理的结构重写。简言之，它不是简单的全局替换字符串工具，而是能基于 无损语义树（LST） 进行语义级别的代码修改。
应用场景 在深入原理之前，我们先来看几个常见的场景，这能帮助我们理解为什么要使用 OpenRewrite：
统一代码风格和格式化规则： 当团队决定采用统一的代码风格（如使用特定的命名规范、去除不必要的注释、多余的空格或换行），可以通过 OpenRewrite 的规则对全仓库进行自动化的清理。 批量升级依赖版本和框架迁移： 想象你维护着一个庞大的微服务体系结构，需要从 Spring Boot 2.x 升级到 3.x，这往往意味着在几十个甚至上百个仓库中同步修改数百个依赖项。OpenRewrite 可以通过一条 Recipe 来自动化完成这些变更。 统一日志框架或安全库： 如果团队决定弃用某个日志库或安全框架，需要全仓库替换相关调用。手动修改非常繁琐，而 OpenRewrite 能确保精确定位和替换代码。 遗留代码现代化： 对老旧项目的遗留代码进行现代化改造，例如将早期的 Java 语言特性（如匿名内部类）改为更现代的 Lambda 表达式，将旧的集合框架替换为流式处理 API，快速为老系统注入新特性和代码规范。 关键特性 语法级与语义级分析：基于 LST 进行代码解析，确保代码修改的精准性。 可扩展的配方（Recipes）：提供大量内置和可扩展的规则集，用于自动化处理常见的代码问题。配方可与其他配方组合成更复杂的配方。 语言与框架的广泛支持：编程语言如 Java、Kotlin、Groovy；数据格式：XML、YAML、Properties、JSON、ProtoBuf；构建工具 Maven、Gradle；框架：Quarkus、Spring、Micronaut、Jakarta。 如果说 Recipe 是 OpenRewrite 进行自动化重构的核心机制，那么 LST 就是是确保代码在重构时具备精确语义结构的基石。</description></item></channel></rss>