<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes on 乱世浮生</title><link>https://atbug.com/tags/kubernetes/</link><description>Recent content in Kubernetes on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 07 Feb 2022 01:00:29 +0800</lastBuildDate><atom:link href="https://atbug.com/tags/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>探秘 k8e：极简 Kubernetes 发行版</title><link>https://atbug.com/explore-simple-kubernetes-distribution/</link><pubDate>Mon, 07 Feb 2022 01:00:29 +0800</pubDate><guid>https://atbug.com/explore-simple-kubernetes-distribution/</guid><description>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>本文介绍并安装体验了极简 Kubernetes 发行版，也顺便分析学习下编译的流程。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>&lt;a href="https://github.com/xiaods/k8e">k8e&lt;/a> 本意为 &lt;em>kuber easy&lt;/em>，是一个 Kubernetes 的极简发行版，意图让云原生落地部署 Kubernetes 更轻松。k8e 是基于另一个发行版 &lt;a href="https://github.com/rancher/k3s">k3s&lt;/a> ，经过裁剪（去掉了 Edge/IoT 相关功能、traefix等）、扩展（加入 ingress、sidecar 实现、cilium等）而来。&lt;/p>
&lt;p>k8e 具有以下特性：&lt;/p>
&lt;ul>
&lt;li>单二进制文件，集成了 k8s 的各种组件、containerd、runc、kubectl、nerdctl 等&lt;/li>
&lt;li>使用 cilium 作为 cni 的实现，方便 eBPF 的快速落地&lt;/li>
&lt;li>支持基于 pipy 的 ingress、sidecar proxy，实现应用流量一站式管理&lt;/li>
&lt;li>只维护一个 k8s 版本，目前是 1.21&lt;/li>
&lt;li>按照私有云的经验增加、优化代码&lt;/li>
&lt;/ul>
&lt;p>得益于这些特性，k8e 非常适合CI、开发和企业级部署，单机版的集群适合技术验证环境。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/02/07/16441611053071.png" alt="组件架构图">&lt;/p>
&lt;h2 id="安装测试">安装测试&lt;/h2>
&lt;p>可以从 GitHub 上下载对应版本的&lt;a href="https://github.com/xiaods/k8e/releases">二进制文件&lt;/a>，也可以自己手动编译（后面对编译的流程进行了简单的分析）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">sudo k8e check-config
sudo k8e server &lt;span class="p">&amp;amp;&lt;/span>
&lt;span class="c1"># Kubeconfig is written to /etc/k8e/k8e.yaml&lt;/span>
&lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>/etc/k8e/k8e.yaml
&lt;span class="c1"># On a different node run the below. NODE_TOKEN comes from&lt;/span>
&lt;span class="c1"># /var/lib/k8e/server/node-token on your server&lt;/span>
sudo k8e agent --server https://myserver:6443 --token &lt;span class="si">${&lt;/span>&lt;span class="nv">NODE_TOKEN&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="c1"># query all node from k8s cluster&lt;/span>
sudo k8e kubectl get nodes
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为没有提供默认的 cni 实现，此时 pod 都处于 &lt;code>Pending&lt;/code> 状态。需要手动安装 cilium：&lt;/p>
&lt;p>通过 &lt;code>k8e check-config&lt;/code> 可以找到 builddata 目录：&lt;code>/var/lib/k8e/data/5a7ced03412504a18bf3f49cbee5dafca7187d86ef8fdaa789448d53d7fbb823&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">/var/lib/k8e/data/5a7ced03412504a18bf3f49cbee5dafca7187d86ef8fdaa789448d53d7fbb823/bin/cilium install
&lt;/code>&lt;/pre>&lt;/div>&lt;p>cilium 安装成功后 Pod 成功运行，可以查看 cilium 状态：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">/var/lib/k8e/data/5a7ced03412504a18bf3f49cbee5dafca7187d86ef8fdaa789448d53d7fbb823/bin/cilium status
/¯¯&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> /¯¯&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\ &lt;/span> Cilium: OK
&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\_&lt;/span>_/ Operator: OK
/¯¯&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\ &lt;/span> Hubble: disabled
&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\_&lt;/span>_/ ClusterMesh: disabled
&lt;span class="se">\_&lt;/span>_/
DaemonSet cilium Desired: 1, Ready: 1/1, Available: 1/1
Deployment cilium-operator Desired: 1, Ready: 1/1, Available: 1/1
Containers: cilium Running: &lt;span class="m">1&lt;/span>
cilium-operator Running: &lt;span class="m">1&lt;/span>
Cluster Pods: 3/3 managed by Cilium
Image versions cilium quay.io/cilium/cilium:v1.10.5: &lt;span class="m">1&lt;/span>
cilium-operator quay.io/cilium/operator-generic:v1.10.5: &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者执行 &lt;code>cilium connectivity test&lt;/code> 进行检查网络。&lt;/p>
&lt;p>&lt;strong>上面是作为开发验证环境的部署，若要部署标准 Kubernetes，可以参考&lt;a href="https://getk8e.com/docs/install/quick-start/">官方文档&lt;/a>。&lt;/strong>&lt;/p>
&lt;h2 id="编译流程分析">编译流程分析&lt;/h2>
&lt;p>k8e 的编译部署简单的两条命令就能完成：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">make generate
make
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行 &lt;code>make generate&lt;/code> 下载内置的几个工具：&lt;code>runc&lt;/code>、&lt;code>nerdctl&lt;/code>、&lt;code>cilium&lt;/code>，保存在 &lt;code>bin&lt;/code> 目录中。&lt;/p>
&lt;p>&lt;code>.DEFAULT_GOAL&lt;/code> 是 &lt;code>ci&lt;/code>，执行 &lt;code>make&lt;/code> 则会执行 target &lt;code>ci&lt;/code> 。&lt;/p>
&lt;h3 id="dapper">Dapper&lt;/h3>
&lt;p>在 &lt;em>makefile&lt;/em> 的第一行是 &lt;code>TARGETS := $(shell ls hack | grep -v \\.sh | grep -v package-airgap| grep -v clean)&lt;/code> 定义了变量 &lt;code>TARGETS&lt;/code>，然后 &lt;code>$(TARGETS): .dapper&lt;/code> 为几个 target 指定前置条件。其中就有 &lt;code>ci&lt;/code>，因此在执行 &lt;code>ci&lt;/code> 之前会先执行 target &lt;code>.dapper&lt;/code>。&lt;/p>
&lt;p>target &lt;code>.dapper&lt;/code> 用于下载 &lt;a href="https://github.com/rancher/dapper">rancher dapper&lt;/a>。dapper 是 Docker 的构建封装器，执行时会使用位于源码根目录 &lt;code>Dockerfile.dapper&lt;/code> 构建镜像，并以此作为代码构建环境。&lt;/p>
&lt;p>在 &lt;code>Dockerfile.dapper&lt;/code> 中，会准备构建环境，以及几个需要关注的设置：&lt;/p>
&lt;ul>
&lt;li>&lt;code>WORKDIR&lt;/code>：&lt;code>/go/src/github.com/xiaods/k8e/&lt;/code>，也就是容器的工作目录。&lt;code>dapper&lt;/code> 启动时会将源码内容拷贝到容器中&lt;/li>
&lt;li>&lt;code>ENTRYPOINT&lt;/code>：&lt;code>[&amp;quot;./hack/entry.sh&amp;quot;]&lt;/code>，容器启动的 entrypoint。&lt;/li>
&lt;li>&lt;code>CMD&lt;/code>：&lt;code>[&amp;quot;ci&amp;quot;]&lt;/code>，容器运行时的默认 CMD&lt;/li>
&lt;li>&lt;code>ENV&lt;/code>
&lt;ul>
&lt;li>&lt;code>DAPPER_SOURCE&lt;/code>：&lt;code>/go/src/github.com/xiaods/k8e/&lt;/code>&lt;/li>
&lt;li>&lt;code>DAPPER_OUTPUT&lt;/code>：&lt;code>./bin ./dist ./build/out&lt;/code>，构建完成后，会执行 &lt;code>docker cp ${DAPPER_SOURCE}/${DAPPER_OUTPUT} .&lt;/code> 将容器中的内容拷贝到容器外。&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>dapper&lt;/em> 下载完成后会执行 &lt;code>ci&lt;/code> 的命令：&lt;code>./.dapper ci&lt;/code>，根据 &lt;code>Dockerfile.dapper&lt;/code> 的配置，启动后会执行 &lt;code>./hack/entry.sh ci&lt;/code>。&lt;/p>
&lt;h3 id="ci">CI&lt;/h3>
&lt;p>CI 的流程与 k3s 的流程相比精简了很多。在 &lt;code>./hack/ci&lt;/code> 中，会依次执行：&lt;/p>
&lt;ul>
&lt;li>./hack/validate：代码格式化、校验&lt;/li>
&lt;li>./hack/build：代码编译&lt;/li>
&lt;li>./hack/package：将前面下载、编译的 &lt;code>bin/&lt;/code> 目录下的二进制一同打包到同一个二进制文件中（使用 &lt;a href="https://github.com/go-bindata/go-bindata">go-bindata&lt;/a>）。&lt;/li>
&lt;li>./hack/binary_size_check.sh：二进制文件大小的检查，是否超过 81 M（k3s 的是64M，由于加入了 cilium 等 cli，体积会有增加）。&lt;/li>
&lt;/ul></description></item><item><title>追踪 Kubernetes 中的网络流量</title><link>https://atbug.com/tracing-path-of-kubernetes-network-packets/</link><pubDate>Sat, 22 Jan 2022 10:15:31 +0800</pubDate><guid>https://atbug.com/tracing-path-of-kubernetes-network-packets/</guid><description>
&lt;p>译者注：&lt;/p>
&lt;p>这篇文章很全面的罗列出了 Kubernetes 中涉及的网络知识，从 Linux 内核的网络内容，到容器、Kubernetes，一一进行了详细的说明。&lt;/p>
&lt;p>​文章篇幅有点长，不得不说，网络是很复杂很麻烦的一层，但恰恰这层多年来变化不大。希望翻译的内容对大家能有所帮助，有误的地方，也欢迎大家指正。&lt;/p>
&lt;p>本文翻译获得 Learnk8s 的授权，原文 &lt;a href="https://learnk8s.io/kubernetes-network-packets">Tracing the path of network traffic in Kubernetes&lt;/a> 作者 Kristijan Mitevski。&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427680911539.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>TL;DR：&lt;/strong> &lt;em>本文将代理了解 Kubernetes 集群内外的数据流转。从最初的 Web 请求开始，一直到托管应用程序的容器。&lt;/em>&lt;/p>
&lt;h2 id="目录">目录&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#%E7%9B%AE%E5%BD%95">目录&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kubernetes-%E7%BD%91%E7%BB%9C%E8%A6%81%E6%B1%82">Kubernetes 网络要求&lt;/a>&lt;/li>
&lt;li>&lt;a href="#linux-%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A6%82%E6%9E%9C%E5%9C%A8-pod-%E4%B8%AD%E5%B7%A5%E4%BD%9C">Linux 网络命名空间如果在 pod 中工作&lt;/a>&lt;/li>
&lt;li>&lt;a href="#pause-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA-pod-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">Pause 容器创建 Pod 中的网络命名空间&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%B8%BA-pod-%E5%88%86%E9%85%8D%E4%BA%86-ip-%E5%9C%B0%E5%9D%80">为 Pod 分配了 IP 地址&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A3%80%E6%9F%A5%E9%9B%86%E7%BE%A4%E4%B8%AD-pod-%E5%88%B0-pod-%E7%9A%84%E6%B5%81%E9%87%8F">检查集群中 pod 到 pod 的流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#pod-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A1%A5%E6%8E%A5%E5%99%A8">Pod 命名空间连接到以太网桥接器&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%B7%9F%E8%B8%AA%E5%90%8C%E4%B8%80%E8%8A%82%E7%82%B9%E4%B8%8A-pod-%E9%97%B4%E7%9A%84%E6%B5%81%E9%87%8F">跟踪同一节点上 pod 间的流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%B7%9F%E8%B8%AA%E4%B8%8D%E5%90%8C%E8%8A%82%E7%82%B9%E4%B8%8A-pod-%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">跟踪不同节点上 pod 间的通信&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">位运算的工作原理&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3---cni">容器网络接口 - CNI&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A3%80%E6%9F%A5-pod-%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B5%81%E9%87%8F">检查 pod 到服务的流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%BD%BF%E7%94%A8-netfilter-%E5%92%8C-iptables-%E6%8B%A6%E6%88%AA%E5%92%8C%E9%87%8D%E5%86%99%E6%B5%81%E9%87%8F">使用 Netfilter 和 Iptables 拦截和重写流量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%93%8D%E5%BA%94">检查服务的响应&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%9B%9E%E9%A1%BE">回顾&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes-网络要求">Kubernetes 网络要求&lt;/h2>
&lt;p>在深入了解 Kubernetes 中的数据流转之前，让我们先澄清下 Kubernetes 网络的要求。&lt;/p>
&lt;p>Kubernetes 网络模型定义了一套基本规则：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>集群中的 pod 应该能够与任何其他 pod 自由通信&lt;/strong>，而无需使用网络地址转换（NAT）。&lt;/li>
&lt;li>在不使用 NAT 的情况下，&lt;strong>集群节点上运行的任意程序都应该能够与同一节点上的任意 pod 通信&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>每个 pod 都有自己的 IP 地址&lt;/strong>（IP-per Pod），其他 pod 都可以使用同一个地址进行访问。&lt;/li>
&lt;/ul>
&lt;p>这些要求不会将实现限制在单一方案上。&lt;/p>
&lt;p>相反，他们概括了集群网络的特性。&lt;/p>
&lt;p>在满足这些限制时，必须解决如下&lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/network/networking.md">挑战&lt;/a>：&lt;/p>
&lt;ol>
&lt;li>&lt;em>如何保证同一 pod 中的容器间的访问就像在同一主机上一样？&lt;/em>&lt;/li>
&lt;li>&lt;em>Pod 能否访问集群中的其他 pod？&lt;/em>&lt;/li>
&lt;li>&lt;em>Pod 能否访问服务（service）？以及服务可以负载均衡请求吗？&lt;/em>&lt;/li>
&lt;li>&lt;em>Pod 可以接收来自集群外的流量吗？&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>本文将专注于前三点，从 pod 内部网络或者容器间的通信说起。&lt;/p>
&lt;h2 id="linux-网络命名空间如果在-pod-中工作">Linux 网络命名空间如果在 pod 中工作&lt;/h2>
&lt;p>我们想象下，有一个承载应用程序的主容器和另一个与它一起运行的容器。&lt;/p>
&lt;p>在示例 Pod 中有一个 Nginx 容器和 busybox 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">multi-container-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">container-1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;/bin/sh&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;-c&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;sleep 1d&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">container-2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在部署时，会出现如下情况：&lt;/p>
&lt;ol>
&lt;li>Pod 在节点上得到&lt;strong>自己的网络命名空间&lt;/strong>。&lt;/li>
&lt;li>Pod &lt;strong>分配到一个 IP 地址&lt;/strong>，两个容器间共享端口。&lt;/li>
&lt;li>&lt;strong>两个容器共享同一个网络命名空间&lt;/strong>，在本地互相可见。&lt;/li>
&lt;/ol>
&lt;p>网络配置在后台很快完成。&lt;/p>
&lt;p>然后，我们退后一步，是这理解&lt;em>为什么&lt;/em>上面是容器运行所必须的。&lt;/p>
&lt;p>&lt;a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">在 Linux 中，网络命名空间是独立的、隔离的逻辑空间。&lt;/a>&lt;/p>
&lt;p>可以将网络命名空间堪称将物理网络接口分割成更小的独立部分。&lt;/p>
&lt;p>每部分都可以单独配置，并使用自己的网络规则和资源。&lt;/p>
&lt;p>这些可以包括防火墙规则、接口（虚拟或物理）、路由和其他所有与网络相关的内容。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>物理接口持有根命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427699864958.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以使用 Linux 网络命名空间创建隔离的网络。每个网络都是独立的，除非进行配置否则不会与其他命名空间通信。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427700613518.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>物理接口必须处理最后的所有&lt;em>真实&lt;/em>数据包，因此所有的虚拟接口都是从中创建的。&lt;/p>
&lt;p>网络命名空间可以通过 &lt;a href="https://man7.org/linux/man-pages/man8/ip-netns.8.html">&lt;code>ip-netns&lt;/code> 管理工具&lt;/a> 来管理，可以使用 &lt;code>ip netns list&lt;/code> 列出主机上的命名空间。&lt;/p>
&lt;blockquote>
&lt;p>请注意，创建的网络命名空间将会出现在 &lt;code>/var/run/netns&lt;/code> 目录下，但 &lt;a href="https://www.packetcoders.io/how-to-view-the-network-namespaces-in-kubernetes/">Docker 并没有遵循这一点&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>例如，下面是 Kubernetes 节点的命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns list
cni-0f226515-e28b-df13-9f16-dd79456825ac &lt;span class="o">(&lt;/span>id: 3&lt;span class="o">)&lt;/span>
cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd &lt;span class="o">(&lt;/span>id: 4&lt;span class="o">)&lt;/span>
cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e &lt;span class="o">(&lt;/span>id: 2&lt;span class="o">)&lt;/span>
cni-7619c818-5b66-5d45-91c1-1c516f559291 &lt;span class="o">(&lt;/span>id: 1&lt;span class="o">)&lt;/span>
cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8 &lt;span class="o">(&lt;/span>id: 0&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意 &lt;code>cni-&lt;/code> 前缀意味着命名空间的创建由 CNI 来完成。&lt;/p>
&lt;/blockquote>
&lt;p>当创建 pod 并分配给节点时，&lt;a href="https://github.com/containernetworking/cni#what-is-cni">CNI&lt;/a> 会：&lt;/p>
&lt;ol>
&lt;li>为其创建网络命名空间。&lt;/li>
&lt;li>分配 IP 地址。&lt;/li>
&lt;li>将容器连接到网络。&lt;/li>
&lt;/ol>
&lt;p>如果 pod 像上面的示例一样包含多个容器，则所有容器都被置于同一个命名空间中。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建 pod 时，CNI 为容器创建网络命名空间&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427706567489.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后分配 IP 地址&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427707025246.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后将容器连接到网络的其余部分&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427710287189.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;em>那么当列出节点上的容器时会看到什么？&lt;/em>&lt;/p>
&lt;p>可以 SSH 到 Kubernetes 节点来查看命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ lsns -t net
NS TYPE NPROCS PID USER NETNSID NSFS COMMAND
&lt;span class="m">4026531992&lt;/span> net &lt;span class="m">171&lt;/span> &lt;span class="m">1&lt;/span> root unassigned /run/docker/netns/default /sbin/init noembed norestore
&lt;span class="m">4026532286&lt;/span> net &lt;span class="m">2&lt;/span> &lt;span class="m">4808&lt;/span> &lt;span class="m">65535&lt;/span> &lt;span class="m">0&lt;/span> /run/docker/netns/56c020051c3b /pause
&lt;span class="m">4026532414&lt;/span> net &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> &lt;span class="m">1&lt;/span> /run/docker/netns/7db647b9b187 /pause
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>lsns&lt;/code> 命令会列出主机上&lt;em>所有&lt;/em>的命名空间。&lt;/p>
&lt;blockquote>
&lt;p>记住 Linux 中有&lt;a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">多种命名空间类型&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;em>Nginx 容器在哪？&lt;/em>&lt;/p>
&lt;p>&lt;em>那么 &lt;code>pause&lt;/code> 容器又是什么？&lt;/em>&lt;/p>
&lt;h2 id="pause-容器创建-pod-中的网络命名空间">Pause 容器创建 Pod 中的网络命名空间&lt;/h2>
&lt;p>从节点上的所有进程中找出 Nginx 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ lsns
NS TYPE NPROCS PID USER COMMAND
&lt;span class="c1"># truncated output&lt;/span>
&lt;span class="m">4026532414&lt;/span> net &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> /pause
&lt;span class="m">4026532513&lt;/span> mnt &lt;span class="m">1&lt;/span> &lt;span class="m">5599&lt;/span> root sleep 1d
&lt;span class="m">4026532514&lt;/span> uts &lt;span class="m">1&lt;/span> &lt;span class="m">5599&lt;/span> root sleep 1d
&lt;span class="m">4026532515&lt;/span> pid &lt;span class="m">1&lt;/span> &lt;span class="m">5599&lt;/span> root sleep 1d
&lt;span class="m">4026532516&lt;/span> mnt &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532517&lt;/span> uts &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532518&lt;/span> pid &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该容器出现在了挂在（mount &lt;code>mnt&lt;/code>）、Unix 分时系统（Unix time-sharing &lt;code>uts&lt;/code>）和 PID（&lt;code>pid&lt;/code>）命名空间中，但是并不在网络命名空间（&lt;code>net&lt;/code>）中。&lt;/p>
&lt;p>不幸的是，&lt;code>lsns&lt;/code> 只显示了每个进程最低的 PID，不过可以根据进程 ID 进一步过滤。&lt;/p>
&lt;p>可以通过以下内容检索Nginx 容器的所有命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ sudo lsns -p &lt;span class="m">5777&lt;/span>
NS TYPE NPROCS PID USER COMMAND
&lt;span class="m">4026531835&lt;/span> cgroup &lt;span class="m">178&lt;/span> &lt;span class="m">1&lt;/span> root /sbin/init noembed norestore
&lt;span class="m">4026531837&lt;/span> user &lt;span class="m">178&lt;/span> &lt;span class="m">1&lt;/span> root /sbin/init noembed norestore
&lt;span class="m">4026532411&lt;/span> ipc &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> /pause
&lt;span class="m">4026532414&lt;/span> net &lt;span class="m">5&lt;/span> &lt;span class="m">5489&lt;/span> &lt;span class="m">65535&lt;/span> /pause
&lt;span class="m">4026532516&lt;/span> mnt &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532517&lt;/span> uts &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;span class="m">4026532518&lt;/span> pid &lt;span class="m">3&lt;/span> &lt;span class="m">5777&lt;/span> root nginx: master process nginx -g daemon off&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>pause&lt;/code> 进程再次出现，这次它劫持了网络命名空间。&lt;/p>
&lt;p>&lt;em>那是什么？&lt;/em>&lt;/p>
&lt;p>&lt;strong>集群中的每个 pod 都有一个在后台运行的隐藏容器，被称为 &lt;code>pause&lt;/code>&lt;/strong>。&lt;/p>
&lt;p>列出节点上的所有容器并过滤出 pause 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ docker ps &lt;span class="p">|&lt;/span> grep pause
fa9666c1d9c6 k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_kube-dns-599484b884-sv2js…
44218e010aeb k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_blackbox-exporter-55c457d…
5fb4b5942c66 k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_kube-dns-599484b884-cq99x…
8007db79dcf2 k8s.gcr.io/pause:3.4.1 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> k8s_POD_konnectivity-agent-84f87c…
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将看到对于节点分配到的每个 pod，都有一个匹配的 &lt;code>pause&lt;/code> 容器。&lt;/p>
&lt;p>&lt;strong>该 &lt;code>pause&lt;/code> 容器负责创建和维持网络命名空间。&lt;/strong>&lt;/p>
&lt;p>它包含的代码极少，部署后立即进入睡眠状态。&lt;/p>
&lt;p>然而，&lt;a href="https://www.ianlewis.org/en/almighty-pause-container">它在 Kubernetes 生态中的首当其冲，发挥着至关重要的作用。&lt;/a>。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建 pod 时，CNI 会创建一个带有&lt;em>睡眠&lt;/em>容器的网络命名空间&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427720335296.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pod 中的所有容器都会加入到它创建的网络命名空间中&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427721343650.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此时 CNI 分配 IP 地址并将容器连接到网络&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427710287189.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;em>进入睡眠状态的容器有什么用？&lt;/em>&lt;/p>
&lt;p>要了解它的实用性，我们可以想象下如示例一样有两个容器的 pod，但没有 &lt;code>pause&lt;/code> 容器。&lt;/p>
&lt;p>容器启动，CNI：&lt;/p>
&lt;ol>
&lt;li>为 Nginx 容器创建一个网络命名空间。&lt;/li>
&lt;li>把 busybox 容器加入到前面创建的网络命名空间中。&lt;/li>
&lt;li>为 pod 分配 IP 地址。&lt;/li>
&lt;li>将容器连接到网络。&lt;/li>
&lt;/ol>
&lt;p>&lt;em>假如 Nginx 容器崩溃了会发生什么？&lt;/em>&lt;/p>
&lt;p>CNI 将不得不&lt;em>再次&lt;/em>完成所有流程，两个容器的网络都会中断。&lt;/p>
&lt;p>由于 &lt;code>sleep&lt;/code> 容器不太可能有任何 bug，因此创建网络命名空间通常是一个更保险、更健壮的选择。&lt;/p>
&lt;p>&lt;strong>如果 pod 中的一个容器崩溃，其余的仍可以处理网络请求。&lt;/strong>&lt;/p>
&lt;h2 id="为-pod-分配了-ip-地址">为 Pod 分配了 IP 地址&lt;/h2>
&lt;p>前面提到 pod 和所有容器获得了同样的 IP。&lt;/p>
&lt;p>&lt;code>这是怎么配置的？&lt;/code>&lt;/p>
&lt;p>&lt;em>&lt;em>在 pod 网络命名空间中，创建一个接口并分配 IP 地址&lt;/em>。&lt;/em>&lt;/p>
&lt;p>我们来验证下。&lt;/p>
&lt;p>首先，找到 pod 的 IP 地址：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod multi-container-pod -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">={&lt;/span>.status.podIP&lt;span class="o">}&lt;/span>
10.244.4.40
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，找到相关的网络命名空间。&lt;/p>
&lt;p>由于网络命名空间是从物理接口创建的，需要访问集群节点。&lt;/p>
&lt;blockquote>
&lt;p>如果你运行的是 minikube，可以通过 &lt;code>minikube ssh&lt;/code> 访问节点。如果在云提供商中运行，应该有某种方法通过 SSH 访问节点。&lt;/p>
&lt;/blockquote>
&lt;p>进入后，可以找到创建的最新的网络命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ls -lt /var/run/netns
total &lt;span class="m">0&lt;/span>
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">25&lt;/span> 13:34 cni-0f226515-e28b-df13-9f16-dd79456825ac
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-7619c818-5b66-5d45-91c1-1c516f559291
-r--r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Sep &lt;span class="m">24&lt;/span> 09:39 cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本示例中，它是 &lt;code>cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;/code>。此时，可以在该命名空间总执行 &lt;code>exec&lt;/code> 命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip a
&lt;span class="c1"># output truncated&lt;/span>
3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">1450&lt;/span> qdisc noqueue state UP group default
link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span class="m">0&lt;/span>
inet 10.244.4.40/32 brd 10.244.4.40 scope global eth0
valid_lft forever preferred_lft forever
inet6 fe80::14a4:f8ff:fe4f:5677/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>&lt;code>10.244.4.40&lt;/code> 就是 pod 的 IP 地址。&lt;/strong>&lt;/p>
&lt;p>通过查找 &lt;code>@if12&lt;/code> 中的 &lt;code>12&lt;/code> 找到网络接口。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip link &lt;span class="p">|&lt;/span> grep -A1 ^12
12: vethweplb3f36a0@if16: mtu &lt;span class="m">1376&lt;/span> qdisc noqueue master weave state UP mode DEFAULT group default
link/ether 72:1c:73:d9:d9:f6 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以验证 Nginx 容器是否从该命名空间中监听 HTTP 流量：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac netstat -lnp
Active Internet connections &lt;span class="o">(&lt;/span>only servers&lt;span class="o">)&lt;/span>
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
tcp &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 0.0.0.0:80 0.0.0.0:* LISTEN 692698/nginx: master
tcp6 &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> :::80 :::* LISTEN 692698/nginx: master
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>如果无法通过 SSH 访问集群的节点，可以试试 &lt;code>kubectl exec&lt;/code> 进入到 busybox 容器，然后使用 &lt;code>ip&lt;/code> 和 &lt;code>netstat&lt;/code> 命令。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;em>太棒了！&lt;/em>&lt;/p>
&lt;p>现在我们已经介绍了容器间的通信，接下来看看 Pod 与 Pod 直接如何建立通信。&lt;/p>
&lt;h2 id="检查集群中-pod-到-pod-的流量">检查集群中 pod 到 pod 的流量&lt;/h2>
&lt;p>当说起 pod 间通信时，会有两种可能：&lt;/p>
&lt;ol>
&lt;li>Pod 流量流向同一节点上的 pod。&lt;/li>
&lt;li>Pod 流量流量另一个节点上的 pod。&lt;/li>
&lt;/ol>
&lt;p>为了使整个设置正常工作，我们需要之前讨论过的虚拟接口和以太网桥接。&lt;/p>
&lt;p>在继续之前，我们先讨论下他们的功能以及为什么他们时必需的。&lt;/p>
&lt;p>&lt;strong>要完成 pod 与其他 pod 的通信，它必须先访问节点的根命名空间。&lt;/strong>&lt;/p>
&lt;p>这是使用连接 pod 和根命名空间的虚拟以太网对来实现的。&lt;/p>
&lt;p>这些&lt;a href="https://man7.org/linux/man-pages/man4/veth.4.html">虚拟接口设备&lt;/a>（&lt;code>veth&lt;/code> 中的 &lt;code>v&lt;/code>）连接并充当两个命名空间间的隧道。&lt;/p>
&lt;p>使用此 &lt;code>veth&lt;/code> 设备，将一端连接到 pod 的命名空间，另一端连接到根命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427710287189.jpg" alt="">&lt;/p>
&lt;p>这些 CNI 可以替你做，也可以手动操作：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip link add veth1 netns pod-namespace &lt;span class="nb">type&lt;/span> veth peer veth2 netns root
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在 pod 的命名空间有了可以访问根命名空间的隧道。&lt;/p>
&lt;p>&lt;strong>节点上每个新建的 pod 都会设置如下所示的 veth 对。&lt;/strong>&lt;/p>
&lt;p>创建接口对时其中一部分。&lt;/p>
&lt;p>其他的就是为以太网设备分配地址，并创建默认路由。&lt;/p>
&lt;p>来看下如何在 pod 的命名空间中设置 &lt;code>veth1&lt;/code> 接口：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip addr add 10.244.4.40/24 dev veth1
$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip link &lt;span class="nb">set&lt;/span> veth1 up
$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip route add default via 10.244.4.40
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在节点侧，我们创建另一个 &lt;code>veth2&lt;/code> 对：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip addr add 169.254.132.141/16 dev veth2
$ ip link &lt;span class="nb">set&lt;/span> veth2 up
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以像以前一样检查现有的 &lt;code>veth&lt;/code> 对。&lt;/p>
&lt;p>在 pod 的命名空间中，检查 &lt;code>eth0&lt;/code> 接口的后缀。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip netns &lt;span class="nb">exec&lt;/span> cni-0f226515-e28b-df13-9f16-dd79456825ac ip link show &lt;span class="nb">type&lt;/span> veth
3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">1450&lt;/span> qdisc noqueue state UP mode DEFAULT group default
link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种情况下可以使用 &lt;code>grep -A1 ^12&lt;/code> 进行查找（或者滚动到目标所在）：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ip link show &lt;span class="nb">type&lt;/span> veth
&lt;span class="c1"># output truncated&lt;/span>
12: cali97e50e215bd@if3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">1450&lt;/span> qdisc noqueue state UP mode DEFAULT group default
link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netns cni-0f226515-e28b-df13-9f16-dd79456825ac
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>也可以使用 &lt;code>ip -n cni-0f226515-e28b-df13-9f16-dd79456825ac link show type veth&lt;/code> 命令。&lt;/p>
&lt;/blockquote>
&lt;p>注意 &lt;code>3: eth0@if12&lt;/code> 和 &lt;code>12: cali97e50e215bd@if3&lt;/code> 接口上的符号。&lt;/p>
&lt;p>在 pod 命名空间中，&lt;code>eth0&lt;/code> 接口连接到根命名空间中编号为 &lt;code>12&lt;/code> 的接口。因此是 &lt;code>@if12&lt;/code>。&lt;/p>
&lt;p>在 &lt;code>veth&lt;/code> 对的另一端，根命名空间连接到 pod 命名空间的 &lt;code>3&lt;/code> 号接口。&lt;/p>
&lt;p>接下来是连接 &lt;code>veth&lt;/code> 对两端的桥接器（bridge）。&lt;/p>
&lt;h2 id="pod-命名空间连接到以太网桥接器">Pod 命名空间连接到以太网桥接器&lt;/h2>
&lt;p>桥接器将位于根命名空间中的虚拟接口的每一端“绑定”。&lt;/p>
&lt;p>&lt;strong>该桥接器将允许流量在虚拟对之间流动，并通过公共根命名空间。&lt;/strong>&lt;/p>
&lt;p>&lt;em>理论时间。&lt;/em>&lt;/p>
&lt;p>以太网桥接器位于&lt;a href="https://en.wikipedia.org/wiki/OSI_model">OSI 网络模型&lt;/a>的第二层。&lt;/p>
&lt;p>&lt;a href="https://ops.tips/blog/using-network-namespaces-and-bridge-to-isolate-servers/">可以将桥接器看作一个虚拟交换机，接受来自不同命名空间和接口的连接。&lt;/a>&lt;/p>
&lt;p>&lt;strong>以太网桥接器允许连接同一个节点上的多个可用网络。&lt;/strong>&lt;/p>
&lt;p>因此，可以使用该设置连接两个接口：从 pod 命名空间的 &lt;code>veth&lt;/code> 连接到同一节点上另一个 pod 的 &lt;code>veth&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427769020626.jpg" alt="">&lt;/p>
&lt;p>我们继续看下以太网桥接器和 veth 对的作用。&lt;/p>
&lt;h2 id="跟踪同一节点上-pod-间的流量">跟踪同一节点上 pod 间的流量&lt;/h2>
&lt;p>假设同一个节点上有两个 pod，Pod-A 想向 Pod-B 发送消息。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>由于目标不是同命名空间的容器，Pod-A 向其默认接口 &lt;code>eth0&lt;/code> 发送数据包。这个接口与 &lt;code>veth&lt;/code> 对的一端绑定，作为隧道。因此数据包将被转发到节点的根命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427770131482.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以太网桥接器作为虚拟交换机，必须以某种方式将目标 pod IP（Pod-B）解析为其 MAC 地址。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427772473425.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>轮到ARP 协议上场了。当帧到达桥接器时，会向所有连接的设备发送 ARP 广播。桥接器喊道&lt;em>谁有 Pod-B 的 IP 地址&lt;/em>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427774225871.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>收到带有连接 Pod-B 接口的 MAC 地址的回复，然后此信息存储在桥接器 ARP 缓存（查找表）中。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427775056174.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IP 和 MAC 地址的映射存储完成后，桥接器在表中查找，并将数据包转发到正确的短点。数据包到达根命名空间中 Pod- B 的 &lt;code>veth&lt;/code>，然后从那快速到达 Pod-B 命名空间内的 &lt;code>eth0&lt;/code> 接口。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427775056174.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>有了这个，Pod-A 和 Pod-B 之间的通信取得了成功。&lt;/p>
&lt;h2 id="跟踪不同节点上-pod-间的通信">跟踪不同节点上 pod 间的通信&lt;/h2>
&lt;p>对于需要跨不同节点通信的 pod，需要额外的通信跳转。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>前几个步骤保持不变，直到数据包到达根命名空间并需要发送到 Pod- B。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427777182601.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当目标地址不在本地网络中，数据包将被转发到本节点的默认网关。节点上退出或默认网关通常位于 &lt;code>eth0&lt;/code> 接口上 &amp;ndash; 将节点连接到网络的物理接口。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16427777968858.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>这次并不会发生 ARP 解析，因为源和目标 IP 在不同网络上。&lt;/strong>&lt;/p>
&lt;p>检查使用位运算（Bitwise）操作完成。&lt;/p>
&lt;p>当目标 IP 不在当前网络上时，数据包将被转发到节点的默认网关。&lt;/p>
&lt;h3 id="位运算的工作原理">位运算的工作原理&lt;/h3>
&lt;p>在确定数据包的转发位置时，源节点必须执行位运算。&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">这也被称为与操作。&lt;/a>&lt;/p>
&lt;p>作为复习，位与操作产生如下结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了 1 与 1 以外的都是 false。&lt;/p>
&lt;p>如果源节点的 IP 为 192.168.1.1，子网掩码为 /24，目标 IP 为 172.16.1.1/16，则按位与操作将确认他们不在同一网络上。&lt;/p>
&lt;p>这意味着目标 IP 与数据包的源在不同的网络上，因此数据包将在默认网关中转发。&lt;/p>
&lt;p>&lt;em>数学时间。&lt;/em>&lt;/p>
&lt;p>我们必须从二进制文件中的 32 位地址执行与操作开始。&lt;/p>
&lt;p>先找出源和目标 IP 的网络。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">| Type | Binary | Converted |
| ---------------- | ----------------------------------- | ------------------ |
| Src. IP Address | 11000000.10101000.00000001.00000001 | 192.168.1.1 |
| Src. Subnet Mask | 11111111.11111111.11111111.00000000 | 255.255.255.0(/24) |
| Src. Network | 11000000.10101000.00000001.00000000 | 192.168.1.0 |
| | | |
| Dst. IP Address | 10101100.00010000.00000001.00000001 | 172.16.1.1 |
| Dst. Subnet Mask | 11111111.11111111.00000000.00000000 | 255.255.0.0(/16) |
| Dst. Network | 10101100.00010000.00000000.00000000 | 172.16.0.0 |
&lt;/code>&lt;/pre>&lt;/div>&lt;p>位运算操作后，需要将目标 IP 与数据包源节点的子网进行比较。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">| Type | Binary | Converted |
| ---------------- | ----------------------------------- | ------------------ |
| Dst. IP Address | 10101100.00010000.00000001.00000001 | 172.16.1.1 |
| Src. Subnet Mask | 11111111.11111111.11111111.00000000 | 255.255.255.0(/24) |
| Network Result | 10101100.00010000.00000001.00000000 | 172.16.1.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>进行位比较后，ARP 会检查其查询表来查找默认网关的 MAC 地址。&lt;/p>
&lt;p>如果有条目，将立即转发数据包。&lt;/p>
&lt;p>否则，先进行广播以确定网关的 MAC 地址。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>数据包现在路由到另一个节点的默认接口，我们叫它 Node-B。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428091589748.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以相反的顺序。数据包现在位与 Node-B 的根命名空间，并到达桥接器，这里会进行 ARP 解析。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428095883798.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>收到带有连接 Pod-B 的接口 MAC地址的回复。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428097041936.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这次桥接器通过 Pod-B 的 &lt;code>veth&lt;/code> 设备将帧转发，并到达 Pod-B 自己的命名空间。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428097041936.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>此时应该已经熟悉了 pod 之间的流量如何流转，接下来再探索下 CNI 如何创建上述内容。&lt;/p>
&lt;h2 id="容器网络接口---cni">容器网络接口 - CNI&lt;/h2>
&lt;p>&lt;a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">容器网络接口（CNI）关注当前节点的网络。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428099347551.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>可以将 CNI 看作网络插件在解决 Kubernetes &lt;em>某些&lt;/em> 需求时要遵循的一套规则。&lt;/strong>&lt;/p>
&lt;p>然而，它不仅仅与 Kubernetes 或者特定网络插件关联。&lt;/p>
&lt;p>可以使用如下 CNI：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.tigera.io/project-calico/">Calico&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cilium.io/">Cilium&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/flannel-io/flannel">Flannel&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.weave.works/docs/net/latest/overview/">Weave Net&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containernetworking/cni#3rd-party-plugins">其他网络插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>他们都实现相同的 CNI 标准。&lt;/p>
&lt;p>如果没有 CNI，你需要手动完成如下操作：&lt;/p>
&lt;ul>
&lt;li>创建 pod（容器）的网络命名空间&lt;/li>
&lt;li>创建接口&lt;/li>
&lt;li>创建 veth 对&lt;/li>
&lt;li>设置命名空间网络&lt;/li>
&lt;li>设置静态路由&lt;/li>
&lt;li>配置以太网桥接器&lt;/li>
&lt;li>分配 IP 地址&lt;/li>
&lt;li>创建 NAT 规则&lt;/li>
&lt;/ul>
&lt;p>还有太多其他需要手动完成的工作。&lt;/p>
&lt;p>更不用说删除或重新启动 pod 时删除或调整上述所有内容了。&lt;/p>
&lt;p>CNI 必须支持&lt;a href="https://github.com/containernetworking/cni/blob/master/SPEC.md#cni-operations">四个不同的操作&lt;/a>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ADD&lt;/strong> - 将容器添加到网络&lt;/li>
&lt;li>&lt;strong>DEL&lt;/strong> - 从网络中删除容器&lt;/li>
&lt;li>&lt;strong>CHECK&lt;/strong> - 如果容器的网络出现问题，则返回错误&lt;/li>
&lt;li>&lt;strong>VERSION&lt;/strong> - 显示插件的版本&lt;/li>
&lt;/ul>
&lt;p>&lt;em>让我们在实践中看看它是如何工作的。&lt;/em>&lt;/p>
&lt;p>当 pod 分配到特定节点时，kubelet 本身不会初始化网络。&lt;/p>
&lt;p>相反，它将任务交给了 CNI。&lt;/p>
&lt;p>&lt;strong>然后，它指定了配置，并以 JSON 格式将其发送给 CNI 插件。&lt;/strong>&lt;/p>
&lt;p>可以在节点的 &lt;code>/etc/cni/net.d&lt;/code> 目录中，找到当前 CNI 的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat 10-calico.conflist
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;k8s-pod-network&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;cniVersion&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;0.3.1&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;plugins&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;calico&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;datastore_type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;kubernetes&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;mtu&amp;#34;&lt;/span>: 0,
&lt;span class="s2">&amp;#34;nodename_file_optional&amp;#34;&lt;/span>: false,
&lt;span class="s2">&amp;#34;log_level&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Info&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;log_file_path&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/var/log/calico/cni/cni.log&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;ipam&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span> &lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;calico-ipam&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;assign_ipv4&amp;#34;&lt;/span> : &lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;assign_ipv6&amp;#34;&lt;/span> : &lt;span class="s2">&amp;#34;false&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;container_settings&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;allow_ip_forwarding&amp;#34;&lt;/span>: &lt;span class="nb">false&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;policy&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;k8s&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;kubernetes&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;k8s_api_root&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;https://10.96.0.1:443&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;kubeconfig&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/etc/cni/net.d/calico-kubeconfig&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;bandwidth&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;capabilities&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bandwidth&amp;#34;&lt;/span>: true&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;portmap&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;snat&amp;#34;&lt;/span>: true, &lt;span class="s2">&amp;#34;capabilities&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;portMappings&amp;#34;&lt;/span>: true&lt;span class="o">}}&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>每个插件都使用不同类型的配置来设置网络。&lt;/strong>&lt;/p>
&lt;p>例如，Calico 使用 BGP 路由协议配对的第 3 层网络来连接 pod。&lt;/p>
&lt;p>Cilium 在第 3 到 7 层使用 eBPF 配置覆盖网络。&lt;/p>
&lt;p>与 Calico 一起，Cilium 支持设置网络策略来限制流量。&lt;/p>
&lt;p>&lt;em>那该如何选择呢？&lt;/em>&lt;/p>
&lt;p>这取决于。&lt;/p>
&lt;p>CNI 主要有两组。&lt;/p>
&lt;p>&lt;strong>第一组中，可以找到使用基本网络设置（也称为扁平网络）的CNI&lt;/strong>，并将集群 IP 池 中的IP 地址分配给 pod。&lt;/p>
&lt;p>这可能会因为快速用尽可用的 IP 地址而成为负担。&lt;/p>
&lt;p>&lt;strong>相反，另一种方法是使用覆盖网络。&lt;/strong>&lt;/p>
&lt;p>简而言之，覆盖网络是主（底层）网络之上的辅助网络。&lt;/p>
&lt;p>&lt;strong>覆盖网络的工作原理是封装来自底层网络的所有数据包，这些数据包指向另一个节点上的 pod。&lt;/strong>&lt;/p>
&lt;p>覆盖网络的一项流行技术是 &lt;a href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN">VXLAN&lt;/a>，它允许在 L3 网络上隧道传输 L2 域。&lt;/p>
&lt;p>&lt;em>那么哪种更好？&lt;/em>&lt;/p>
&lt;p>&lt;strong>没有唯一的答案，通常取决于你的需求。&lt;/strong>&lt;/p>
&lt;p>&lt;em>你是在构建一个拥有数万个节点的大集群吗？&lt;/em>&lt;/p>
&lt;p>可能覆盖网络更好。&lt;/p>
&lt;p>&lt;em>你是否在意更简单的设置和在嵌套网络中不失去检查网络流量的能力。&lt;/em>&lt;/p>
&lt;p>扁平网络更适合你。&lt;/p>
&lt;p>现在已经讨论了 CNI，让我们继续探索 Pod 到服务（service）的通信是如何完成的。&lt;/p>
&lt;h2 id="检查-pod-到服务的流量">检查 pod 到服务的流量&lt;/h2>
&lt;p>由于 Kubernetes 环境下 pod 的动态特性，分配给 pod 的 IP 地址不是静态的。&lt;/p>
&lt;p>&lt;strong>这些 IP 地址是短暂的，每次创建或者删除 pod 时都会发生变化。&lt;/strong>&lt;/p>
&lt;p>服务解决了这个问题，为连接到一组 pod 提供了稳定的机制。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428122010963.jpg" alt="">&lt;/p>
&lt;p>默认情况下，在 Kubernetes 中创建服务时，会&lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">为其预定并分配虚拟 IP &lt;/a>。&lt;/p>
&lt;p>使用选择器将服务于目标 pod 进行管理。&lt;/p>
&lt;p>&lt;em>当删除 pod 并添加新 pod 时会发生什么？&lt;/em>&lt;/p>
&lt;p>&lt;strong>该服务的虚拟 IP 保持不变。&lt;/strong>&lt;/p>
&lt;p>然而，无需敢于，流量将到达新创建的 pod。&lt;/p>
&lt;p>换句话说，Kubernetes 中的服务类似于负载均衡器。&lt;/p>
&lt;p>&lt;em>但他们时如何工作的？&lt;/em>&lt;/p>
&lt;h2 id="使用-netfilter-和-iptables-拦截和重写流量">使用 Netfilter 和 Iptables 拦截和重写流量&lt;/h2>
&lt;p>Kubernetes 中的服务基于两个 Linux 内核组件：&lt;/p>
&lt;ol>
&lt;li>Netfilter&lt;/li>
&lt;li>Iptables&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Netfilter 是一个框架，允许配置数据包过滤、创建 NAT或端口翻译规则，并管理网络中的流量。&lt;/strong>&lt;/p>
&lt;p>此外，它还屏蔽和阻止不请自来的连接访问服务。&lt;/p>
&lt;p>&lt;strong>另一方面，Iptables 是一个用户空间程序，允许你配置 Linux 内核防火墙的 IP 数据包过滤器规则。&lt;/strong>&lt;/p>
&lt;p>iptables 使用不同的 Netfilter 模块实现。&lt;/p>
&lt;p>你可以使用 iptables CLI 实时更改过滤规则，并将其插入 netfilters 的挂点。&lt;/p>
&lt;p>过滤器组织在不同的表中，其中包含处理网络流量数据包的链。&lt;/p>
&lt;p>每个协议都使用不同的内核模块和程序。&lt;/p>
&lt;blockquote>
&lt;p>当提到 iptables 时，通常说的是 IPV4。对于 IPV6 的规则，CLI 是 ip6tables。&lt;/p>
&lt;/blockquote>
&lt;p>Iptables 有五种类型的链，每种链都直接映射到 Netfilter 钩子。&lt;/p>
&lt;p>从 iptables 角度看是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>PRE_ROUTING&lt;/code>&lt;/li>
&lt;li>&lt;code>INPUT&lt;/code>&lt;/li>
&lt;li>&lt;code>FORWARD&lt;/code>&lt;/li>
&lt;li>&lt;code>OUTPUT&lt;/code>&lt;/li>
&lt;li>&lt;code>POST_ROUTING&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>对应映射到 Netfilter 钩子：&lt;/p>
&lt;ul>
&lt;li>&lt;code>NF_IP_PRE_ROUTING&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_LOCAL_IN&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_FORWARD&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_LOCAL_OUT&lt;/code>&lt;/li>
&lt;li>&lt;code>NF_IP_POST_ROUTING&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>当数据包到达时，根据所处的阶段，会“出发” Netfilter 钩子，该钩子应用特定的 iptables 过滤。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428137183275.jpg" alt="">&lt;/p>
&lt;p>&lt;em>哎呀，看起来很复杂！&lt;/em>&lt;/p>
&lt;p>不过不需要担心。&lt;/p>
&lt;p>这就是为什么我们使用 Kubernetes，上面的所有内容都是通过使用服务来抽象的，一个简单的 YAML 定义就可以自动完成这些规则的设置。&lt;/p>
&lt;p>如果对这些 iptables 规则感兴趣，可以登陆到节点并运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">iptables-save
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用&lt;a href="https://github.com/Nudin/iptable_vis">可视化工具&lt;/a>浏览节点上的 iptables 链。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428153624915.jpg" alt="">&lt;/p>
&lt;p>&lt;em>记住，可能会有数百条规则。想象下手动创建的难度。&lt;/em>&lt;/p>
&lt;p>我们已经解释了相同和不同节点上的 pod 间如何通信。&lt;/p>
&lt;p>在 Pod-to-Service 中，通信的前半部分保持不变。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428154678475.jpg" alt="">&lt;/p>
&lt;p>当 Pod-A 发出请求时，希望到达 Pod-B（这种情况下，Pod-B 位与服务之后），转移的过程中会发生其他变化。&lt;/p>
&lt;p>原始请求从 Pod-A 命名空间中的 &lt;code>eth0&lt;/code> 接口出来。&lt;/p>
&lt;p>从那里穿过 &lt;code>veth&lt;/code> 对，到达根命名空间的以太网桥。&lt;/p>
&lt;p>一旦到达桥接器，数据包立即通过默认网关转发。&lt;/p>
&lt;p>与 Pod-to-Pod 部分一样，主机进行位比较，由于服务的 vIP 不是节点 CIDR 的一部分，数据包将立即通过默认网关转发出去。&lt;/p>
&lt;p>如果查找表中尚没有默认网关的 MAC 地址，则会进行相同的 ARP 解析。&lt;/p>
&lt;p>&lt;em>现在魔法发生了。&lt;/em>&lt;/p>
&lt;p>在数据包经过节点的路由处理之前，Netfilter 钩子 &lt;code>NF_IP_PRE_ROUTING&lt;/code> 被触发并应用一条 iptables 规则。规则进行了 DNAT 转换，重写了 POD-A 数据包的目标 IP 地址。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428159345915.jpg" alt="">&lt;/p>
&lt;p>原来服务 vIP 地址被重写称 POD-B 的IP 地址。&lt;/p>
&lt;p>从那里，路由就像 Pod-to-Pod 直接通信一样。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428160707534.jpg" alt="">&lt;/p>
&lt;p>然而，在所有这些通信之间，使用了第三个功能。&lt;/p>
&lt;p>&lt;a href="https://www.linuxtopia.org/Linux_Firewall_iptables/x1298.html">这个功能被称为 conntrack&lt;/a>，或连接跟踪。&lt;/p>
&lt;p>&lt;strong>Conntrack 将数据包与连接关联起来，并在 Pod-B 发送回响应时跟踪其来源。&lt;/strong>&lt;/p>
&lt;p>NAT 严重依赖 contrack 工作。&lt;/p>
&lt;p>如果没有连接跟踪，它将不知道将包含响应的数据包发送回哪里。&lt;/p>
&lt;p>使用 conntrack 时，数据包的返回路径可以轻松设置相同的源或目标 NAT 更改。&lt;/p>
&lt;p>另一半使用相反的顺序执行。&lt;/p>
&lt;p>Pod-B 接收并处理了请求，现在将数据发送回 Pod-A。&lt;/p>
&lt;p>&lt;em>此时会发生什么？&lt;/em>&lt;/p>
&lt;h2 id="检查服务的响应">检查服务的响应&lt;/h2>
&lt;p>现在 Pod-B 发送响应，将其 IP 地址设置为源地址，Pod-A IP 地址设置为目标地址。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当数据包到达 Pod-A 所在节点的接口时，就会发生另一个 NAT&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428165510048.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这次，使用 conntrack 更改源 IP 地址，iptables 规则执行 SNAT 将 Pod-B IP 地址替换为原始服务的 VIP 地址。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428166224192.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从 Pod-A 来看像是服务发回的响应，而不是 Pod-B。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/22/16428166224192.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>其他部分都一样；一旦 SNAT 完成，数据包到达根命名空间中的以太网桥接器，并通过 veth 对转发到 Pod-A。&lt;/p>
&lt;h2 id="回顾">回顾&lt;/h2>
&lt;p>让我们来总结下你在本文中学到的东西：&lt;/p>
&lt;ul>
&lt;li>容器如何在本地或 pod 内通信。&lt;/li>
&lt;li>当 pod 位于相同和不同的节点上时，Pod-to- Pod 如何通信。&lt;/li>
&lt;li>Pod-to-Service - 当 pod 向 Kubernetes 服务背后的 pod 发送流量时。&lt;/li>
&lt;li>Kubernetes 网络工具箱中有效通信所需的命名空间、veth、iptables、链、Netfilter、CNI、覆盖网络以及所有其他内容。&lt;/li>
&lt;/ul></description></item><item><title>Kubernetes HPA 基于 Prometheus 自定义指标的可控弹性伸缩</title><link>https://atbug.com/kubernetes-pod-autoscale-on-prometheus-metrics/</link><pubDate>Tue, 18 Jan 2022 12:03:59 +0800</pubDate><guid>https://atbug.com/kubernetes-pod-autoscale-on-prometheus-metrics/</guid><description>
&lt;p>在&lt;a href="https://mp.weixin.qq.com/s/GKS3DJHm4p0Tjtj8nJRGmA">《Kubernetes 的自动伸缩你用对了吗？》&lt;/a>
一文中详细说明了如何使用 Kubernetes 的自动伸缩。在 Kubernetes 中弹性伸缩主要有三种：HPA、VPA、CA。本文不再详细说明，有兴趣的可以看那篇文章。这里主要来说下 Pod 水平缩放 &lt;a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">HPA&lt;/a>。&lt;/p>
&lt;p>随着 Kubernetes v1.23 的发布，HPA 的 API 来到了稳定版 &lt;code>autoscaling/v2&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>基于自定义指标的伸缩&lt;/li>
&lt;li>基于多项指标的伸缩&lt;/li>
&lt;li>可配置的伸缩行为&lt;/li>
&lt;/ul>
&lt;p>从最初的 v1 版本 HPA 只支持 CPU、内存利用率的伸缩，到后来的自定义指标、聚合层 API 的支持，到了 v1.18 版本又加入了配置伸缩行为的支持，HPA 也越来越好用、可靠。&lt;/p>
&lt;p>依靠 CPU 或者内存指标的扩容并非使用所有系统，看起来也没那么可靠。对大部分的 web 后端系统来说，基于 RPS（每秒请求数）的弹性伸缩来处理突发的流量则会更加靠谱。&lt;/p>
&lt;p>Prometheus 也是当下流行开源监控系统，通过 Prometheus 可以获取到系统的实时流量负载指标，今天我们就来尝试下基于 Prometheus 的自定义指标进行弹性伸缩。&lt;/p>
&lt;p>&lt;strong>注：目前 HPA 的缩容0 （scale to 0），则需要在 feature gate 打开 alpha 版本的 &lt;code>HPAScaleToZero&lt;/code> 以及配置一个对象或者外部指标。即使是打开了，从 0 到 1 的扩容需要调度、IP 分配、镜像拉取等过程，存在一定的开销。如果降低这部分开销，这里先卖个关子，后续的文章进行补充。&lt;/strong>&lt;/p>
&lt;p>文章中使用的所有代码都可以&lt;a href="https://github.com/addozhang/hpa-on-prometheus-metrics">从这里下载&lt;/a>。&lt;/p>
&lt;h2 id="整体架构">整体架构&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/18/hpa2.png" alt="">&lt;/p>
&lt;p>HPA 要获取 Prometheus 的指标数据，这里引入 &lt;a href="https://github.com/kubernetes-sigs/prometheus-adapter">Prometheus Adapter&lt;/a> 组件。Prometheus Adapter 实现了 &lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/resource-metrics-api.md">resource metrics&lt;/a>、&lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/custom-metrics-api.md">custom metrics&lt;/a> 和 &lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/external-metrics-api.md">external metrics APIs&lt;/a> API，支持 &lt;em>autoscaling/v2&lt;/em> 的 HPA。&lt;/p>
&lt;p>获取到指标数据后，根据预定义的规则对工作负载的示例数进行调整。&lt;/p>
&lt;h2 id="环境搭建">环境搭建&lt;/h2>
&lt;h3 id="k3s">K3s&lt;/h3>
&lt;p>我们使用最新 1.23 版本的 K3s 作为 Kubernetes 环境。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nb">export&lt;/span> &lt;span class="nv">INSTALL_K3S_VERSION&lt;/span>&lt;span class="o">=&lt;/span>v1.23.1+k3s2
curl -sfL https://get.k3s.io &lt;span class="p">|&lt;/span> sh -s - --write-kubeconfig-mode &lt;span class="m">644&lt;/span> --write-kubeconfig ~/.kube/config
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="示例应用">示例应用&lt;/h3>
&lt;p>我们准备一个简单的 web 应用，可以记录请求次数并通过 &lt;code>/metrics&lt;/code> 端点输出 Prometheus 格式的指标 &lt;code>http_requests_total&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">metrics&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">prometheus&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewCounterVec&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="nx">prometheus&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CounterOpts&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;http_requests_total&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Help&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;Number of total http requests&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;status&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="nx">prometheus&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MustRegister&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">metrics&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">path&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">URL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Path&lt;/span>
&lt;span class="nx">statusCode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">200&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">path&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;/metrics&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">promhttp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Handler&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">ServeHTTP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">w&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteHeader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">statusCode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">w&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello World!&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">metrics&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithLabelValues&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">strconv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Itoa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">statusCode&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nf">Inc&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:3000&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将应用部署到集群：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f kubernetes/sample-httpserver-deployment.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="prometheus">Prometheus&lt;/h3>
&lt;p>使用 Helm 安装 Prometheus，先添加 prometheus 的 chart 仓库：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的测试只需要用到 prometheus-server，安装时禁用其他组件。&lt;strong>同时为了演示效果的实效性，将指标的拉取间隔设置为 &lt;code>10s&lt;/code>&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># install prometheus with some components disabled&lt;/span>
&lt;span class="c1"># set scrape interval to 10s&lt;/span>
helm install prometheus prometheus-community/prometheus -n default --set alertmanager.enabled&lt;span class="o">=&lt;/span>false,pushgateway.enabled&lt;span class="o">=&lt;/span>false,nodeExporter.enabled&lt;span class="o">=&lt;/span>false,kubeStateMetrics.enabled&lt;span class="o">=&lt;/span>false,server.global.scrape_interval&lt;span class="o">=&lt;/span>10s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过端口转发，可以在浏览器中访问 web 页面。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># port forward&lt;/span>
kubectl port-forward svc/prometheus-server 9090:80 -n prometheus
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里查询 Pod 的 RPS 使用 &lt;code>sum(rate(http_requests_total[30s])) by (pod)&lt;/code> 语句查询：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/18/20220118-at-112123.png" alt="">&lt;/p>
&lt;h3 id="prometheus-adapter">Prometheus Adapter&lt;/h3>
&lt;p>同样使用 Helm 安装 Produmetheus Adapter，这里要进行额外的配置。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">helm install prometheus-adapter prometheus-community/prometheus-adapter -n default -f kubernetes/values-adapter.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了要配置 Prometheus server 的访问方式外，还要配置自定义指标的计算规则，告诉 adapter 如何从 Prometheus 获取指标并计算出我们需要的指标：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">rules:
default: false
custom:
- seriesQuery: &amp;#39;{__name__=~&amp;#34;^http_requests.*_total$&amp;#34;,container!=&amp;#34;POD&amp;#34;,namespace!=&amp;#34;&amp;#34;,pod!=&amp;#34;&amp;#34;}&amp;#39;
resources:
overrides:
namespace: { resource: &amp;#34;namespace&amp;#34; }
pod: { resource: &amp;#34;pod&amp;#34; }
name:
matches: &amp;#34;(.*)_total&amp;#34;
as: &amp;#34;${1}_qps&amp;#34;
metricsQuery: sum(rate(&amp;lt;&amp;lt;.Series&amp;gt;&amp;gt;{&amp;lt;&amp;lt;.LabelMatchers&amp;gt;&amp;gt;}[30s])) by (&amp;lt;&amp;lt;.GroupBy&amp;gt;&amp;gt;)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以参考详细的 &lt;a href="https://github.com/kubernetes-sigs/prometheus-adapter/blob/master/docs/sample-config.yaml">Adapter 配置&lt;/a>。&lt;/p>
&lt;p>待 promethues-adapter pod 成功运行后，可以执行 &lt;code>custom.metrics.k8s.io&lt;/code> 请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get --raw &lt;span class="s1">&amp;#39;/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/http_requests_qps&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> jq .
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;MetricValueList&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;custom.metrics.k8s.io/v1beta1&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;metadata&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;selfLink&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/%2A/http_requests_qps&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;items&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;describedObject&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Pod&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;namespace&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;default&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;sample-httpserver-64c495844f-b58pl&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/v1&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;metricName&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;http_requests_qps&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;2022-01-18T03:32:51Z&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;value&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;100m&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;selector&amp;#34;&lt;/span>: null
&lt;span class="o">}&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：这里的 &lt;code>value: 100m&lt;/code>，值的后缀“m” 标识 &lt;code>milli-requests per seconds&lt;/code>，所以这里的 100m 的意思是 0.1/s 每秒0.1 个请求。&lt;/strong>&lt;/p>
&lt;h3 id="hpa">HPA&lt;/h3>
&lt;p>最后就是 HPA 的配置了：&lt;/p>
&lt;ol>
&lt;li>最小最大的副本数分别设置 1、10&lt;/li>
&lt;li>为了测试效果的实效性，设置扩缩容的行为 &lt;code>behavior&lt;/code>&lt;/li>
&lt;li>指定指标 &lt;code>http_requests_qps&lt;/code>、类型 &lt;code>Pods&lt;/code> 以及目标值 &lt;code>50000m&lt;/code>：表示平均每个 pod 的 RPS &lt;code>50&lt;/code> 。比如以 300 的 RPS 访问，副本数就是 300/50=6 。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">HorizontalPodAutoscaler&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">autoscaling/v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sample-httpserver&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scaleTargetRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sample-httpserver&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">minReplicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">maxReplicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">behavior&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scaleDown&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stabilizationWindowSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">policies&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Percent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">periodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">15&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scaleUp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stabilizationWindowSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">policies&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Percent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">periodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">15&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metrics&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pods&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pods&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metric&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http_requests_qps&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">target&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">AverageValue&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">averageValue&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">50000m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="测试">测试&lt;/h2>
&lt;p>测试工具选用 &lt;a href="https://github.com/tsenart/vegeta">&lt;code>vegeta&lt;/code>&lt;/a>，因为其可以指定 RPS。&lt;/p>
&lt;p>先为应用创建 NodePort service：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl expose deploy sample-httpserver --name sample-httpserver-host --type NodePort --target-port &lt;span class="m">3000&lt;/span>
kubectl get svc sample-httpserver-host
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span class="o">(&lt;/span>S&lt;span class="o">)&lt;/span> AGE
sample-httpserver-host NodePort 10.43.66.206 &amp;lt;none&amp;gt; 3000:31617/TCP 12h
&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别使用 &lt;code>240&lt;/code>、&lt;code>120&lt;/code>、&lt;code>40&lt;/code> 的 RPS 发起请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># 240&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;GET http://192.168.1.92:31617&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> vegeta attack -duration 60s -connections &lt;span class="m">10&lt;/span> -rate &lt;span class="m">240&lt;/span> &lt;span class="p">|&lt;/span> vegeta report
&lt;span class="c1"># 120&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;GET http://192.168.1.92:31617&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> vegeta attack -duration 60s -connections &lt;span class="m">10&lt;/span> -rate &lt;span class="m">120&lt;/span> &lt;span class="p">|&lt;/span> vegeta report
&lt;span class="c1"># 40&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;GET http://192.168.1.92:31617&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> vegeta attack -duration 60s -connections &lt;span class="m">10&lt;/span> -rate &lt;span class="m">40&lt;/span> &lt;span class="p">|&lt;/span> vegeta report
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从 Prometheus 的 web 界面上观察请求量与示例数的变化：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/18/20220118-at-091913.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2022/01/18/20220118-at-091941.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl describe hpa sample-httpserver
Warning: autoscaling/v2beta2 HorizontalPodAutoscaler is deprecated in v1.23+, unavailable in v1.26+&lt;span class="p">;&lt;/span> use autoscaling/v2 HorizontalPodAutoscaler
Name: sample-httpserver
Namespace: default
Labels: &amp;lt;none&amp;gt;
Annotations: &amp;lt;none&amp;gt;
CreationTimestamp: Mon, &lt;span class="m">17&lt;/span> Jan &lt;span class="m">2022&lt;/span> 23:18:46 +0800
Reference: Deployment/sample-httpserver
Metrics: &lt;span class="o">(&lt;/span> current / target &lt;span class="o">)&lt;/span>
&lt;span class="s2">&amp;#34;http_requests_qps&amp;#34;&lt;/span> on pods: 100m / &lt;span class="m">50&lt;/span>
Min replicas: &lt;span class="m">1&lt;/span>
Max replicas: &lt;span class="m">10&lt;/span>
Behavior:
Scale Up:
Stabilization Window: &lt;span class="m">0&lt;/span> seconds
Select Policy: Max
Policies:
- Type: Percent Value: &lt;span class="m">100&lt;/span> Period: &lt;span class="m">15&lt;/span> seconds
Scale Down:
Stabilization Window: &lt;span class="m">30&lt;/span> seconds
Select Policy: Max
Policies:
- Type: Percent Value: &lt;span class="m">100&lt;/span> Period: &lt;span class="m">15&lt;/span> seconds
Deployment pods: &lt;span class="m">1&lt;/span> current / &lt;span class="m">1&lt;/span> desired
Conditions:
Type Status Reason Message
---- ------ ------ -------
AbleToScale True ReadyForNewScale recommended size matches current size
ScalingActive True ValidMetricFound the HPA was able to successfully calculate a replica count from pods metric http_requests_qps
ScalingLimited False DesiredWithinRange the desired count is within the acceptable range
Events:
Type Reason Age From Message
---- ------ ---- ---- -------
Normal SuccessfulRescale 25m horizontal-pod-autoscaler New size: 6&lt;span class="p">;&lt;/span> reason: pods metric http_requests_qps above target
Normal SuccessfulRescale 19m horizontal-pod-autoscaler New size: 4&lt;span class="p">;&lt;/span> reason: All metrics below target
Normal SuccessfulRescale 12m &lt;span class="o">(&lt;/span>x2 over 9h&lt;span class="o">)&lt;/span> horizontal-pod-autoscaler New size: 4&lt;span class="p">;&lt;/span> reason: pods metric http_requests_qps above target
Normal SuccessfulRescale 11m horizontal-pod-autoscaler New size: 5&lt;span class="p">;&lt;/span> reason: pods metric http_requests_qps above target
Normal SuccessfulRescale 9m40s &lt;span class="o">(&lt;/span>x2 over 12m&lt;span class="o">)&lt;/span> horizontal-pod-autoscaler New size: 2&lt;span class="p">;&lt;/span> reason: pods metric http_requests_qps above target
Normal SuccessfulRescale 9m24s &lt;span class="o">(&lt;/span>x4 over 10h&lt;span class="o">)&lt;/span> horizontal-pod-autoscaler New size: 3&lt;span class="p">;&lt;/span> reason: pods metric http_requests_qps above target
Normal SuccessfulRescale 7m54s &lt;span class="o">(&lt;/span>x3 over 9h&lt;span class="o">)&lt;/span> horizontal-pod-autoscaler New size: 2&lt;span class="p">;&lt;/span> reason: All metrics below target
Normal SuccessfulRescale 7m39s &lt;span class="o">(&lt;/span>x4 over 9h&lt;span class="o">)&lt;/span> horizontal-pod-autoscaler New size: 1&lt;span class="p">;&lt;/span> reason: All metrics below target
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>基于自定义指标比如每秒请求量进行应用的水平扩容相比 CPU/内存 作为依据更加靠谱，适用于大部分的 web 系统。在突发流量时可以进行快速扩容，通过对伸缩行为的控制，可以减少副本数的抖动。Promeheus 作为流行应用的监控系统，在 Adapter 和 Aggregate API 的支持下，可以作为伸缩的指标。&lt;/p>
&lt;p>目前 HPA 的 &lt;em>scale to 0&lt;/em> 还在 alpha 的阶段，还需要关注副本从 0 到 N 的实效性。如果最小副本数大于0 ，对某些服务来说又会占用资源。接下来，我们会为尝试解决 0 到 N 的性能，以及资源占用的问题。&lt;/p></description></item><item><title>Colima：MacOS 上的极简容器运行时和 Kubernetes（支持 m1）</title><link>https://atbug.com/containers-runtime-on-macos-with-colima/</link><pubDate>Sun, 26 Dec 2021 12:31:16 +0800</pubDate><guid>https://atbug.com/containers-runtime-on-macos-with-colima/</guid><description>
&lt;p>&lt;a href="https://github.com/abiosoft/colima">Colima&lt;/a> 是一个以最小化设置来在MacOS上运行容器运行时和 Kubernetes 的工具。支持 m1（文末讨论），同样也支持 Linux。&lt;/p>
&lt;p>Colima 的名字取自 Container on Lima。&lt;a href="https://github.com/lima-vm/lima">Lima&lt;/a> 是一个虚拟机工具，可以实现自动的文件共享、端口转发以及 containerd。&lt;/p>
&lt;p>Colima 实际上是通过 Lima 启动了名为 &lt;code>colima&lt;/code> 的虚拟机，使用虚拟机中的 containerd 作为容器运行时。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/26/colima.gif" alt="colima">&lt;/p>
&lt;h2 id="使用">使用&lt;/h2>
&lt;p>Colima 的使用很简单，执行下面的命令就可以创建虚拟机，默认是 Docker 的运行时。&lt;/p>
&lt;p>初次运行需要下载虚拟机镜像创建虚拟机，耗时因网络情况有所差异。之后，启动虚拟机就只需要 30s 左右的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start
INFO&lt;span class="o">[&lt;/span>0000&lt;span class="o">]&lt;/span> starting colima
INFO&lt;span class="o">[&lt;/span>0000&lt;span class="o">]&lt;/span> creating and starting ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>vm
INFO&lt;span class="o">[&lt;/span>0119&lt;span class="o">]&lt;/span> provisioning ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0119&lt;span class="o">]&lt;/span> provisioning in VM ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0133&lt;span class="o">]&lt;/span> restarting VM to &lt;span class="nb">complete&lt;/span> setup ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0133&lt;span class="o">]&lt;/span> stopping ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>vm
INFO&lt;span class="o">[&lt;/span>0136&lt;span class="o">]&lt;/span> starting ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>vm
INFO&lt;span class="o">[&lt;/span>0158&lt;span class="o">]&lt;/span> starting ... &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>docker
INFO&lt;span class="o">[&lt;/span>0159&lt;span class="o">]&lt;/span> &lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，在宿主机上就可以使用 Docker 相关的命令了：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
docker pull busybox
docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
busybox latest b34806a1af7a &lt;span class="m">2&lt;/span> weeks ago 1.41MB
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用 Lima 的命令行 &lt;code>limact&lt;/code>工具查看虚拟机的情况：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">limactl list
NAME STATUS SSH ARCH CPUS MEMORY DISK DIR
colima Running 127.0.0.1:64505 aarch64 &lt;span class="m">2&lt;/span> 2GiB 60GiB /Users/addo/.lima/colima
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看操作系统信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">uname -a
Darwin Addos-Macbook-Pro.local 21.2.0 Darwin Kernel Version 21.2.0: Sun Nov &lt;span class="m">28&lt;/span> 20:28:41 PST 2021&lt;span class="p">;&lt;/span> root:xnu-8019.61.5~1/RELEASE_ARM64_T6000 arm64
limactl shell colima uname -a
Linux lima-colima 5.13.0-22-generic &lt;span class="c1">#22-Ubuntu SMP Fri Nov 5 13:22:27 UTC 2021 aarch64 aarch64 aarch64 GNU/Linux&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者使用 Colima 的 &lt;code>ssh&lt;/code> 命令进入虚拟机：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># on host&lt;/span>
colima ssh
&lt;span class="c1"># in vm&lt;/span>
uname -a
Linux lima-colima 5.13.0-22-generic &lt;span class="c1">#22-Ubuntu SMP Fri Nov 5 13:22:27 UTC 2021 aarch64 aarch64 aarch64 GNU/Linux&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他运行时">其他运行时&lt;/h3>
&lt;p>也可以在创建的时候通过 &lt;code>--runtime containerd&lt;/code> 参数指定使用 Containerd 作为运行时。此时就需要使用 &lt;code>colima nerdctl&lt;/code> 来使用 &lt;code>nerdctl&lt;/code> 与 Containerd 进行交互。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start --runtime containerd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样，还可以创建一个 k3s 作为 Kubernetes 运行时：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start --with-kubernetes
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="demo">Demo&lt;/h2>
&lt;p>我们尝试启动一个 nginx 容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --rm -d --name nginx -p 8080:80 nginx:latest
docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
20d6c56e038b nginx:latest &lt;span class="s2">&amp;#34;/docker-entrypoint.…&amp;#34;&lt;/span> &lt;span class="m">9&lt;/span> seconds ago Up &lt;span class="m">8&lt;/span> seconds 0.0.0.0:8080-&amp;gt;80/tcp, :::8080-&amp;gt;80/tcp nginx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Colima 会自动配置端口转发：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -I http://localhost:8080
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
Server: nginx/1.21.4
Date: Sun, &lt;span class="m">26&lt;/span> Dec &lt;span class="m">2021&lt;/span> 04:17:22 GMT
Content-Type: text/html
Content-Length: &lt;span class="m">615&lt;/span>
Last-Modified: Tue, &lt;span class="m">02&lt;/span> Nov &lt;span class="m">2021&lt;/span> 14:49:22 GMT
Connection: keep-alive
ETag: &lt;span class="s2">&amp;#34;61814ff2-267&amp;#34;&lt;/span>
Accept-Ranges: bytes
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="虚拟机配置">虚拟机配置&lt;/h2>
&lt;p>Colima 启动的虚拟机默认是 2CPU、2GiB 内存 和 60GiB 存储。可以在创建时通过 &lt;code>--cpu&lt;/code> 、&lt;code>--memory&lt;/code> 和 &lt;code>--disk&lt;/code> 来分配更多资源。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima start --cpu &lt;span class="m">4&lt;/span> --memory &lt;span class="m">16&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以修改当前虚拟机的配置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">colima stop
colima start --cpu &lt;span class="m">4&lt;/span> --memory &lt;span class="m">16&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="同类工具比较">同类工具比较&lt;/h2>
&lt;p>其实有不少类似的工具，比如 kind、k3d 和 minikube 三种都是用来创建 Kubernetes 环境。我个人此前用的 k3d 就比较多。&lt;/p>
&lt;p>对于 Docker 容器环境，这三个其实都没有提供。minikube 的虚拟机中也有容器运行时，但是无法单纯安装 Docker 环境。&lt;/p>
&lt;p>对于 Kubernetes 环境来说，这几种都适合，相比 Colima 来说还支持创建多个集群（当前 Colima 最新版本是 0.2.2，多集群的支持也在开发中。估计 0.3.0 会提供，毕竟创建多个虚拟机就能实现）。但使用 Colima 的话，Kubernetes 和 Docker 可以共享镜像（本地镜像）和运行时。&lt;/p>
&lt;h2 id="不足">不足&lt;/h2>
&lt;h3 id="多集群的支持">多集群的支持&lt;/h3>
&lt;p>前面提到，目前还不支持创建多个 Kubernetes 集群，估计 0.3.0 会提供。&lt;/p>
&lt;h3 id="m1-的支持">m1 的支持&lt;/h3>
&lt;p>这里还是要说下 m1，我现在主要用 m1 的电脑，本地的容器运行时用的 Docker Desktop。&lt;/p>
&lt;p>前面我们有留意到虚拟机使用的是 &lt;code>aarch64&lt;/code> 架构系统，&lt;strong>对于某些不支持 arm64 的镜像还是无法运行&lt;/strong>。毕竟 Lima 是原生支持 m1，而不是使用 Rosetta 转译的 Docker Desktop。&lt;/p>
&lt;p>有兴趣的同学可以尝试用 Rosetta 转译 Lima。&lt;/p></description></item><item><title>OpenFaaS - 以自己的方式运行容器化函数</title><link>https://atbug.com/openfaas-case-study-zh/</link><pubDate>Fri, 17 Dec 2021 09:13:59 +0800</pubDate><guid>https://atbug.com/openfaas-case-study-zh/</guid><description>
&lt;p>&lt;strong>译者注：&lt;/strong>
本文篇幅较长，有助于了解 FaaS 和 OpenFaaS。作者分别从开发人员和运维人员的视角来了解 OpenFaaS，对了解新的技术是个很好的方式。&lt;/p>
&lt;p>本文翻译自 &lt;a href="https://twitter.com/iximiuz">Ivan Velichko&lt;/a> 的 &lt;a href="https://iximiuz.com/en/posts/openfaas-case-study/">OpenFaaS - Run Containerized Functions On Your Own Terms&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>长期以来，&lt;em>无服务器（serverless）&lt;/em> 对我来说无非就是 AWS Lambda 的代名词。Lambda 提供了一种方便的途径，可以将任意代码附加到平台事件（云实例的状态变更、DynamoDB 记录的更新或新的 SNS 消息）中。但是，我时不时会想到某个逻辑，但其又没大到足以有自己的服务，同时有不适合任何现有服务的范围。因此，我经常将其放入函数中，以便日后使用 CLI 命令或者 HTTP 调用来调用它。&lt;/p>
&lt;p>几年前，我来开了 AWS，自那以后，我一直怀念部署无服务器功能的便利性。因此，当我得知 &lt;a href="https://www.openfaas.com">OpenFaaS&lt;/a>
项目时惊喜万分。它将在 Kubernetes 集群上部署函数变得简单，甚至仅需要 Containerd 就可以部署到虚拟机上。&lt;/p>
&lt;p>有兴趣？那么继续！&lt;/p>
&lt;h2 id="无服务器与-faas">无服务器与 FaaS&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Serverless_computing">无服务器&lt;/a> 已成为一个流行词，目前其实际含义扔不够清晰。&lt;/p>
&lt;p>许多现代平台被视为 &lt;em>无服务器&lt;/em> 平台。在 AWS Fargate 或 GCP Cloud Run 上部署容器化服务？无服务器！在 Heroku 上运行应用程序？也可能是无服务器的。&lt;/p>
&lt;p>同时，我更喜欢将 &lt;a href="https://en.wikipedia.org/wiki/Function_as_a_service">FaaS&lt;/a> 视为一种具体的设计模式。按照 FaaS 范式，可以部署代码片段（响应某些外部时间执行的&lt;em>函数&lt;/em>）。这些函数与事件驱动程序中的回调类似，但是是运行在其他人的的服务器上。由于操作的是函数而不是服务器，顾名思义 FaaS 是无服务器的。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/20211217-at-001929.png" alt="">
&lt;em>&lt;a href="https://twitter.com/iximiuz/status/1465273596033609736?ref_src=twsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1465273596033609736%257Ctwgr%255E%257Ctwcon%255Es1_&amp;amp;ref_url=https%253A%252F%252Fiximiuz.com%252Fen%252Fposts%252Fopenfaas-case-study%252F">source&lt;/a>&lt;/em>&lt;/p>
&lt;p>&lt;strong>OpenFaaS 项目旨在将 Kubernetes 集群或者独立的虚拟机等低级基础设施转化为管理无服务器函数的高级平台。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>站在开发人员的角度&lt;/strong>，这样一个平台看起来是真的无服务器的 &amp;ndash; 你只需要知道特定的 CLI/UI/API 来处理 &lt;em>函数&lt;/em> 抽象。但&lt;strong>站在运维的角度&lt;/strong>，需要了解 OpenFaaS 如何使用 &lt;em>服务器&lt;/em> 来运行这些函数。&lt;/p>
&lt;p>就我而言，我经常既是开发又是运维，下面我将尝试从二者展开说明。然而，我认为在评估 UX 时，我们应该明确区分它们。&lt;/p>
&lt;h2 id="开发人员眼中的-openfaas">开发人员眼中的 OpenFaaS&lt;/h2>
&lt;p>OpenFaaS 创建于 2016 年，现在网上也有大量的教程。这里不会重复介绍，但可以通过以下链接了解：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.openfaas.com/deployment/">How to deploy OpenFaaS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/cli/templates/">Create Functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/cli/build/">Build Functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/cli/templates/#nodejs-12-node12-of-watchdog-template">Writing a Node.js function - step-by-step guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>相反，我将描述我所理解的 OpenFaaS。我希望有助于一些需要评估该技术是否解决其问题的人，以及那些希望更有效地使用该技术的人。&lt;/p>
&lt;h3 id="函数运行时">函数运行时&lt;/h3>
&lt;p>在进入正式编码之前，有必要了解下其未来的执行环境（又名运行时）。或者，简单说：&lt;/p>
&lt;ul>
&lt;li>如何启动函数&lt;/li>
&lt;li>如何组织 I/O 操作&lt;/li>
&lt;li>如何重置 / 终止函数&lt;/li>
&lt;li>如何隔离函数和调用&lt;/li>
&lt;/ul>
&lt;p>OpenFaaS 自带多个运行时模式，这些模式针对不同的场景定制。因此，不同的场景下上述问题的答案会略有不同。&lt;/p>
&lt;p>&lt;strong>OpenFaaS 函数在容器中运行&lt;/strong>，并且每个容器必须遵守&lt;a href="https://docs.openfaas.com/reference/workloads/">简单的约定&lt;/a> ：它作为监听在预设端口（默认为 &lt;em>8080&lt;/em>）上的 HTTP 服务器，临时存储并且是无状态的。&lt;/p>
&lt;p>然而，OpenFaaS 通过 &lt;em>函数 watchdog&lt;/em>（译者注：watchdog 不做翻译）模式避免了用户编写此类服务器。&lt;em>函数 watchdog&lt;/em> 是一种轻量级 HTTP 服务器，可以感知如何执行实际函数业务逻辑。因此，安装在容器中的所有内容加上作为入口点的 watchdog，就构成了函数的运行时环境。&lt;/p>
&lt;h4 id="经典-watchdog">经典 watchdog&lt;/h4>
&lt;p>从&lt;strong>最简单&lt;/strong>的开始，或者又是被称为&lt;a href="https://github.com/openfaas/classic-watchdog">&lt;em>经典&lt;/em> watchdog&lt;/a>：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396730767429.png" alt="">&lt;/p>
&lt;p>这种模式下，watchdog 启动了监听在 &lt;em>8080&lt;/em> 端口的轻量级 HTTP 服务器，每个进来的请求都会：&lt;/p>
&lt;ul>
&lt;li>读取请求头和请求体&lt;/li>
&lt;li>fork 或者 exec 包含实际函数的可执行文件&lt;/li>
&lt;li>将请求头和请求体写入到函数进程的 &lt;em>stdin&lt;/em>&lt;/li>
&lt;li>等待函数进程的退出（或者超市）&lt;/li>
&lt;li>读取函数进程的 &lt;em>stdout&lt;/em> 和 &lt;em>stderr&lt;/em>&lt;/li>
&lt;li>在 HTTP 响应中将去读的字节发送回调用方&lt;/li>
&lt;/ul>
&lt;p>上述逻辑类似于传统的 &lt;a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">通用网关接口（CGI）&lt;/a>。一方面，每次函数调用都启动单独的进程看起来不够高效，而另一方面，它确实超级方便，因为 &lt;strong>任何使用 &lt;em>stdio&lt;/em> 流进行 I/O 处理的程序（包括最喜欢的 CLI 工具）都可以部署为 OpenFaaS 函数&lt;/strong>。&lt;/p>
&lt;p>提起&lt;strong>隔离&lt;/strong>，我们有必要区分下&lt;em>函数&lt;/em>和&lt;em>调用&lt;/em>：&lt;/p>
&lt;ul>
&lt;li>OpenFaaS 中的不同函数始终分布在不同的容器中&lt;/li>
&lt;li>一个函数可以有一个或多个容器 —— 取决于缩放选项&lt;/li>
&lt;li>同一函数的独立调用可能会最终进入同一个容器&lt;/li>
&lt;li>同一函数的独立调用将始终使用不同的进程进行&lt;/li>
&lt;/ul>
&lt;h4 id="反向代理-watchdog">反向代理 watchdog&lt;/h4>
&lt;p>&lt;em>注意：使用 OpenFaaS 官方术语，本节讨论在 HTTP 模式下运行的 &lt;a href="https://github.com/openfaas/of-watchdog">of-watchdog&lt;/a>。但我个人认为称之为反向代理 watchdog 更加形象。&lt;/em>&lt;/p>
&lt;p>如果 &lt;strong>经典&lt;/strong> 运行时类似于 CGI，那么这个运行时模式类似于后来的 &lt;a href="https://en.wikipedia.org/wiki/FastCGI">FastCGI&lt;/a>。运行时希望在 watchdog 后面有一个长期运行的 HTTP 服务器，而不是每次函数调用时创建新的进程。这本质上是 &lt;a href="https://github.com/openfaas/of-watchdog/blob/a0289419078824f0a070860f84a6b383eb4f2169/README.md#1-http-modehttp">将 watchdog 组件变成反向代理&lt;/a>：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396740301372.png" alt="">&lt;/p>
&lt;p>当容器启动时，&lt;strong>反向代理&lt;/strong> watchdog 也会创建一个监听在 &lt;em>8080&lt;/em> 端口的轻量级 HTTP 服务器。然而，与 &lt;strong>经典&lt;/strong> watchdog 不同的是&lt;strong>反向代理&lt;/strong>watchdog 只创建一次函数的进程，并将其当成（长期运行的）上游服务器。然后，函数调用转变成到该上游的 HTTP 请求。&lt;/p>
&lt;p>然而，&lt;strong>反向代理&lt;/strong>模式并不为了取代&lt;strong>经典&lt;/strong>模式。&lt;strong>经典&lt;/strong>模式的强项在于其函数的编写非常简单。这也是没有 HTTP 服务器的代码的唯一选择。比如使用 Cobol、bash 或者 PowerShell 脚本等等编写的函数。&lt;/p>
&lt;p>何时该使用&lt;strong>反向代理&lt;/strong>运行时模式：&lt;/p>
&lt;ul>
&lt;li>函数需要在两次调用之间保持状态：
&lt;ul>
&lt;li>缓存&lt;/li>
&lt;li>持久连接（例如，保持从函数到数据库的连接打开）&lt;/li>
&lt;li>有状态函数 🥴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个函数启动一个进程可能开销很大，为每个调用带来了延迟&lt;/li>
&lt;li>你想运行一个（微）服务作为函数 🤔&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>根据 OpenFaaS 的创建者 &lt;a href="https://twitter.com/alexellisuk">Alex Ellis&lt;/a> 的解释，&lt;em>FaaS&lt;/em>，特别是 OpenFaaS，可以被视为在不依赖服务器抽象的情况下 &lt;a href="https://blog.alexellis.io/introducing-functions-as-a-service/">部署微服务的简化方式&lt;/a>。即 FaaS 是无服务器架构的规范示例。&lt;/p>
&lt;/blockquote>
&lt;p>因此，使用反向代理的方式，函数可以被看作是部署微服务的固执的方式。方便、快速、简单。但使用有状态函数时，要留意由于多个调用可能在同一个进程中结束而导致的警告：&lt;/p>
&lt;ul>
&lt;li>在一个进程中结束的并发调用可能会触发代码中的竞争条件（例如，一个带有全局变量的 Go 函数，而全局变量没有锁的保护）。&lt;/li>
&lt;li>在一个进程中结束的后续调用可能会导致交叉调用数据泄露（当然，就像传统微服务一样）。&lt;/li>
&lt;li>由于该进程在两次调用之间被复用，因此代码中的任何内存泄漏都不会被缓解。&lt;/li>
&lt;/ul>
&lt;h4 id="其他运行时模式">其他运行时模式&lt;/h4>
&lt;p>&lt;strong>经典&lt;strong>运行时模式在将函数结果发送回调用方之前缓冲了函数的整个响应。但如果响应的大小超出了容器的内存怎么办？OpenFaaS 提供了&lt;/strong>响应流&lt;/strong>&lt;a href="https://github.com/openfaas/of-watchdog/blob/a0289419078824f0a070860f84a6b383eb4f2169/README.md#3-streaming-fork-modestreaming---default">另一种运行时模式，该模式仍然为每个调用创建进程，但添加了&lt;/a>。&lt;/p>
&lt;p>另一个又去的场景是从函数中提供静态文件服务。&lt;a href="https://github.com/openfaas/of-watchdog/blob/a0289419078824f0a070860f84a6b383eb4f2169/README.md#4-static-modestatic">OpenFaaS 也有解决方案&lt;/a>。&lt;/p>
&lt;p>这可能是所有的内置运行时模式。但如果仍未满足需求，OpenFaaS 是一个开源项目！看下现有的watchdog（&lt;a href="https://github.com/openfaas/classic-watchdog">1&lt;/a> &amp;amp; &lt;a href="https://github.com/openfaas/of-watchdog">2&lt;/a>），简洁明了。因此，可以随时提交 PR 或者 issue，让整个社区因你的贡献收益。&lt;/p>
&lt;h3 id="编写函数">编写函数&lt;/h3>
&lt;p>此时，我们已经了解函数如何在配备了函数 watchdog 的容器中运行。那么最小的函数是什么样子的？&lt;/p>
&lt;p>下面的示例将简单的 shell 脚本封装到 OpenFaaS 函数中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># WARNING: Not for Production - No Security Hardening! #&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># This FROM is just to get the watchdog executable.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> ghcr.io/openfaas/classic-watchdog:0.2.0 as watchdog&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># FROM this line the actual runtime definion starts.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> alpine:latest&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Mandatory step - put the watchdog.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>watchdog /fwatchdog /usr/bin/fwatchdog&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Optionally - install extra packages, libs, tools, etc.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Function&amp;#39;s payload - script echoing its STDIN, a bit transformed.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;#!/bin/sh&amp;#39;&lt;/span> &amp;gt; /echo.sh&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;cat | rev | tr &amp;#34;[:lower:]&amp;#34; &amp;#34;[:upper:]&amp;#34;&amp;#39;&lt;/span> &amp;gt;&amp;gt; /echo.sh&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> chmod +x /echo.sh&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Point the watchdog to the actual thingy to run.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">fprocess&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/echo.sh&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Start the watchdog server.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;fwatchdog&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当构建、部署和调用时，上面的函数作为 &lt;em>回显服务器&lt;/em>，倒转并大写其输入。&lt;/p>
&lt;p>稍微高级点的例子：一个 Node.js &lt;em>Hello World&lt;/em> 脚本作为函数：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># WARNING: Not for Production - No Security Hardening! #&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">########################################################&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> ghcr.io/openfaas/classic-watchdog:0.2.0 as watchdog&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> node:17-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>watchdog /fwatchdog /usr/bin/fwatchdog&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;console.log(&amp;#34;Hello World!&amp;#34;)&amp;#39;&lt;/span> &amp;gt; index.js&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">fprocess&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node index.js&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;fwatchdog&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此，要编写一个简单的函数，只需要在 Dockerfile 中加入：&lt;/p>
&lt;ul>
&lt;li>实际脚本（或可执行文件）&lt;/li>
&lt;li>它的所有依赖项——软件包、操作系统库等&lt;/li>
&lt;li>首选的 watchdog&lt;/li>
&lt;/ul>
&lt;p>然后将 watchdog 指向该脚本（或可执行文件），并将 watchdog 作为入口。有点酷，因为：&lt;/p>
&lt;ul>
&lt;li>可以完全控制函数未来的运行时&lt;/li>
&lt;li>可以部署任何可以在容器中作为函数运行的东西&lt;/li>
&lt;/ul>
&lt;p>但上述方法有个明显的缺点 &amp;ndash; 一个生产就绪的 Dockerfile 可能有上百行。如果我只想运行一个简单的 Node.js/Python 脚本或者一个小的 Go 程序作为函数，要怎么处理 Dockerfile？就不能有一个占位符来粘贴代码片段？&lt;/p>
&lt;h4 id="功能模板">功能模板&lt;/h4>
&lt;p>OpenFaaS 的美妙之处在于，我们可以两者兼而有之 —— 使用 Dockerfile 进行低级修补或目标语言编写高级脚本！得益于丰富的功能模板库！&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ faas-cli template store list
NAME SOURCE DESCRIPTION
csharp openfaas Classic C# template
dockerfile openfaas Classic Dockerfile template
go openfaas Classic Golang template
java8 openfaas Java &lt;span class="m">8&lt;/span> template
...
node14 openfaas HTTP-based Node &lt;span class="m">14&lt;/span> template
node12 openfaas HTTP-based Node &lt;span class="m">12&lt;/span> template
node openfaas Classic NodeJS &lt;span class="m">8&lt;/span> template
php7 openfaas Classic PHP &lt;span class="m">7&lt;/span> template
python openfaas Classic Python 2.7 template
python3 openfaas Classic Python 3.6 template
...
python3-flask openfaas Python 3.7 Flask template
python3-http openfaas Python 3.7 with Flask and HTTP
...
golang-http openfaas Golang HTTP template
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述功能模板由 OpenFaaS 作者和社区精心只做。典型的模板附带一个复杂的 Dockerfile，指向虚拟处理程序函数。当引导新函数时，通过 &lt;code>faas-cli new&lt;/code> 命令来使用这些模板。例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ faas-cli new --lang python my-fn
Folder: my-fn created.
Function created in folder: my-fn
Stack file written: my-fn.yml
$ cat my-fn/handler.py
def handle&lt;span class="o">(&lt;/span>req&lt;span class="o">)&lt;/span>:
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34; PUT YOUR BUSINESS LOGIC HERE &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">return&lt;/span> req
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此，对于模板，编写函数的工作可以归结为简单地将业务逻辑放入响应的处理程序文件中。&lt;/p>
&lt;p>使用模板时，了解使用那种 &lt;em>watchdog&lt;/em> 和 &lt;em>模式&lt;/em> 很重要：&lt;/p>
&lt;ul>
&lt;li>使用&lt;strong>经典的&lt;/strong>类似 CGI 的 watchdog，处理程序通常被编写为接受和返回纯字符串的函数（例如：&lt;a href="https://github.com/openfaas/templates/blob/d8893afe3d1072840174911859c6f5db2986e814/template/python3/function/handler.py">python3&lt;/a>、&lt;a href="https://github.com/openfaas/templates/blob/d8893afe3d1072840174911859c6f5db2986e814/template/php7/function/src/Handler.php">php7&lt;/a>）&lt;/li>
&lt;li>在 &lt;strong>HTTP 模式下&lt;/strong>，使用 &lt;strong>of-watchdog&lt;/strong>时，处理程序看起来更像 HTTP 处理程序接受请求并返回响应结构（例如：&lt;a href="https://github.com/openfaas/python-flask-template/blob/12db680950b42c7cfcc7d21ba036bd1397d62eb7/template/python3-http/function/handler.py">python3-http&lt;/a>，&lt;a href="https://github.com/openfaas/templates/blob/d8893afe3d1072840174911859c6f5db2986e814/template/node17/function/handler.js">node17&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h4 id="函数商店">函数商店&lt;/h4>
&lt;p>你的最佳函数是什么？对，你不需要写。OpenFaaS 接受这种想法，并带来了&lt;a href="https://github.com/openfaas/store">函数商店&lt;/a>（经过社区测试并根据过往经验选择的 OpenFaaS 函数精选索引）。&lt;/p>
&lt;p>该商店包含一些有趣的函数，可以一键部署到现有的 OpenFaaS 中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ faas-cli store list
FUNCTION DESCRIPTION
NodeInfo Get info about the machine that you&lt;span class="s1">&amp;#39;r...
&lt;/span>&lt;span class="s1">alpine An Alpine Linux shell, set the &amp;#34;fproc...
&lt;/span>&lt;span class="s1">env Print the environment variables prese...
&lt;/span>&lt;span class="s1">sleep Simulate a 2s duration or pass an X-S...
&lt;/span>&lt;span class="s1">shasum Generate a shasum for the given input
&lt;/span>&lt;span class="s1">Figlet Generate ASCII logos with the figlet CLI
&lt;/span>&lt;span class="s1">curl Use curl for network diagnostics, pas...
&lt;/span>&lt;span class="s1">SentimentAnalysis Python function provides a rating on ...
&lt;/span>&lt;span class="s1">hey HTTP load generator, ApacheBench (ab)...
&lt;/span>&lt;span class="s1">nslookup Query the nameserver for the IP addre...
&lt;/span>&lt;span class="s1">SSL/TLS cert info Returns SSL/TLS certificate informati...
&lt;/span>&lt;span class="s1">Colorization Turn black and white photos to color ...
&lt;/span>&lt;span class="s1">Inception This is a forked version of the work ...
&lt;/span>&lt;span class="s1">Have I Been Pwned The Have I Been Pwned function lets y...
&lt;/span>&lt;span class="s1">Face Detection with Pigo Detect faces in images using the Pigo...
&lt;/span>&lt;span class="s1">Tesseract OCR This function brings OCR - Optical Ch...
&lt;/span>&lt;span class="s1">Dockerhub Stats Golang function gives the count of re...
&lt;/span>&lt;span class="s1">QR Code Generator - Go QR Code generator using Go
&lt;/span>&lt;span class="s1">Nmap Security Scanner Tool for network discovery and securi...
&lt;/span>&lt;span class="s1">ASCII Cows Generate a random ASCII cow
&lt;/span>&lt;span class="s1">YouTube Video Downloader Download YouTube videos as a function
&lt;/span>&lt;span class="s1">OpenFaaS Text-to-Speech Generate an MP3 of text using Google&amp;#39;&lt;/span>...
Docker Image Manifest Query Query an image on the Docker Hub &lt;span class="k">for&lt;/span> ...
face-detect with OpenCV Detect faces in images. Send a URL as...
Face blur by Endre Simo Blur out faces detected in JPEGs. Inv...
Left-Pad left-pad on OpenFaaS
normalisecolor Automatically fix white-balance in ph...
mememachine Turn any image into a meme.
Business Strategy Generator Generates a Business Strategy &lt;span class="o">(&lt;/span>using ...
Image EXIF Reader Reads EXIF information from an URL or...
Open NSFW Model Score images &lt;span class="k">for&lt;/span> NSFW &lt;span class="o">(&lt;/span>nudity&lt;span class="o">)&lt;/span> content.
Identicon Generator Create an identicon from a provided s...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些函数实际上是存储在 Docker Hub 或者 Quay 等公共库的容器镜像，可以自由复用。&lt;/p>
&lt;p>场景示例：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>env&lt;/code> 函数调试函数接收的HTTP标头&lt;/li>
&lt;li>使用 &lt;code>curl&lt;/code> 函数从 OpenFaaS 部署内部测试连接&lt;/li>
&lt;li>从运行多个副本的函数中使用 &lt;code>hey&lt;/code> 来增加负载&lt;/li>
&lt;/ul>
&lt;h3 id="函数的构建和部署">函数的构建和部署&lt;/h3>
&lt;p>由于函数是在容器中运行的，因此需要有人为这些容器构建镜像。无论你喜不喜欢，这都是开发人员的事情。OpenFaaS 提供了方便的 &lt;code>faas-cli build&lt;/code> 命令，但没有服务器端构建。因此，要么需要（在安装 Docker 的机器上）手动运行 &lt;code>faas-cli build&lt;/code>，要么使用 CI/CD 完成。&lt;/p>
&lt;p>接下来，构建好的镜像需要通过 &lt;code>faas-cli push&lt;/code> 到仓库。显然，这种仓库也应该可以从 OpenFaaS 服务器端访问。否则，使 用&lt;code>faas-cli deploy&lt;/code> 部署函数时会失败。&lt;/p>
&lt;p>开发人员的工作流程如下：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396975427765.png" alt="">&lt;/p>
&lt;h3 id="调用函数">调用函数&lt;/h3>
&lt;p>函数部署后，可以通过向 &lt;code>$API_HOST:$API_PORT/function/&amp;lt;fn-name&amp;gt;&lt;/code> 端点发送 GET、POST、PUT 或者 DELET HTTP 请求来调用它。常见的调用方式有：&lt;/p>
&lt;ul>
&lt;li>各种钩子（webhook）&lt;/li>
&lt;li>&lt;code>faas-cli invoke&lt;/code>&lt;/li>
&lt;li>&lt;strong>event connectors&lt;/strong>！&lt;/li>
&lt;/ul>
&lt;p>前两个选项相当简单。使用函数作为作为 webhook 处理器（GitHub、IFTTT 等）很方便，每个函数开发人员都已经安装了 &lt;code>faas-cli&lt;/code>，因此可以成为日常脚本编写的组成部分。&lt;/p>
&lt;h4 id="那什么是事件连接器">那什么是事件连接器？&lt;/h4>
&lt;p>在本文开头是我对 AWS Lambda 与 AWS 平台事件紧密集成的温暖回忆。请记住，可以在响应新 SQS/SNS 消息、新的 Kinesis 记录、EC2 实例生命周期等事件时调用 Lambda。OpenFaaS 函数是否存在类似的东西呢？&lt;/p>
&lt;p>显然，OpenFaaS 无法开箱即用地与任何生态系统集成。然而，它提供了一种名为&lt;a href="https://docs.openfaas.com/reference/triggers/#event-connector-pattern">&lt;strong>事件连接器&lt;/strong>&lt;/a>模式的通用解决方案。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396992441046.png" alt="">&lt;/p>
&lt;p>官方支持的连接器：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/openfaas/cron-connector">Cron connector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openfaas/mqtt-connector">MQTT connector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openfaas/nats-connector">NATS connector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/reference/triggers/#apache-kafka-openfaas-pro">Kafka connector&lt;/a> (需要&lt;strong>专业版&lt;/strong>订阅)&lt;/li>
&lt;/ul>
&lt;p>OpenFaaS 还提供了很小的&lt;a href="https://github.com/openfaas/connector-sdk">&lt;strong>连接器-sdk&lt;/strong>&lt;/a>库来简化连接器的开发。&lt;/p>
&lt;h2 id="运维眼中的-openfaas">运维眼中的 OpenFaaS&lt;/h2>
&lt;p>开发眼中的 OpenFaaS 是个黑盒，提供简单的 API 来部署和调用函数。然而，作为运维可能会从了解 一点 OpenFaaS 内部原理中受益。&lt;/p>
&lt;h3 id="openfaas-通用架构">OpenFaaS 通用架构&lt;/h3>
&lt;p>OpenFaaS 有一个简单但强大的架构，允许使用不同的基础设施作为后端。如果已经有了 Kubernetes 集群，可以通过&lt;a href="https://docs.openfaas.com/deployment/kubernetes/">在上面部署 OpenFaaS&lt;/a> 轻松将其变成 &lt;a href="https://docs.openfaas.com/deployment/kubernetes/">FaaS&lt;/a> 解决方案。但是如果旧的虚拟（或物理）机，仍然可以在上面安装 OpenFaaS，并获得差不多功能的更小的 FaaS 解决方案。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16396997846325.png" alt="">&lt;/p>
&lt;p>上面的架构中唯一面向用户的组件是 &lt;a href="https://github.com/openfaas/faas/tree/fe152ba69c591d584b1f183f9f5f209e29a9b049/gateway">API 网关&lt;/a>。OpenFaaS 的 API 网关：&lt;/p>
&lt;ul>
&lt;li>暴露 API 来管理和调用函数&lt;/li>
&lt;li>提供内置的 UI 来管理函数&lt;/li>
&lt;li>处理函数的自动缩放&lt;/li>
&lt;li>预计后面会有兼容的 OpenFaaS 提供商&lt;/li>
&lt;/ul>
&lt;p>因此，当开发人员运行 &lt;code>faas-cli deploy&lt;/code>、&lt;code>faas-cli list&lt;/code> 或使用 &lt;code>curl $API_URL/function/foobar&lt;/code> 调用函数等内容时，请求将发送到上述的 API 网关。&lt;/p>
&lt;p>上图中的另一个重要组成部分是  &lt;a href="https://github.com/openfaas/faas-provider">faas-provider&lt;/a>。它不是一个具体的组件，而更像是接口。任何实现&lt;a href="https://github.com/openfaas/faas-provider/blob/36474d89ca995ea0a7c064493258d9edec88fe3f/serve.go#L32-L96">（非常简洁）的提供商 API&lt;/a> 的软件都可以成为提供商。OpenFaaS 提供商：&lt;/p>
&lt;ul>
&lt;li>管理功能（部署、列表、缩放、删除）&lt;/li>
&lt;li>调用函数&lt;/li>
&lt;li>暴露一些系统信息&lt;/li>
&lt;/ul>
&lt;p>两个最注明的提供商是 &lt;a href="https://github.com/openfaas/faas-netes">faas-netes&lt;/a>（Kubernetes 上的 OpenFaaS）和 &lt;a href="https://github.com/openfaas/faasd">faasd&lt;/a>（Containerd 上的 OpenFaaS）。下面，将介绍他们的实现。&lt;/p>
&lt;h3 id="kubernetes-上的-openfaasfaas-nets">Kubernetes 上的 OpenFaaS（faas-nets）&lt;/h3>
&lt;p>&lt;a href="https://github.com/openfaas/faas-netes">当部署在 Kubernetes 上时&lt;/a>，OpenFaaS 利用了该平台开箱即用的强大原语。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16397005465805.png" alt="">&lt;/p>
&lt;p>关键要点：&lt;/p>
&lt;ul>
&lt;li>API 网关成为标准（部署+服务）对。因此，可以随心所欲地扩展它。也可以随心所欲地把它暴露出来&lt;/li>
&lt;li>每个函数也成为（部署+服务）对。可能不会直接处理函数，但对于 faas-netes，缩放变得就像调整相应的副本数一样简单&lt;/li>
&lt;li>高可用性和开箱即用的水平缩放 - 同一功能的 pod 可以（而且应该）跨多个集群节点运行。&lt;/li>
&lt;li>Kubernetes 作为一个数据库工作；例如，当运行 &lt;code>faas-cli list&lt;/code> 等命令来获取当前部署的函数列表时，faas-netes 只会将其转换为相应的 Kubernetes API 查询&lt;/li>
&lt;/ul>
&lt;h3 id="containerd-上的-openfaasfaasd">Containerd 上的 OpenFaaS（faasd）&lt;/h3>
&lt;p>对于没有使用 Kubernetes 集群的人来说，OpenFaaS 提供了名为 &lt;a href="https://github.com/openfaas/faasd">faasd&lt;/a> 的替代轻量级提供商。它可以安装在（虚拟或物理）服务器上，，并利用 &lt;a href="https://iximiuz.com/en/posts/containerd-command-line-clients/">containerd&lt;/a> 来管理容器。&lt;a href="https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#containerd">正如我之前写的那样&lt;/a>，容器是一个在 Docker 和 Kubernetes 下使用的较低级别的容器管理器。结合 &lt;a href="https://github.com/containernetworking/plugins">CNI 插件&lt;/a>，它成为编写容器调度器的构建组件，OpenFaaS 的 faasd 是个很好的讲究案例：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/17/16397012181479.png" alt="">&lt;/p>
&lt;p>关键要点：&lt;/p>
&lt;ul>
&lt;li>被设计为在 IoT 设备上或 VM 中运行&lt;/li>
&lt;li>使用 containerd 的原生 &lt;code>pause&lt;/code> （通过&lt;em>cgroup freezers&lt;/em>）和超快速函数冷启动快速扩展到零&lt;/li>
&lt;li>&lt;a href="https://metal.equinix.com/proximity/?wchannelid=ujj9b20qi5&amp;amp;wmediaid=hkkw4b4o5n">它可以在每台服务器上运行比 faas-netes 多十倍的函数&lt;/a>，并且可以有效地使用更便宜的硬件，包括树莓派&lt;/li>
&lt;li>containerd 和 faasd 作为 systemd 服务进行管理，因此会自动处理日志、重启等&lt;/li>
&lt;li>没有 Kubernetes DNS，但 faasd 确保 DNS 在函数之间共享以简化互操作&lt;/li>
&lt;li>containerd 扮演着数据库的角色（比如 &lt;code>faas-cli list&lt;/code> 变成了类似 &lt;code>ctr container list&lt;/code>的操作 ），所以如果服务器挂了，所有状态就会丢失，每个函数都需要重新部署&lt;/li>
&lt;li>没有开箱即用的高可用性或水平扩展（参见 &lt;a href="https://github.com/openfaas/faasd/issues/225">issue/225&lt;/a>）&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>对你所使用的软件有个好的心智模型是是有益的，它可以提高开发效率，防止单例场景的发生，并简化了故障排查。&lt;/p>
&lt;p>以 OpenFaaS 为例，区分开发人员和运维人员对系统的看法可能是个很好的思路。从&lt;strong>开发人员角度来看&lt;/strong>，这是一个简单而强大的无服务器解决方案，主要关注 FaaS 场景。该解决方案由一个用于管理和调用函数的简洁 API、一个涵盖开发人员工作流的命令行工具以及一个函数模板库组成。无服务器函数以不同的运行时模式（类 CGI、反向代理）在容器中运行，并提供不同的隔离和状态保障。&lt;/p>
&lt;p>从&lt;strong>运维人员的角度来看&lt;/strong>，OpenFaaS 是一个具有灵活架构的模块化系统，可以部署在不同类型的基础设施之上：从树莓派到裸机或虚拟机、以及成熟的 Kubernetes、OpenShift 或 Docker Swarm 集群。当然，每种选择都有其优缺点，需要详细评估取舍。但即使现有选项都不合适，简单的 &lt;em>faas-provider&lt;/em> 抽象允许开发自己的后端来运行无服务器功能。&lt;/p>
&lt;p>上述内容主要集中在 OpenFaaS 基础知识上。但是 OpenFaaS 也有一些高级功能。通过以下链接进一步了解：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.openfaas.com/reference/async/">使用 NATS 消息传递系统的异步函数调用&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.openfaas.com/architecture/autoscaling/">使用 Prometheus 和 AlertManager 自动缩放功能&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openfaas/faas-middleware/tree/ace4eb24749c0814850a56b23b0015232dd41c2a/concurrency-limiter">函数调用限制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openfaas.gumroad.com/l/serverless-for-everyone-else">使用 docker-compose 通过 faasd 运行有状态的工作负载&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="资源">资源&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.openfaas.com/">OpenFaaS 官方文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.alexellis.io/deploy-serverless-faasd-with-cloud-init/">一堆清晰的 OpenFaaS 用例&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.alexellis.io/cli-functions-with-openfaas/">使用 OpenFaaS 将任何 CLI 转换为函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openfaas.com/blog/introducing-faasd/">faasd 介绍、动机、主要用例&lt;/a>&lt;/li>
&lt;li>📖&lt;a href="https://openfaas.gumroad.com/l/serverless-for-everyone-else">面向其他人的无服务器&lt;/a>- 尽管有通用名称，但它是 faasd 的一个非常详细的指南&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>作者介绍：
Ivan Velichko
Software Engineer at heart, SRE at day job, Tech Storyteller at night.&lt;/p>
&lt;/blockquote></description></item><item><title>策略即代码：为了 OpenPolicyAgent 学 Rego？试试 Javascript</title><link>https://atbug.com/policy-as-code-with-pipy/</link><pubDate>Wed, 08 Dec 2021 07:49:37 +0800</pubDate><guid>https://atbug.com/policy-as-code-with-pipy/</guid><description>
&lt;p>距离上个版本 &lt;a href="https://mp.weixin.qq.com/s/uZ_Q5Fn3XpfUEHBOFxWdvg">用 Pipy 实现 OPA&lt;/a>，已经过去快半年了。当初使用Pipy 实现了可信镜像仓库的检查，那时的版本实现起来会稍微复杂，从策略仓库到证书创建到Admission Webhook 的创建都需要大量的人工操作，配置和逻辑也还是耦合在一起。&lt;/p>
&lt;p>这个版本安装和使用起来会更加简单。&lt;/p>
&lt;p>当初我用“不务正业”来形容 Pipy 实现准入控制，等看完这篇文章，欢迎留言说说你的看法。&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>还是继续上次的场景，在 Pod 创建时对 Pod 使用的镜像所在仓库进行检查，以及检查镜像的 tag 是否&lt;em>合法&lt;/em>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/08/untitled.jpg" alt="Untitled">&lt;/p>
&lt;p>这里借助 Pipy Repo 的能力，将&lt;strong>代表策略的脚本和配置&lt;/strong>交由 Repo 进行管理；Pipy 实例实时从 Pipy Repo 同步&lt;strong>策略&lt;/strong>，并进行&lt;strong>动态加载&lt;/strong>。&lt;/p>
&lt;p>同时 Pipy Repo 对外提供 REST API 来管理策略，对策略的修改更容易。也方便与企业现有管理后台进行对接。&lt;/p>
&lt;p>下面就开始部署验证，这里所使用的所有代码都已提交到&lt;a href="https://github.com/flomesh-io/demo-policy-as-code"> GitHub 仓库&lt;/a>：https://github.com/flomesh-io/demo-policy-as-code。&lt;/p>
&lt;h2 id="运行">运行&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">git clone https://github.com/flomesh-io/demo-policy-as-code.git
&lt;span class="nb">cd&lt;/span> demo-policy-as-code
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="准备">准备&lt;/h3>
&lt;h4 id="环境">环境&lt;/h4>
&lt;p>使用 Kubernetes 发行版 K3s 作为集群环境，集群的搭建不做过多说明。我用 &lt;a href="https://k3d.io%0A">k3d&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">k3d cluster create policy-as-code -p &lt;span class="s2">&amp;#34;6060:30060@server:0&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注：K3d 是在容器中运行 K3s，这里做了将容器的 &lt;code>30060&lt;/code> 端口映射到本地的 &lt;code>6060&lt;/code> 端口，后面会详细解释。&lt;/p>
&lt;h4 id="部署策略服务器">部署策略服务器&lt;/h4>
&lt;p>执行下面的命令部署策略服务器 Repo：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f repo/pipy-repo.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>确保 Pod 正常运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get po -n pipy
NAME READY STATUS RESTARTS AGE
pipy-repo-697bbd9f4b-94pld 1/1 Running &lt;span class="m">0&lt;/span> 10s
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="发布策略">发布策略&lt;/h4>
&lt;p>要使用的策略（脚本和配置）位于 &lt;code>./repo/scripts&lt;/code> 目录中。前面提到 Repo 提供了 REST API 来管理 codebase（策略）。&lt;/p>
&lt;p>这里提供了脚本 &lt;code>init-codebase.sh&lt;/code>，通过 &lt;code>curl&lt;/code> 命令将策略发布到策略服务器。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">./init-codebase.sh
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署策略引擎">部署策略引擎&lt;/h3>
&lt;p>这个版本中，使用 helm chart 完成证书的创建、服务的部署以及 Admission WebHook 的注册。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">helm install policy-as-code ./policy-as-code -n default
&lt;/code>&lt;/pre>&lt;/div>&lt;p>确保 Pod 正常运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get po -n pipy
kubectl get po -n pipy
NAME READY STATUS RESTARTS AGE
pipy-repo-697bbd9f4b-94pld 1/1 Running &lt;span class="m">0&lt;/span> 2m
policy-as-code-5867f9cdb9-9vwks 1/1 Running &lt;span class="m">0&lt;/span> 8s
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>在 &lt;code>./test&lt;/code> 目录中有三个 yaml 文件用于测试。&lt;/p>
&lt;p>&lt;strong>非法的镜像仓库：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f test/bad.yaml
Error from server &lt;span class="o">(&lt;/span>192.168.64.1:5000/hello-world:linux repo not start with any repo &lt;span class="o">[&lt;/span>docker.io, k8s.gcr.io&lt;span class="o">])&lt;/span>: error when creating &lt;span class="s2">&amp;#34;test/bad.yaml&amp;#34;&lt;/span>: admission webhook &lt;span class="s2">&amp;#34;validating-webhook.pipy.flomesh-io.cn&amp;#34;&lt;/span> denied the request: 192.168.64.1:5000/hello-world:linux repo not start with any repo &lt;span class="o">[&lt;/span>docker.io, k8s.gcr.io&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>非法的镜像 tag：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f test/bad2.yaml
Error from server &lt;span class="o">(&lt;/span>docker.io/library/hello-world:latest tag end with :latest&lt;span class="o">)&lt;/span>: error when creating &lt;span class="s2">&amp;#34;test/bad2.yaml&amp;#34;&lt;/span>: admission webhook &lt;span class="s2">&amp;#34;validating-webhook.pipy.flomesh-io.cn&amp;#34;&lt;/span> denied the request: docker.io/library/hello-world:latest tag end with :latest
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>合法的镜像&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f test/ok.yaml
pod/hello-world-success created
&lt;/code>&lt;/pre>&lt;/div>&lt;p>就这么结束了？当然没有，我们还要对策略进行动态的调整。&lt;/p>
&lt;p>继续下面的测试之前，执行 &lt;code>kubectl delete -f test/ok.yaml&lt;/code> 清理刚才创建的 Pod。&lt;/p>
&lt;h3 id="修改策略">修改策略&lt;/h3>
&lt;p>修改 &lt;code>./repo/scripts/config.json&lt;/code>文件，清空 &lt;code>invalidTagSuffixes&lt;/code> 数组中的内容。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;validRepoPrefixes&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;docker.io&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;k8s.gcr.io&amp;#34;&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;invalidTagSuffixes&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>**注意：**这里需要执行脚本 &lt;code>./init-codebase.sh&lt;/code> 更新策略。&lt;/p>
&lt;p>此时，再次尝试 apply &lt;code>test/bad2.yaml&lt;/code>。你会发现，这次 Pod 创建成功了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f test/bad2.yaml
pod/hello-world-bad-tag created
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们没有修改任何逻辑代码，仅仅修改了配置就完成了对 Pod 镜像检查逻辑的调整。可能有人会问，命令行太麻烦调试不方便，有没有更直观的方式？&lt;/p>
&lt;p>答案是：有！&lt;/p>
&lt;h3 id="图形用户界面">图形用户界面&lt;/h3>
&lt;p>Pipy Repo 提供了图形用户界面，方便脚本的开发和调试。详细信息可以参考&lt;a href="https://mp.weixin.qq.com/s/cDhPtNdng8_YZQpyFo5czw">快速入门 Pipy Repo&lt;/a>，了解图形用户界面的使用。&lt;/p>
&lt;p>还记得开头的地方我们为 K3d 容器做了端口映射：&lt;code>6060=&amp;gt;30060&lt;/code>，细心的你也可能发现我们为 Pipy Repo 创建了 NodePort Servce，node port 端口为 &lt;code>30060&lt;/code>。&lt;/p>
&lt;p>此时，本地启动一个 Pipy：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#k3d&lt;/span>
pipy http://localhost:6060 --admin-port&lt;span class="o">=&lt;/span>&lt;span class="m">6061&lt;/span>
&lt;span class="c1">#主机直接部署 k3s 请使用这条命令&lt;/span>
pipy http://localhost:30060 --admin-port&lt;span class="o">=&lt;/span>&lt;span class="m">6061&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在浏览器中打开 &lt;code>http://localhost:6060&lt;/code>，你会看到：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/08/20211208-at-003435.png" alt="">&lt;/p>
&lt;p>点击下面我们创建的 codebase &lt;code>/image-verify&lt;/code>，在左侧文件目录中可以找到我们修改后的 &lt;code>config.json&lt;/code>:&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/08/20211208-at-003512.png" alt="">&lt;/p>
&lt;p>在编辑器中编辑，改回原来的配置，然后点击 2 和 3 两个按钮&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/08/20211208-at-003659.png" alt="2021-12-08 at 00.36.59">&lt;/p>
&lt;h3 id="再次测试">再次测试&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#清理&lt;/span>
kubectl delete -f test/bad2.yaml
kubectl apply -f test/bad2.yaml
Error from server &lt;span class="o">(&lt;/span>docker.io/library/hello-world:latest tag end with :latest&lt;span class="o">)&lt;/span>: error when creating &lt;span class="s2">&amp;#34;test/bad2.yaml&amp;#34;&lt;/span>: admission webhook &lt;span class="s2">&amp;#34;validating-webhook.pipy.flomesh-io.cn&amp;#34;&lt;/span> denied the request: docker.io/library/hello-world:latest tag end with :latest
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，修改的结果体现在错误信息里了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Open Policy Agent (OPA) 为策略引擎带来了新的天地，但是使用 Rego 语言编写策略为使用带来了门槛。Pipy 以其流量编程、易扩展的特性结合 Repo 的 codebase 管理，可以轻松实现策略即代码。同时，资源消耗更少，性能更高（代理场景的特点）。&lt;/p></description></item><item><title>Kubernetes Deployment 的故障排查可视化指南（2021 中文版）</title><link>https://atbug.com/troubleshooting-kubernetes-deployment-zh-v2/</link><pubDate>Sat, 20 Nov 2021 18:29:19 +0800</pubDate><guid>https://atbug.com/troubleshooting-kubernetes-deployment-zh-v2/</guid><description>
&lt;p>将应用部署到 Kubernetes 时通常会使用 Deployment、Service、Ingress，整个应用从部署到正常运行，经历的流程很长。从 kubectl apply YAML 文件，经过 apiserver、controller manager、scheduler、kubelet、以及 CRI、CNI 等众多组件的协同工作。&lt;/p>
&lt;p>漫长的“行程”，Pod 也经历各种正常和不正常的状态变化，即使正常运行也会出现服务无法访问的问题。对于刚开始在 Kubernetes 平台开展工作的同学来说，故障的排查确实棘手。之前工作的时候，经常要协助排查各种问题。去年在 Learnk8s 上看到了关于 Deployment 故障排查的视图，我还参考做了当时整个平台的故障排查视图，包括了从项目源码、CICD 流水线、部署整个流程的故障排查参考。&lt;/p>
&lt;p>现在 Learnk8s 的 Deployment 排查指南更新了，也有了中文版本。&lt;/p>
&lt;hr>
&lt;p>年中翻译 Learnk8s 的文章&lt;a href="https://mp.weixin.qq.com/s/GKS3DJHm4p0Tjtj8nJRGmA">《Kubernetes 的自动伸缩你用对了吗？》&lt;/a> 时，与 Daniele Polencic 沟通时被问及是否能翻译故障排查的可视化指南。&lt;/p>
&lt;p>年中的时候就翻译完了，今天电报上被告知&lt;a href="https://learnk8s.io/troubleshooting-deployments">文章 A visual guide on troubleshooting Kubernetes deployments&lt;/a>已更新，排查视图较上一版有了部分的调整。&lt;/p>
&lt;p>原文：https://learnk8s.io/troubleshooting-deployments&lt;/p>
&lt;p>中文版PDF：https://learnk8s.io/a/a-visual-guide-on-troubleshooting-kubernetes-deployments/troubleshooting-kubernetes.zh_cn.v2.pdf&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/11/20/troubleshootingkuberneteszhcnv2.png" alt="troubleshooting-kubernetes.zh_cn.v2">&lt;/p></description></item><item><title>Kubernetes 上调试 distroless 容器</title><link>https://atbug.com/debug-distroless-container-on-kubernetes/</link><pubDate>Wed, 03 Nov 2021 07:40:40 +0800</pubDate><guid>https://atbug.com/debug-distroless-container-on-kubernetes/</guid><description>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>本文内容：&lt;/p>
&lt;ul>
&lt;li>介绍 distroless 镜像、作用以及简单的使用&lt;/li>
&lt;li>如何针对 distroless 容器的进行调试&lt;/li>
&lt;li>临时容器(v.1.18+)的使用&lt;/li>
&lt;/ul>
&lt;h2 id="distroless-镜像">Distroless 镜像&lt;/h2>
&lt;p>Distroless 容器，顾名思义使用 &lt;a href="https://github.com/GoogleContainerTools/distroless">Distroless 镜像&lt;/a>作为基础镜像运行的容器。&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;Distroless&amp;rdquo; 镜像只包含了你的应用程序以及其运行时所需要的依赖。不包含你能在标准 Linxu 发行版里的可以找到的包管理器、shells 或者其他程序。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/GoogleContainerTools/distroless">GoogleContainerTools/distroless&lt;/a> 针对不同语言提供了 distroless 镜像：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/base/README.md">gcr.io/distroless/static-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/base/README.md">gcr.io/distroless/base-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/java/README.md">gcr.io/distroless/java-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/cc/README.md">gcr.io/distroless/cc-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/nodejs/README.md">gcr.io/distroless/nodejs-debian11&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/distroless/blob/main/experimental/python3/README.md">gcr.io/distroless/python3-debian11&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="distroless-镜像有什么用">Distroless 镜像有什么用？&lt;/h2>
&lt;p>那些可能是构建镜像时需要的，但大部分并不是运行时需要的。这也是为什么&lt;a href="https://mp.weixin.qq.com/s/Y3GQI3hg5I8MHOV4iwVqiQ">上篇文章介绍 Buildpacks&lt;/a> 时说的一个 builder 的 stack 镜像包含构建时基础镜像和运行时基础镜像，这样可以做到镜像的最小化。&lt;/p>
&lt;p>其实控制体积并不是 distroless 镜像的主要作用。将运行时容器中的内容限制为应用程序所需的依赖，此外不应该安装任何东西。这种方式可能极大的提升容器的安全性，也是 distroless 镜像的最重要作用。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/11/02/16357706125816.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>这里并不会再深入探究 distroless 镜像，而是如何调试 distroless 容器&lt;/strong>&lt;/p>
&lt;p>没有了包管理器，镜像构建完成后就不能再使用类似 &lt;code>apt&lt;/code>、&lt;code>yum&lt;/code> 的包管理工具；没有了 &lt;code>shell&lt;/code>，容器运行后无法再进入容器。&lt;/p>
&lt;p>&lt;em>“就像一个没有任何门的房间，也无法安装门。”&lt;/em> Distroless 镜像在提升容器安全性的同时，也为调试增加了难度。&lt;/p>
&lt;h2 id="使用-distroless-镜像">使用 distroless 镜像&lt;/h2>
&lt;p>写个很简单的 golang 应用：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">defaultHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResponseWriter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Hello world!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">defaultHandler&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ListenAndServe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;:8080&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如使用 &lt;code>gcr.io/distroless/base-debian11&lt;/code> 作为 golang 应用的基础镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> golang:1.12 as build-env&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /go/src/app&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /go/src/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go get -d -v ./...&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go build -o /go/bin/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> gcr.io/distroless/base-debian11&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build-env /go/bin/app /&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/app&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用镜像创建 deployment&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl create deploy golang-distroless --image addozhang/golang-distroless-example:latest
$ kubectl get po
NAME READY STATUS RESTARTS AGE
golang-distroless-784bb4875-srmmr 1/1 Running &lt;span class="m">0&lt;/span> 3m2s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>尝试进入容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl &lt;span class="nb">exec&lt;/span> -it golang-distroless-784bb4875-srmmr -- sh
error: Internal error occurred: error executing &lt;span class="nb">command&lt;/span> in container: failed to &lt;span class="nb">exec&lt;/span> in container: failed to start &lt;span class="nb">exec&lt;/span> &lt;span class="s2">&amp;#34;b76e800eafa85d39f909f39fcee4a4ba9fc2f37d5f674aa6620690b8e2939203&amp;#34;&lt;/span>: OCI runtime &lt;span class="nb">exec&lt;/span> failed: &lt;span class="nb">exec&lt;/span> failed: container_linux.go:380: starting container process caused: exec: &lt;span class="s2">&amp;#34;sh&amp;#34;&lt;/span>: executable file not found in &lt;span class="nv">$PATH&lt;/span>: unknown
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何调试-distroless-容器">如何调试 Distroless 容器&lt;/h2>
&lt;h3 id="1-使用-distroless-debug-镜像">1. 使用 distroless debug 镜像&lt;/h3>
&lt;p>GoogleContainerTools 为每个 distroless 镜像都提供了 &lt;code>debug&lt;/code> tag，&lt;strong>适合在开发阶段进行调试&lt;/strong>。如何使用？替换容器的 base 镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> golang:1.12 as build-env&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /go/src/app&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /go/src/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go get -d -v ./...&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> go build -o /go/bin/app&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> gcr.io/distroless/base-debian11:debug # use debug tag here&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build-env /go/bin/app /&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/app&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重新构建镜像并部署，得益于&lt;code>debug&lt;/code>镜像中提供了 busybox shell 让我们可以 exec 到容器中。&lt;/p>
&lt;h3 id="2-debug-容器与共享进程命名空间">2. debug 容器与共享进程命名空间&lt;/h3>
&lt;p>同一个 pod 中可以运行多个容器，通过设置 &lt;code>pod.spec.shareProcessNamespace&lt;/code> 为 &lt;code>true&lt;/code>，来让同一个 Pod 中的&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/">多容器共享同一个进程命名空间&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>Share a single process namespace between all of the containers in a pod.
When this is set containers will be able to view and signal processes from
other containers in the same pod, and the first process in each container
will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both
be set. Optional: Default to false.&lt;/p>
&lt;/blockquote>
&lt;p>添加一个使用 &lt;code>ubuntu&lt;/code> 镜像的 &lt;code>debug&lt;/code> 容器，这里为了测试（后面解释）我们为原容器添加 &lt;code>securityContext.runAsUser: 1000&lt;/code>，模拟两个容器使用不同的 UID 运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">strategy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">shareProcessNamespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">addozhang/golang-distroless-example:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">golang-distroless-example&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">securityContext&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runAsUser&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1000&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">debug&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;sleep&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1d&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">securityContext&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capabilities&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">add&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">SYS_PTRACE&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更新 deployment 之后：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get po
NAME READY STATUS RESTARTS AGE
golang-distroless-85c4896c45-rkjwn 2/2 Running &lt;span class="m">0&lt;/span> 3m12s
$ kubectl get po -o json &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.items[].spec.containers[].name&amp;#39;&lt;/span>
golang-distroless-example
debug
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后通过 debug 容器来进入到 pod 中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl &lt;span class="nb">exec&lt;/span> -it golang-distroless-85c4896c45-rkjwn -c debug -- sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在容器中执行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ps -ef
UID PID PPID C STIME TTY TIME CMD
root &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:54 ? 00:00:00 /pause &lt;span class="c1"># infra 容器&lt;/span>
&lt;span class="m">1000&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:54 ? 00:00:00 /app &lt;span class="c1"># 原容器，UID 为 1000&lt;/span>
root &lt;span class="m">19&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:55 ? 00:00:00 sleep 1d &lt;span class="c1"># debug 容器&lt;/span>
root &lt;span class="m">25&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 14:55 pts/0 00:00:00 sh
root &lt;span class="m">32&lt;/span> &lt;span class="m">25&lt;/span> &lt;span class="m">0&lt;/span> 14:55 pts/0 00:00:00 ps -ef
&lt;/code>&lt;/pre>&lt;/div>&lt;p>尝试访问 进程 &lt;code>7&lt;/code> 的进程空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat /proc/7/environ
$ cat: /proc/7/environ: Permission denied
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们需要为 &lt;code>debug&lt;/code> 容器加上：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">securityContext&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capabilities&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">add&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">SYS_PTRACE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后再访问就正常了：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat /proc/7/environ
&lt;span class="nv">PATH&lt;/span>&lt;span class="o">=&lt;/span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME&lt;span class="o">=&lt;/span>golang-distroless-58b6c5f455-v9zkvSSL_CERT_FILE&lt;span class="o">=&lt;/span>/etc/ssl/certs/ca-certificates.crtKUBERNETES_PORT_443_TCP&lt;span class="o">=&lt;/span>tcp://10.43.0.1:443KUBERNETES_PORT_443_TCP_PROTO&lt;span class="o">=&lt;/span>&lt;span class="nv">tcpKUBERNETES_PORT_443_TCP_PORT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">443KUBERNETES_PORT_443_TCP_ADDR&lt;/span>&lt;span class="o">=&lt;/span>10.43.0.1KUBERNETES_SERVICE_HOST&lt;span class="o">=&lt;/span>10.43.0.1KUBERNETES_SERVICE_PORT&lt;span class="o">=&lt;/span>&lt;span class="nv">443KUBERNETES_SERVICE_PORT_HTTPS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">443KUBERNETES_PORT&lt;/span>&lt;span class="o">=&lt;/span>tcp://10.43.0.1:443HOME&lt;span class="o">=&lt;/span>/root
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样我们也可以访问进程的文件系统：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">$ &lt;span class="nb">cd&lt;/span> /proc/7/root
$ ls
app bin boot dev etc home lib lib64 proc root run sbin sys tmp usr var
&lt;/code>&lt;/pre>&lt;/div>&lt;p>无需修改容器的基础镜像，使用 &lt;code>pod.spec.shareProcessNamespace: true&lt;/code> 配合安全配置中增加 &lt;code>SYS_PTRACE&lt;/code> 特性，为 debug 容器赋予完整的 shell 访问来调试应用。但是修改 YAML 和安全配置只适合在测试环境使用，到了生产环境这些都是不允许的。&lt;/p>
&lt;p>我们就需要用到 &lt;code>kubectl debug&lt;/code> 了。&lt;/p>
&lt;h3 id="3-kubectl-debug">3. Kubectl debug&lt;/h3>
&lt;p>针对不同的资源 &lt;code>kubectl debug&lt;/code> 可以进行不同操作：&lt;/p>
&lt;ul>
&lt;li>负载：创建一个正在运行的 Pod 的拷贝，并可以修改部分属性。比如在拷贝中使用新版本的tag。&lt;/li>
&lt;li>负载：为运行中的 Pod 增加一个临时容器（下面介绍），使用临时容器中的工具调试，无需重启 Pod。&lt;/li>
&lt;li>节点：在节点上创建一个 Pod 运行在&lt;strong>节点的 host 命名空间&lt;/strong>，可以访问节点的文件系统。&lt;/li>
&lt;/ul>
&lt;h4 id="31-临时容器">3.1 临时容器&lt;/h4>
&lt;p>从 Kubernetes 1.18 之后开始，可以使用 &lt;code>kubectl&lt;/code> 为运行的 pod 添加一个临时容器。这个命令还处于 &lt;code>alpha&lt;/code> 阶段，因此需要在&lt;a href="k3d%20cluster%20create%20test%20--k3s-arg%20%22--kube-apiserver-arg=feature-gates=EphemeralContainers=true%22@">“feature gate”&lt;/a>中打开。&lt;/p>
&lt;p>在使用 k3d 创建 k3s 集群时，打开 &lt;code>EphemeralContainers&lt;/code> feature：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ k3d cluster create &lt;span class="nb">test&lt;/span> --k3s-arg &lt;span class="s2">&amp;#34;--kube-apiserver-arg=feature-gates=EphemeralContainers=true&amp;#34;&lt;/span>@
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后创建临时容器，创建完成后会直接进入容器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl debug golang-distroless-85c4896c45-rkjwn -it --image&lt;span class="o">=&lt;/span>ubuntu --image-pull-policy&lt;span class="o">=&lt;/span>IfNotPresent
&lt;span class="c1">#临时容器 shell&lt;/span>
$ apt update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt install -y curl
$ curl localhost:8080
Hello world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/11/02/20211102110330.png" alt="临时容器">&lt;/p>
&lt;p>值得注意的是，临时容器无法与原容器共享进程命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ps -ef
UID PID PPID C STIME TTY TIME CMD
root &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 02:59 pts/0 00:00:00 bash
root &lt;span class="m">3042&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> 03:02 pts/0 00:00:00 ps -ef
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以通过添加参数 &lt;code>--target=[container]&lt;/code> 来将临时容器挂接到目标容器。这里与 &lt;code>pod.spec.shareProcessNamespace&lt;/code> 并不同，&lt;strong>进程号为 1 的进程是目标容器的进程&lt;/strong>，而后者的进程是 infra 容器的进程 &lt;code>/pause&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl debug golang-distroless-85c4896c45-rkjwn -it --image&lt;span class="o">=&lt;/span>ubuntu --image-pull-policy&lt;span class="o">=&lt;/span>IfNotPresent --target&lt;span class="o">=&lt;/span>golang-distroless-example
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：目前的版本还不支持删除临时容器，参考 &lt;a href="https://github.com/kubernetes/kubernetes/issues/84764#issuecomment-872839644">issue&lt;/a>，支持的版本：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/11/02/20211102111319.png" alt="">&lt;/p>
&lt;h4 id="32-拷贝-pod-并添加容器">3.2 拷贝 Pod 并添加容器&lt;/h4>
&lt;p>除了添加临时容器以外，另一种方式就是创建一个 Pod 的拷贝，并添加一个容器。&lt;strong>注意这里的是普通容器，不是临时容器。&lt;/strong> 注意这里加上了 &lt;code>--share-processes&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl debug golang-distroless-85c4896c45-rkjwn -it --image&lt;span class="o">=&lt;/span>ubuntu --image-pull-policy&lt;span class="o">=&lt;/span>IfNotPresent --share-processes --copy-to&lt;span class="o">=&lt;/span>golang-distroless-debug
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意这里加上了 &lt;code>--share-processes&lt;/code>，会自动加上 &lt;code>pod.spec.shareProcessNamespace=true&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get po golang-distroless-debug -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.spec.shareProcessNamespace}&amp;#39;&lt;/span>
&lt;span class="nb">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：使用 &lt;code>kubectl debug&lt;/code> 调试，并不能为 pod 自动加上 &lt;code>SYS_PTRACE&lt;/code> 安全特性，这就意味着如果容器使用的 UID 不一致，就无法访问进程空间。&lt;/strong> 截止发文，&lt;a href="https://github.com/kubernetes/kubernetes/issues/97103#issuecomment-899382147">计划在 &lt;code>1.23&lt;/code> 中支持&lt;/a>。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>目前上面所有的都不适合在生产环境使用，无法在不修改 Pod 定义的情况下进行调试。&lt;/p>
&lt;p>期望 Kubernetes 1.23 版本之后 &lt;code>debug&lt;/code> 功能添加 &lt;code>SYS_PTRACE&lt;/code> 的支持。到时候，再尝试一下。&lt;/p></description></item><item><title>自动替换 Kubernetes 镜像</title><link>https://atbug.com/kubernetes-images-swapper/</link><pubDate>Wed, 06 Oct 2021 08:01:41 +0800</pubDate><guid>https://atbug.com/kubernetes-images-swapper/</guid><description>
&lt;p>前几天有朋友在问如何在某云上拉取 Tekton 的镜像，这种情况其实比较普遍不只是某云。工作中经常要用到过某些靠运气才能拉取到的镜像，这对工作来说真是极度的不友好。&lt;/p>
&lt;p>因此也萌生了个想法，维护一个后网络友好的仓库镜像，在 Pod 创建时将镜像仓库切换到自维护的仓库，从自维护的仓库拉取镜像。&lt;/p>
&lt;p>前几天&lt;a href="https://mp.weixin.qq.com/s/SL_yBvyhb5p6Lm1HieJBbA">体验了极狐Gitlab 的容器镜像库&lt;/a>，便是为这个想法做的准备。当然其他的云厂商也有提供针对个人版的免费镜像仓库和企业版仓库。&lt;/p>
&lt;p>正好 &lt;a href="https://mp.weixin.qq.com/s/uZ_Q5Fn3XpfUEHBOFxWdvg">Pipy 作为策略引擎&lt;/a>，非常适合实现这种策略的执行。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/05/20211005212733.png" alt="">&lt;/p>
&lt;h2 id="实现思路">实现思路&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/05/20211005210725.png" alt="">&lt;/p>
&lt;h3 id="admission-webhook">Admission Webhook&lt;/h3>
&lt;p>&lt;a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/">Kubernetes 动态准备控制&lt;/a> 的 &lt;code>MutatingWebhookConfiguration&lt;/code> 可以 hook Pod 的创建或者更新，然后调用目标服务对 Pod 资源对象进行 patch 操作。&lt;/p>
&lt;h3 id="策略引擎">策略引擎&lt;/h3>
&lt;p>Pipy 作为应用的核心，也就是 &lt;code>MutatingWebhookConfiguration&lt;/code> 的目标服务，以策略引擎的角色完成策略的执行。&lt;/p>
&lt;p>Pipy 支持从文件或者 HTTP 地址加载脚本，这里为了便于策略的更新，使用了后者。&lt;/p>
&lt;p>对于从 HTTP 地址加载脚本，HTTP 地址返回内容的第一行会作为 Pipy 的主脚本，Pipy 启动时会加载主脚本，其他的文件也会被缓存到内存中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#地址 http://localhost:6080/repo/registry-mirror/&lt;/span>
$ curl http://localhost:6080/repo/registry-mirror/
/main.js
/config.json
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pipy 会每隔 5s 检查脚本和配置文件的 &lt;code>etag&lt;/code>（就是文件的最后更新时间），假如与当前文件的 etag 不一致，则会缓存并重新加载。&lt;/p>
&lt;p>利用 Pipy 的这个特性，便可以策略和配置的准实时更新。&lt;/p>
&lt;h3 id="策略">策略&lt;/h3>
&lt;p>对于策略的部分，我们将其逻辑和配置进行了分离。配置部分，配置了需要进行替换的镜像的前缀，以及替换成的内容；而逻辑，这是对 &lt;code>MutatingWebhookConfiguration&lt;/code> 的 &lt;code>AdmissionReview&lt;/code> 的对象进行检查。&lt;/p>
&lt;p>配置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;registries&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;registry.gitlab.cn/flomesh/registry-mirror/tekton-pipeline&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如说，对于镜像 &lt;code>gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/controller:v0.28.1&lt;/code>，将 &lt;code>gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd&lt;/code> 替换成 &lt;code>registry.gitlab.cn/addozhang/registry-mirror/tekton-pipeline&lt;/code>。&lt;/p>
&lt;h2 id="demo">Demo&lt;/h2>
&lt;p>本文使用所有的&lt;a href="https://github.com/addozhang/registry-mirror">源码&lt;/a>都已上传到了 github。&lt;/p>
&lt;h3 id="脚本服务器">脚本服务器&lt;/h3>
&lt;p>既然选用了 HTTP 方式加载 Pipy 的脚本，那就需要实现一个脚本服务器。实现的方式有两种：使用脚本实现脚本服务器和使用 Pipy 内置的 Codebase。&lt;/p>
&lt;h4 id="使用脚本实现脚本服务器">使用脚本实现脚本服务器&lt;/h4>
&lt;p>根据需求定义两种路由：&lt;/p>
&lt;ul>
&lt;li>&lt;code>/repo/registry-mirror/&lt;/code>：返回脚本和配置的文件列表&lt;/li>
&lt;li>&lt;code>/repo/registry-mirror/[File Name]&lt;/code>：返回对应的文件的内容，同时需要在响应头添加 &lt;code>etag&lt;/code>，值是文件的更新时间&lt;/li>
&lt;/ul>
&lt;p>具体脚本如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="err">#&lt;/span>&lt;span class="nx">repo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">js&lt;/span>
&lt;span class="nx">pipy&lt;/span>&lt;span class="p">({&lt;/span>
&lt;span class="nx">_serveFile&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">filename&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="nx">filename&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">path&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">substring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">22&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">filename&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="nx">Message&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nx">bodiless&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">method&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s1">&amp;#39;HEAD&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">headers&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="s1">&amp;#39;etag&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">filename&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mtime&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;content-type&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">type&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">method&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s1">&amp;#39;HEAD&amp;#39;&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">readFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">filename&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="nx">Message&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">404&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="sb">`file &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">filename&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb"> not found`&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="p">),&lt;/span>
&lt;span class="nx">_router&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">algo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">URLRouter&lt;/span>&lt;span class="p">({&lt;/span>
&lt;span class="s1">&amp;#39;/repo/registry-mirror/&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Message&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;/main.js\n/config.json&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="s1">&amp;#39;/repo/registry-mirror/*&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">_serveFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;text/plain&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}),&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="nx">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">6080&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="nx">serveHTTP&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="nx">req&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">_router&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">path&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">)&lt;/span>&lt;span class="o">%&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ pipy repo.js
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> Module /repo.js
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="o">===============&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>Listen on :::6080&lt;span class="o">]&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> -----&amp;gt;&lt;span class="p">|&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="p">|&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> serveHTTP
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="p">|&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &amp;lt;-----&lt;span class="p">|&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span>
2021-10-05 21:40:25 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>listener&lt;span class="o">]&lt;/span> Listening on port &lt;span class="m">6080&lt;/span> at ::
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查路由：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ curl http://localhost:6080/repo/registry-mirror/
/main.js
/config.json
$ curl http://localhost:6080/repo/registry-mirror/main.js
&lt;span class="c1">#省略 main.js 的内容&lt;/span>
$ curl http://localhost:6080/repo/registry-mirror/config.json
&lt;span class="c1">#省略 config.json 的内容&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="使用-pipy-内置的-codebase">使用 Pipy 内置的 Codebase&lt;/h4>
&lt;p>在最新发布的 Pipy 内置了一个 Codebase，大家可以理解成脚本仓库，但是比单纯的仓库功能更加强大（后面会有文档介绍该特性）。&lt;/p>
&lt;p>目前版本的 Codebase 还未支持持久化的存储，数据都是保存在内存中。后续会提供 KV store 或者 git 类型的持久化支持。&lt;/p>
&lt;p>启动 Pipy 的 Codebase很简单：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ pipy
2021-10-05 21:49:08 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>codebase&lt;span class="o">]&lt;/span> Starting codebase service...
2021-10-05 21:49:08 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>listener&lt;span class="o">]&lt;/span> Listening on port &lt;span class="m">6060&lt;/span> at ::
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/10/05/20211005215007.png" alt="">&lt;/p>
&lt;p>对于新的 Codebase 控制台的使用，这里不做过多的介绍，直接使用 REST API 完成脚本的写入：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#创建 registry-mirror codebase，会自动创建一个空的 main.js&lt;/span>
$ curl -X POST http://localhost:6060/api/v1/repo/registry-mirror
&lt;span class="c1">#更新 main.js&lt;/span>
$ curl -X POST &lt;span class="s1">&amp;#39;http://localhost:6060/api/v1/repo/registry-mirror/main.js&amp;#39;&lt;/span> --data-binary &lt;span class="s1">&amp;#39;@scripts/main.js&amp;#39;&lt;/span>
&lt;span class="c1">#创建 config.json&lt;/span>
$ curl -X POST &lt;span class="s1">&amp;#39;http://localhost:6060/api/v1/repo/registry-mirror/config.json&amp;#39;&lt;/span> --data-binary &lt;span class="s1">&amp;#39;@scripts/config.json&amp;#39;&lt;/span>
&lt;span class="c1">#检查 codebase 的版本&lt;/span>
$ curl -s http://localhost:6060/api/v1/repo/registry-mirror &lt;span class="p">|&lt;/span> jq -r .version
&lt;span class="c1">#更新版本&lt;/span>
$ curl -X POST &lt;span class="s1">&amp;#39;http://localhost:6060/api/v1/repo/registry-mirror&amp;#39;&lt;/span> --data-raw &lt;span class="s1">&amp;#39;{&amp;#34;version&amp;#34;:2}&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装">安装&lt;/h3>
&lt;p>进入到项目的根目录中，执行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ helm install registry-mirror ./registry-mirror -n default
NAME: registry-mirror
LAST DEPLOYED: Tue Oct &lt;span class="m">5&lt;/span> 22:19:26 &lt;span class="m">2021&lt;/span>
NAMESPACE: default
STATUS: deployed
REVISION: &lt;span class="m">1&lt;/span>
TEST SUITE: None
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 webhook：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get mutatingwebhookconfigurations
NAME WEBHOOKS AGE
registry-mirror-webhook &lt;span class="m">1&lt;/span> 2m6s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查 pod 的启动日志：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl logs -n pipy -l &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>pipy
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>codebase&lt;span class="o">]&lt;/span> GET http://192.168.1.101:6060/repo/registry-mirror/ -&amp;gt; &lt;span class="m">21&lt;/span> bytes
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>codebase&lt;span class="o">]&lt;/span> GET /repo/registry-mirror/main.js -&amp;gt; &lt;span class="m">2213&lt;/span> bytes
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>codebase&lt;span class="o">]&lt;/span> GET /repo/registry-mirror/config.json -&amp;gt; &lt;span class="m">149&lt;/span> bytes
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> Module /main.js
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="o">===============&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>Listen on :::6443&lt;span class="o">]&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> -----&amp;gt;&lt;span class="p">|&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="p">|&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> acceptTLS
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="p">|&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="p">|&lt;/span>--&amp;gt; &lt;span class="o">[&lt;/span>tls-offloaded&lt;span class="o">]&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> decodeHTTPRequest
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> replaceMessage
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> encodeHTTPResponse --&amp;gt;&lt;span class="p">|&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &lt;span class="p">|&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span> &amp;lt;---------------------------------&lt;span class="p">|&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>config&lt;span class="o">]&lt;/span>
2021-10-05 14:19:28 &lt;span class="o">[&lt;/span>info&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>listener&lt;span class="o">]&lt;/span> Listening on port &lt;span class="m">6443&lt;/span> at ::
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>在&lt;a href="https://mp.weixin.qq.com/s/SL_yBvyhb5p6Lm1HieJBbA">上一篇&lt;/a>中我已经推送了 Tekton 的两个镜像到容器镜像库中，因此这里直接安装 tekton 进行测试。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/previous/v0.28.1/release.yaml
$ kubectl get pod -n tekton-pipelines
NAME READY STATUS RESTARTS AGE
tekton-pipelines-controller-75974fbfb8-f62dv 1/1 Running &lt;span class="m">0&lt;/span> 7m36s
tekton-pipelines-webhook-6cc478f7ff-mm5l9 1/1 Running &lt;span class="m">0&lt;/span> 7m36s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod -o json -n tekton-pipelines -l &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>tekton-pipelines-controller &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.items[].spec.containers[].image&amp;#39;&lt;/span>
registry.gitlab.cn/flomesh/registry-mirror/tekton-pipeline/controller:v0.28.1
$ kubectl get pod -o json -n tekton-pipelines -l &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>tekton-pipelines-webhook &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.items[].spec.containers[].image&amp;#39;&lt;/span>
registry.gitlab.cn/flomesh/registry-mirror/tekton-pipeline/webhook:v0.28.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的结果可以看到结果是符合预期的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>整个实现的策略部分加上配置，只有 70 多行的代码。并且实现了逻辑与配置的分离之后，后续的配置也都可以做到实时的更新而无需修改任何逻辑代码，更无需重新部署。&lt;/p>
&lt;p>但是目前的实现，是需要手动把镜像推送的自维护的镜像仓库中。实际上理想的情况是检查自维护的仓库中是否存在镜像（比如通过 REST API），如果未发现镜像，先把镜像拉取到本地，&lt;code>tag&lt;/code> 后再推送到自维护的仓库。不过这种操作，还是需要网络的畅通。当然也尝试过通过 REST API 触发 CICD Pipeline 的执行拉取镜像并 tag，但是极狐Gitlab 是部署在某云的环境上，同样也受困于网络问题。&lt;/p></description></item><item><title>ARM64 平台基于 openEuler + iSula 环境部署 Kubernetes</title><link>https://atbug.com/setup-kubernetes-running-with-isulad-on-openeuler/</link><pubDate>Thu, 02 Sep 2021 20:41:06 +0800</pubDate><guid>https://atbug.com/setup-kubernetes-running-with-isulad-on-openeuler/</guid><description>
&lt;p>为什么要在 arm64 平台上部署 Kubernetes，而且还是鲲鹏 920 的架构。说来话长 。。。 此处省略5000 字。&lt;/p>
&lt;p>介绍下系统信息；&lt;/p>
&lt;ul>
&lt;li>架构：鲲鹏 920(Kunpeng920)&lt;/li>
&lt;li>OS：openEuler 20.03 (LTS-SP1)&lt;/li>
&lt;li>CPU：4c&lt;/li>
&lt;li>内存：16G&lt;/li>
&lt;li>硬盘：若干&lt;/li>
&lt;/ul>
&lt;p>整个过程虽然参考了&lt;a href="https://bbs.huaweicloud.com/forum/thread-94271-1-1.html">鲲鹏论坛的帖子&lt;/a>，不过还是颇费周折。&lt;/p>
&lt;h3 id="tldr">TL;DR&lt;/h3>
&lt;p>整个过程中要注意 arm64 平台上安装 Kubernetes 及网络组件，需要使用 arm64 版本的镜像。&lt;/p>
&lt;h3 id="环境配置">环境配置&lt;/h3>
&lt;h4 id="1关闭-selinux">1.关闭 selinux&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#临时关闭&lt;/span>
setenforce &lt;span class="m">0&lt;/span>
&lt;span class="c1">#永久关闭 SELINUX=disabled&lt;/span>
vim /etc/sysconfig/selinux
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-关闭swap分区">2. 关闭swap分区&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#临时关闭&lt;/span>
swapoff -a
&lt;span class="c1">#永久关闭 注释 swap 行&lt;/span>
vim /etc/fstab
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-关闭防火墙">3. 关闭防火墙&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">systemctl stop firewalld
ssystemctl disable firewalld
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="4-网络配置">4. 网络配置&lt;/h4>
&lt;p>对iptables内部的nf-call需要打开的内生的桥接功能&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">vim /etc/sysctl.d/k8s.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">net.bridge.bridge-nf-call-iptables=1
net.bridge.bridge-nf-call-ip6tables=1
net.ipv4.ip_forward=1
vm_swappiness=0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改完成后执行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">modprobe br_netfilter
sysctl -p /etc/sysctl.d/k8s.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="5-添加-kubernetes-源">5. 添加 Kubernetes 源&lt;/h4>
&lt;p>在文件 &lt;code>/etc/yum.repos.d/openEuler.repo&lt;/code> 中追加如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-aarch64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装配置-isula">安装配置 iSula&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">yum install -y iSulad
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 iSula 配置，打开文件 &lt;code>/etc/isulad/daemon.json&lt;/code>，按照下面的部分：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;registry-mirrors&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;docker.io&amp;#34;&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;insecure-registries&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;rnd-dockerhub.huawei.com&amp;#34;&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;pod-sandbox-image&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;k8s.gcr.io/pause:3.2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">//&lt;/span> &lt;span class="err">按照对应&lt;/span> &lt;span class="err">Kubernetes&lt;/span> &lt;span class="err">版本进行修改，后面会有说明&lt;/span>
&lt;span class="nt">&amp;#34;network-plugin&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;cni&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;cni-bin-dir&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;cni-conf-dir&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;hosts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;unix:///var/run/isulad.sock&amp;#34;&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改之后重启 isulad&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">systemctl restart isulad
systemctl &lt;span class="nb">enable&lt;/span> isulad
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kubernetes-部署">Kubernetes 部署&lt;/h3>
&lt;h4 id="1-安装-kubeletkubeadmkubectl">1. 安装 kubelet、kubeadm、kubectl&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">yum install -y kubelet-1.20.0 kubeadm-1.20.0 kubectl-1.20.0
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-准备镜像">2. 准备镜像&lt;/h4>
&lt;p>由于某种未知的网络问提，会导致拉取 &lt;code>k8s.gcr.io&lt;/code> 的镜像失败。需要提前下载好。&lt;/p>
&lt;p>通过 &lt;code>kubeadm config images list --kubernetes-version 1.20.0&lt;/code> 命令，获取初始化所需的镜像。这里需要注意通过 &lt;code>--kubernetes-version&lt;/code> 参数指定版本号，否则 &lt;code>kubeadm&lt;/code> 是打印出最高的 &lt;code>1.20.x&lt;/code> 版本的初始化镜像（比如，1.20.x 的最高版本是 1.20.4）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">k8s.gcr.io/kube-apiserver:v1.20.0
k8s.gcr.io/kube-controller-manager:v1.20.0
k8s.gcr.io/kube-scheduler:v1.20.0
k8s.gcr.io/kube-proxy:v1.20.0
k8s.gcr.io/pause:3.2
k8s.gcr.io/etcd:3.4.13-0
k8s.gcr.io/coredns:1.7.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应的 arm64 版本镜像为：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">k8s.gcr.io/kube-apiserver-arm64:v1.20.0
k8s.gcr.io/kube-controller-manager-arm64:v1.20.0
k8s.gcr.io/kube-scheduler-arm64:v1.20.0
k8s.gcr.io/kube-proxy-arm64:v1.20.0
k8s.gcr.io/pause-arm64:3.2
k8s.gcr.io/etcd-arm64:3.4.2-0 #支持 arm64 的 3.4.x 的最高版本
k8s.gcr.io/coredns:1.7.0 #无需特别的 arm64 版本
&lt;/code>&lt;/pre>&lt;/div>&lt;p>凭“运气”下载好镜像后，再通过 &lt;code>isula tag&lt;/code> 命令修改成我们需要的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">isula tag k8s.gcr.io/kube-apiserver-arm64:v1.20.0 k8s.gcr.io/kube-apiserver:v1.20.0
isula tag k8s.gcr.io/kube-controller-manager-arm64:v1.20.0 k8s.gcr.io/kube-controller-manager:v1.20.0
isula tag k8s.gcr.io/kube-scheduler-arm64:v1.20.0 k8s.gcr.io/kube-scheduler:v1.20.0
isula tag k8s.gcr.io/kube-proxy-arm64:v1.20.0 k8s.gcr.io/kube-proxy:v1.20.0
isula tag k8s.gcr.io/pause-arm64:3.2 k8s.gcr.io/pause:3.2
isula tag k8s.gcr.io/etcd-arm64:3.4.2-0 k8s.gcr.io/etcd:3.4.13-0
isula tag k8s.gcr.io/coredns:1.7.0 k8s.gcr.io/coredns:1.7.0
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-初始化-master-节点">3. 初始化 master 节点&lt;/h4>
&lt;p>注意需要指定 &lt;code>--cri-socket&lt;/code> 参数使用 &lt;code>isulad&lt;/code> 的 API。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubeadm init --kubernetes-version v1.20.0 --cri-socket&lt;span class="o">=&lt;/span>/var/run/isulad.sock --pod-network-cidr&lt;span class="o">=&lt;/span>10.244.0.0/16
&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装成功的话，会看到如下的内容&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">Your Kubernetes control-plane has initialized successfully!
To start using your cluster, you need to run the following as a regular user:
mkdir -p &lt;span class="nv">$HOME&lt;/span>/.kube
sudo cp -i /etc/kubernetes/admin.conf &lt;span class="nv">$HOME&lt;/span>/.kube/config
sudo chown &lt;span class="k">$(&lt;/span>id -u&lt;span class="k">)&lt;/span>:&lt;span class="k">$(&lt;/span>id -g&lt;span class="k">)&lt;/span> &lt;span class="nv">$HOME&lt;/span>/.kube/config
Alternatively, &lt;span class="k">if&lt;/span> you are the root user, you can run:
&lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>/etc/kubernetes/admin.conf
You should now deploy a pod network to the cluster.
Run &lt;span class="s2">&amp;#34;kubectl apply -f [podnetwork].yaml&amp;#34;&lt;/span> with one of the options listed at:
https://kubernetes.io/docs/concepts/cluster-administration/addons/
Then you can join any number of worker nodes by running the following on each as root:
kubeadm join 12.0.0.9:6443 --token 0110xl.lqzlegbduz2qkdhr &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --discovery-token-ca-cert-hash sha256:42b13f5924a01128aac0d6e7b2487af990bc82701f233c8a6a4790187ea064af
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="4-配置集群环境">4. 配置集群环境&lt;/h4>
&lt;p>然后根据上面的输出进行配置&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">mkdir -p &lt;span class="nv">$HOME&lt;/span>/.kube
sudo cp -i /etc/kubernetes/admin.conf &lt;span class="nv">$HOME&lt;/span>/.kube/config
sudo chown &lt;span class="k">$(&lt;/span>id -u&lt;span class="k">)&lt;/span>:&lt;span class="k">$(&lt;/span>id -g&lt;span class="k">)&lt;/span> &lt;span class="nv">$HOME&lt;/span>/.kube/config
&lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>/etc/kubernetes/admin.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="5-向集群添加-node-节点">5. 向集群添加 Node 节点&lt;/h4>
&lt;p>重复前面的步骤：&lt;code>环境配置&lt;/code>、&lt;code>安装配置 iSula&lt;/code> 以及 &lt;code>Kubernetes 部署&lt;/code> 的 1 和 2。&lt;/p>
&lt;p>同样使用上面输出的命令，再加上 &lt;code>--cri-socket&lt;/code> 参数：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubeadm join 12.0.0.9:6443 --token 0110xl.lqzlegbduz2qkdhr &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --discovery-token-ca-cert-hash &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --cri-socket&lt;span class="o">=&lt;/span>/var/run/isulad.sock
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置网络插件">配置网络插件&lt;/h3>
&lt;p>完成 master 节点初始化并配置完集群环境后就可以执行 &lt;code>kubectl&lt;/code> 的命令了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get nodes
NAME STATUS ROLES AGE VERSION
host-12-0-0-9 NotReady control-plane,master 178m v1.20.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>看下节点，发现节点是 &lt;code>NotReady&lt;/code> 的状态，这是因为网络插件还没安装。如果此时通过命令 &lt;code>journalctl -uf kubelet&lt;/code> 查看 &lt;code>kubelet&lt;/code> 的日志，会看到日志提示网络插件没有 ready。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">kubelet.go:2160] Container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:iSulad: network plugin is not ready: cni config uninitialized
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还记得 isulad 的配置么？&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&amp;#34;network-plugin&amp;#34;: &amp;#34;cni&amp;#34;,
&amp;#34;cni-bin-dir&amp;#34;: &amp;#34;&amp;#34;, //使用默认 /opt/cni/bin
&amp;#34;cni-conf-dir&amp;#34;: &amp;#34;&amp;#34;, //使用默认 /etc/cni/net.d
&lt;/code>&lt;/pre>&lt;/div>&lt;p>实际上两个目录都是空的内容，如果目录不存在，先创建：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">mkdir -p /opt/cni/bin
mkdir -p /etc/cni/net.d
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里使用 &lt;code>calico&lt;/code> 做为网络插件，先下载 manifest。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">wget https://docs.projectcalico.org/v3.14/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为是 arm64 的硬件，同样需要使用对应 arm64 版本的镜像，先查看要用哪些镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">grep &lt;span class="s1">&amp;#39;image:&amp;#39;&lt;/span> calico.yaml &lt;span class="p">|&lt;/span> uniq
image: calico/cni:v3.14.2
image: calico/pod2daemon-flexvol:v3.14.2
image: calico/node:v3.14.2
image: calico/kube-controllers:v3.14.2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应的 arm64 版本，操作步骤参考上面，不再赘述。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">calico/cni:v3.14.2-arm64
calico/pod2daemon-flexvol:v3.14.2-arm64
calico/node:v3.14.2-arm64
calico/kube-controllers:v3.14.2-arm64
&lt;/code>&lt;/pre>&lt;/div>&lt;p>搞定镜像之后执行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f calico.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后就可以看到节点变成了 &lt;code>Ready&lt;/code> 状态。&lt;/p>
&lt;h3 id="测试">测试&lt;/h3>
&lt;p>通常都是用 nginx 的镜像创建 pod 进行测试，但是 nginx 并没有 arm64 的版本，这里就用 docker 官方提供的 &lt;code>hello-world&lt;/code> 镜像。没错，支持 arm64。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl run hello-world --image hello-world:latest --restart&lt;span class="o">=&lt;/span>Never
kubectl logs hello-world --previous
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">Hello from Docker!
This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the &amp;#34;hello-world&amp;#34; image from the Docker Hub.
(arm64v8)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.
To try something more ambitious, you can run an Ubuntu container with:
$ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID:
https://hub.docker.com/
For more examples and ideas, visit:
https://docs.docker.com/get-started/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">总结&lt;/h3>
&lt;p>至此，我们就完成了在鲲鹏平台上基于 openEuler + iSula 部署 Kubernetes 的工作。&lt;/p></description></item><item><title>Kubernetes 必备工具：2021</title><link>https://atbug.com/translation-kuberletes-essential-tools-2021/</link><pubDate>Thu, 15 Jul 2021 08:10:22 +0800</pubDate><guid>https://atbug.com/translation-kuberletes-essential-tools-2021/</guid><description>
&lt;p>有别于前些天的文章 - &lt;a href="https://mp.weixin.qq.com/s/uU2zmT5yyVcKZ5XmLSRqtg">常用的几款工具让 Kubernetes 集群上的工作更容易&lt;/a> 偏重于工具类来提升工作效率，今天这篇文章更加适合用来做选型时的参考。&lt;/p>
&lt;p>文档翻译自 &lt;a href="https://itnext.io/kubernetes-essential-tools-2021-def12e84c572">Kubernetes Essential Tools: 2021&lt;/a>，篇幅较长，做了部分增删。&lt;/p>
&lt;hr>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>在本文中，我将尝试总结我最喜欢的 &lt;a href="https://kubernetes.io/">Kubernetes&lt;/a> 工具，并特别强调最新的和鲜为人知但我认为会非常流行的工具。&lt;/p>
&lt;p>这只是我根据我的经验得出的个人清单，但为了避免偏见，我还将尝试提及每种工具的替代方案，以便你可以根据自己的需要进行比较和决定。我将尽可能缩短这篇文章并提供链接，以便你可以自行探索更多内容。我的目标是回答这个问题：“我如何在 Kubernetes 中做 X？” 通过描述不同软件开发任务的工具。&lt;/p>
&lt;h2 id="k3d">K3D&lt;/h2>
&lt;p>&lt;a href="https://k3d.io/">K3D&lt;/a> 是我最喜欢的在笔记本电脑上运行 Kubernetes (K8s) 集群的方式。它非常&lt;strong>轻巧且&lt;/strong>速度非常快。它是使用 &lt;strong>Docker&lt;/strong> 围绕 &lt;a href="https://k3s.io/">K3S&lt;/a> 的包装器。所以，你只需要 Docker 来运行它并且资源使用率非常低。唯一的问题是&lt;strong>它不完全符合 K8s 标准&lt;/strong>，但这不应该是本地开发的问题。对于测试环境，你可以使用其他解决方案。K3D 比 Kind 快，但 Kind 完全兼容。&lt;/p>
&lt;h3 id="备选">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://k3s.io/">&lt;strong>K3S&lt;/strong>&lt;/a> 物联网或者边缘计算&lt;/li>
&lt;li>&lt;a href="https://kind.sigs.k8s.io/">&lt;strong>Kind&lt;/strong>&lt;/a> 完全兼容 Kubernetes 的备选&lt;/li>
&lt;li>&lt;a href="https://microk8s.io/">&lt;strong>MicroK8s&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://minikube.sigs.k8s.io/docs/">&lt;strong>MiniKube&lt;/strong>&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="krew">Krew&lt;/h2>
&lt;p>&lt;a href="https://krew.sigs.k8s.io/">Krew&lt;/a> 是管理的必备工具 &lt;strong>Kubectl 插件&lt;/strong>，这是一个必须有任何 K8S 用户。我不会详细介绍超过 145 个可用&lt;a href="https://krew.sigs.k8s.io/plugins/">插件&lt;/a>，但至少安装 &lt;a href="https://github.com/ahmetb/kubectx">&lt;strong>kubens&lt;/strong>&lt;/a> 和 &lt;a href="https://github.com/ahmetb/kubectx">&lt;strong>kubectx&lt;/strong>&lt;/a>。&lt;/p>
&lt;h2 id="lens">Lens&lt;/h2>
&lt;p>&lt;a href="https://k8slens.dev/">Lens&lt;/a> 是适用于 SRE、Ops 和开发人员的 K8s &lt;strong>IDE&lt;/strong>。它适用于任何 Kubernetes 发行版：本地或云端。它快速、易于使用并提供实时可观察性。使用 Lens 可以非常轻松地管理多个集群。如果你是集群操作员，这是必须的。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263041512885.jpg" alt="">&lt;/p>
&lt;h3 id="备选-1">备选&lt;/h3>
&lt;ul>
&lt;li>对于那些喜欢轻量级终端替代品的人来说，&lt;a href="https://k9scli.io/">K9s&lt;/a> 是一个很好的选择。K9s 会持续观察 Kubernetes 的变化，并提供后续命令来与你观察到的资源进行交互。&lt;/li>
&lt;/ul>
&lt;h2 id="helm">Helm&lt;/h2>
&lt;p>&lt;a href="https://helm.sh/">Helm&lt;/a> 不需要介绍，它是 Kubernetes 最著名的包管理器。你应该在 K8s 中使用包管理器，就像在编程语言中使用它一样。Helm 允许你将应用程序打包到 &lt;a href="https://artifacthub.io/">Charts&lt;/a> 中，将复杂的应用程序抽象为易于定义、安装和更新的可重用简单组件。&lt;/p>
&lt;p>它还提供了强大的模板引擎。Helm 很成熟，有很多预定义的 charts，很好的支持，而且很容易使用。&lt;/p>
&lt;h3 id="备选-2">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://kustomize.io/">&lt;strong>Kustomize&lt;/strong>&lt;/a> 是 helm 的一个更新和伟大的替代品，它不使用模板引擎，而是一个覆盖引擎，在其中你有基本的定义和覆盖在它们之上。&lt;/li>
&lt;/ul>
&lt;h2 id="argocd">ArgoCD&lt;/h2>
&lt;p>我相信 &lt;a href="https://www.gitops.tech/">GitOps&lt;/a> 是过去十年中最好的想法之一。在软件开发中，我们应该使用单一的事实来源来跟踪构建软件所需的所有移动部分，而 &lt;strong>Git&lt;/strong> 是做到这一点的完美工具。我们的想法是拥有一个 Git 存储库，其中包含应用程序代码以及表示所需生产环境状态的基础设施 (&lt;a href="https://en.wikipedia.org/wiki/Infrastructure_as_Code">IaC&lt;/a>) 的声明性描述；以及使所需环境与存储库中描述的状态相匹配的自动化过程。&lt;/p>
&lt;blockquote>
&lt;p>GitOps: versioned CI/CD on top of declarative infrastructure. Stop scripting and start shipping.&lt;/p>
&lt;p>— Kelsey Hightower&lt;/p>
&lt;/blockquote>
&lt;p>尽管使用 &lt;a href="https://www.terraform.io/">Terraform&lt;/a> 或类似工具，你可以实现基础设施即代码（&lt;a href="https://en.wikipedia.org/wiki/Infrastructure_as_code">IaC&lt;/a>），但这还不足以将你在 Git 中的所需状态与生产同步。我们需要一种方法来持续监控环境并确保没有配置漂移。使用 Terraform，你将不得不编写脚本来运行&lt;code>terraform apply&lt;/code>并检查状态是否与 Terraform 状态匹配，但这既乏味又难以维护。&lt;/p>
&lt;p>Kubernetes 从头开始​​构建控制循环的思想，这意味着 Kubernetes 一直在监视集群的状态以确保它与所需的状态匹配，例如，运行的副本数量与所需的数量相匹配复制品。GitOps 的想法是将其扩展到应用程序，因此你可以将你的服务定义为代码，例如，通过定义 Helm Charts，并使用利用 K8s 功能的工具来监控你的应用程序的状态并相应地调整集群。也就是说，如果更新你的代码存储库或Helm Chart，生产集群也会更新。这是真正的&lt;a href="https://en.wikipedia.org/wiki/Continuous_deployment">持续部署&lt;/a>。核心原则是应用程序部署和生命周期管理应该自动化、可审计且易于理解。&lt;/p>
&lt;p>对我来说，这个想法是革命性的，如果做得好，将使组织能够更多地关注功能，而不是编写自动化脚本。这个概念可以扩展到软件开发的其他领域，例如，你可以将文档存储在代码中以跟踪更改的历史并确保文档是最新的；或使用&lt;a href="https://github.com/jamesmh/architecture_decision_record">ADR&lt;/a>跟踪架构决策。&lt;/p>
&lt;p>在我看来，在最好的 GitOps 工具 &lt;strong>Kubernetes&lt;/strong> 是 &lt;a href="https://argoproj.github.io/argo-cd/">ArgoCD&lt;/a>。你可以在&lt;a href="https://argoproj.github.io/argo-cd/core_concepts/">此处&lt;/a>阅读更多信息。ArgoCD 是 &lt;strong>Argo&lt;/strong> 生态系统的一部分，其中包括一些其他很棒的工具，其中一些我们将在稍后讨论。&lt;/p>
&lt;p>使用 &lt;strong>ArgoCD&lt;/strong>，你可以在代码存储库中拥有每个环境，你可以在其中定义该环境的所有配置。Argo CD 在指定的目标环境中自动部署所需的应用程序状态。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263046811430.jpg" alt="">&lt;/p>
&lt;p>ArgoCD 被实现为一个 kubernetes 控制器，它持续监控正在运行的应用程序并将当前的实时状态与所需的目标状态（如 Git 存储库中指定的）进行比较。ArgoCD 报告并可视化差异，并且可以自动或手动将实时状态同步回所需的目标状态。&lt;/p>
&lt;h3 id="备选-3">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://fluxcd.io/">Flux&lt;/a> 刚刚发布了一个具有许多改进的新版本。它提供了非常相似的功能。&lt;/li>
&lt;/ul>
&lt;h2 id="argo-工作流workflows和-argo-事件events">Argo 工作流（Workflows）和 Argo 事件（Events）&lt;/h2>
&lt;p>在 Kubernetes 中，你可能还需要运行批处理作业或复杂的工作流。这可能是你的数据管道、异步流程甚至 CI/CD 的一部分。最重要的是，你甚至可能需要运行对某些事件做出反应的驱动微服务，例如文件上传或消息发送到队列。对于所有这些，我们有 &lt;a href="https://argoproj.github.io/argo-workflows/">Argo Workflows&lt;/a> 和 &lt;a href="https://argoproj.github.io/argo-events/">Argo Events&lt;/a>。&lt;/p>
&lt;p>尽管它们是独立的项目，但它们往往会被部署在一起。&lt;/p>
&lt;p>Argo Workflows 是一个类似于 &lt;a href="https://airflow.apache.org/">Apache Airflow&lt;/a> 的编排引擎，但它是 Kubernetes 原生的。它使用自定义 CRD 来定义复杂的工作流程，使用 YAML 的步骤或 &lt;strong>DAG&lt;/strong>，这在 K8s 中感觉更自然。它有一个漂亮的 UI、重试机制、基于 cron 的作业、输入和输出跟踪等等。你可以使用它来编排数据管道、批处理作业等等。&lt;/p>
&lt;p>有时，你可能希望将管道与异步服务（如 &lt;strong>Kafka&lt;/strong> 等流引擎、队列、webhooks 或深度存储服务）集成。例如，你可能想要对上传到 S3 的文件等事件做出反应。为此，你将使用 &lt;a href="https://argoproj.github.io/argo-events/">Argo 事件（Event）&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263049343226.jpg" alt="">&lt;/p>
&lt;p>这两个工具组合为你的所有管道需求提供了一个简单而强大的解决方案，包括 CI/CD 管道，它允许你在 Kubernetes 中本地运行 CI/CD 管道。&lt;/p>
&lt;h3 id="备选-4">备选&lt;/h3>
&lt;ul>
&lt;li>对于 ML 管道，你可以使用 &lt;a href="https://www.kubeflow.org/">Kubeflow&lt;/a>。&lt;/li>
&lt;li>对于 CI/CD 管道，你可以使用 &lt;a href="https://tekton.dev/docs/pipelines/pipelines/">Tekton&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="kaniko">Kaniko&lt;/h2>
&lt;p>我们刚刚看到了如何使用 Argo Workflows 运行 Kubernetes 原生 &lt;strong>CI/CD&lt;/strong> 管道。一个常见的任务是构建 &lt;strong>Docker 镜像&lt;/strong>，这在 Kubernetes 中通常是乏味的，因为构建过程实际上是在容器本身上运行的，你需要使用变通方法来使用主机的 Docker 引擎。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263050297533.jpg" alt="">&lt;/p>
&lt;p>底线是你不应该使用 &lt;strong>Docker&lt;/strong> 来构建你的镜像：改用 &lt;a href="https://github.com/GoogleContainerTools/kaniko">&lt;strong>Kanico&lt;/strong>&lt;/a>。Kaniko 不依赖于 Docker 守护进程，而是完全在用户空间中执行 Dockerfile 中的每个命令。这使得在无法轻松或安全地运行 Docker 守护程序的环境中构建容器镜像成为可能，例如标准的 Kubernetes 集群。这消除了在 K8s 集群中构建镜像的所有问题。&lt;/p>
&lt;h2 id="istio">Istio&lt;/h2>
&lt;p>&lt;a href="https://istio.io/">Istio&lt;/a> 是市场上最著名的&lt;a href="https://en.wikipedia.org/wiki/Service_mesh">服务网格&lt;/a>，它是开源的并且非常受欢迎。我不会详细介绍什么是服务网格，因为它是一个巨大的话题，但是如果你正在构建&lt;a href="https://microservices.io/">微服务&lt;/a>，并且可能应该这样做，那么你将需要一个服务网格来管理通信、可观察性、错误处理、安全性。与其用重复的逻辑污染每个微服务的代码（译者：SDK 侵入），不如利用服务网格为你做这件事。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263052962147.jpg" alt="">&lt;/p>
&lt;p>简而言之，服务网格是一个专用的基础设施层，你可以将其添加到你的应用程序中。它允许你透明地添加可观察性、流量管理和安全性等功能，而无需将它们添加到你自己的代码中。&lt;/p>
&lt;p>如果 &lt;strong>Istio&lt;/strong> 用于运行微服务，尽管你可以在任何地方运行 Istio 并使用微服务，但 Kubernetes 已被一次又一次地证明是运行它们的最佳平台。&lt;strong>Istio&lt;/strong> 还可以将你的 K8s 集群扩展到其他服务，例如 VM，允许你拥有在迁移到 Kubernetes 时非常有用的混合环境。&lt;/p>
&lt;h3 id="备选-5">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://linkerd.io/">&lt;strong>Linkerd&lt;/strong>&lt;/a> 是一种更轻巧且可能更快的服务网格。Linkerd 从头开始​​为安全性而构建，包括&lt;a href="https://linkerd.io/2.10/features/automatic-mtls/">默认 mTLS&lt;/a>、&lt;a href="https://github.com/linkerd/linkerd2-proxy">使用 Rust 构建的数据平面&lt;/a>、&lt;a href="https://github.com/linkerd/linkerd2-proxy">内存安全语言&lt;/a>和&lt;a href="https://github.com/linkerd/linkerd2/blob/main/SECURITY_AUDIT.pdf">定期安全审计&lt;/a>等功能&lt;/li>
&lt;li>&lt;a href="https://www.consul.io/">&lt;strong>Consul&lt;/strong>&lt;/a> 是为任何运行时和云提供商构建的服务网格，因此它非常适合跨 K8s 和云提供商的混合部署。如果不是所有的工作负载都在 Kubernetes 上运行，这是一个不错的选择。&lt;/li>
&lt;/ul>
&lt;h2 id="argo-rollouts">Argo Rollouts&lt;/h2>
&lt;p>我们已经提到，你可以使用 Kubernetes 使用 Argo Workflows 或使用 Kanico 构建图像的类似工具来运行 CI/CD 管道。下一个合乎逻辑的步骤是继续并进行持续部署。由于涉及高风险，这在真实场景中是极具挑战性的，这就是为什么大多数公司只做持续交付，这意味着他们已经实现了自动化，但他们仍然需要手动批准和验证，这个手动步骤是这是因为团队&lt;strong>不能完全信任他们的自动化&lt;/strong>。&lt;/p>
&lt;p>那么，你如何建立这种信任以摆脱所有脚本并完全自动化从源代码到生产的所有内容？答案是：可观察性。你需要将资源更多地集中在指标上，并收集准确表示应用程序状态所需的所有数据。目标是使用一组指标来建立这种信任。如果你在 &lt;a href="https://prometheus.io/">Prometheus&lt;/a> 中拥有所有数据，那么你可以自动部署，因为你可以根据这些指标自动逐步推出应用程序。&lt;/p>
&lt;p>简而言之，你需要比 K8s 开箱即用的&lt;a href="https://www.educative.io/blog/kubernetes-deployments-strategies">&lt;strong>滚动更新&lt;/strong>&lt;/a>更高级的部署技术。我们需要使用&lt;a href="https://semaphoreci.com/blog/what-is-canary-deployment">金丝雀部署&lt;/a>进行渐进式交付。目标是逐步将流量路由到应用程序的新版本，等待收集指标，分析它们并将它们与预定义的规则进行匹配。如果一切正常，我们增加流量；如果有任何问题，我们会回滚部署。
要在 Kubernetes 中执行此操作，你可以使用提供 Canary 发布等的 Argo Rollouts 。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://kubernetes.io/docs/concepts/architecture/controller/">Argo Rollouts&lt;/a> 是一个 &lt;a href="https://kubernetes.io/docs/concepts/architecture/controller/">Kubernetes 控制器&lt;/a>和一组 &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">CRD&lt;/a>，可提供高级部署功能，例如蓝绿、金丝雀、金丝雀分析、实验和向 Kubernetes 的渐进式交付功能。&lt;/p>
&lt;/blockquote>
&lt;p>尽管像 &lt;a href="https://istio.io/">Istio&lt;/a> 这样的服务网格提供 Canary 发布，但 Argo Rollouts 使这个过程变得更加容易并且以开发人员为中心，因为它是专门为此目的而构建的。除此之外，Argo Rollouts 可以与任何服务网格集成。&lt;/p>
&lt;p>Argo Rollouts 功能：&lt;/p>
&lt;ul>
&lt;li>蓝绿更新策略&lt;/li>
&lt;li>金丝雀更新策略&lt;/li>
&lt;li>细粒度、加权的流量转移&lt;/li>
&lt;li>自动回滚和促销或人工判断&lt;/li>
&lt;li>可定制的指标查询和业务 KPI 分析&lt;/li>
&lt;li>入口控制器集成：NGINX、ALB&lt;/li>
&lt;li>服务网格集成：Istio、Linkerd、SMI&lt;/li>
&lt;li>指标提供者集成：Prometheus、Wavefront、Kayenta、Web、Kubernetes Jobs&lt;/li>
&lt;/ul>
&lt;h3 id="备选-6">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://istio.io/">Istio&lt;/a> 作为 Canary 版本的服务网格。Istio 不仅仅是一个渐进式交付工具，它还是一个完整的服务网格。Istio 不会自动部署，Argo Rollouts 可以与 Istio 集成来实现这一点。&lt;/li>
&lt;li>&lt;a href="https://flagger.app/">Flagger&lt;/a> 与 Argo Rollouts 非常相似，并且与 &lt;a href="https://fluxcd.io/">Flux&lt;/a> 很好地集成在一起，因此如果你使用 Flux，请考虑使用 Flagger。&lt;/li>
&lt;li>&lt;a href="https://spinnaker.io/">Spinnaker&lt;/a> 是 Kubernetes 的第一个持续交付工具，它具有许多功能，但使用和设置起来有点复杂。&lt;/li>
&lt;/ul>
&lt;h2 id="crossplane">Crossplane&lt;/h2>
&lt;p>&lt;a href="https://crossplane.io/">&lt;strong>Crossplane&lt;/strong>&lt;/a> 是我最喜欢的 K8s 工具，我对这个项目感到非常兴奋，因为它给 Kubernetes 带来了一个关键的缺失部分：像管理 K8s 资源一样管理第三方服务。这意味着，你可以使用 &lt;strong>YAML&lt;/strong> 中定义的 K8s 资源来配置云提供商数据库，例如 &lt;a href="https://aws.amazon.com/rds/">&lt;strong>AWS RDS&lt;/strong>&lt;/a> 或 &lt;strong>GCP Cloud SQL&lt;/strong>，就像你在 K8s 中配置数据库一样。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263059248680.jpg" alt="">&lt;/p>
&lt;p>使用 Crossplane，无需使用不同的工具和方法分离基础设施和代码。&lt;strong>你可以使用 K8s 资源定义一切&lt;/strong>。这样，你就无需学习 &lt;a href="https://www.terraform.io/">Terraform&lt;/a> 等新工具并将它们分开保存。&lt;/p>
&lt;blockquote>
&lt;p>Crossplane 是一个开源 Kubernetes 附加组件，它使平台团队能够组装来自多个供应商的基础设施，并公开更高级别的自助 API 供应用程序团队使用，而无需编写任何代码。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Crossplane&lt;/strong> 扩展了你的 Kubernetes 集群，为你提供适用于任何基础架构或托管云服务的 &lt;strong>CRD&lt;/strong>。此外，它允许你完全实现持续部署，因为与 Terraform 等其他工具相反，Crossplane 使用现有的 K8s 功能（例如控制循环）来持续观察你的集群并自动检测任何对其起作用的配置漂移。例如，如果你定义了一个托管数据库实例并且有人手动更改它，Crossplane 将自动检测问题并将其设置回以前的值。这将实施基础设施即代码和 GitOps 原则。Crossplane 与 ArgoCD 配合使用效果很好，它可以查看源代码并确保你的代码存储库是唯一的真实来源，并且代码中的任何更改都会传播到集群以及外部云服务。如果没有 Crossplane，你只能在 K8s 服务中实现 GitOps，而不能在不使用单独进程的情况下在云服务中实现，现在你可以做到这一点，这太棒了。&lt;/p>
&lt;h3 id="备选-7">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.terraform.io/">Terraform&lt;/a> 是最著名的 IaC 工具，但它不是 K8s 原生的，需要新技能并且不会自动监视配置漂移。&lt;/li>
&lt;li>&lt;a href="https://www.pulumi.com/">Pulumi&lt;/a> 是一种 Terraform 替代品，它使用开发人员可以测试和理解的编程语言工作。&lt;/li>
&lt;/ul>
&lt;h2 id="knative">Knative&lt;/h2>
&lt;p>如果你在云中开发应用程序，你可能已经使用了一些无服务器技术，例如 &lt;a href="https://aws.amazon.com/lambda/">AWS Lambda &lt;/a>，它是一种称为 &lt;a href="https://en.wikipedia.org/wiki/Function_as_a_service">FaaS&lt;/a> 的事件驱动范例。&lt;/p>
&lt;p>我过去已经讨论过 &lt;a href="https://en.wikipedia.org/wiki/Serverless_computing">Serverless&lt;/a>，因此请查看我&lt;a href="https://itnext.io/scaling-my-app-serverless-vs-kubernetes-cdb8adf446e1">之前的文章&lt;/a>以了解更多信息。Serverless 的问题在于它与云提供商紧密耦合，因为提供商可以为事件驱动的应用程序创建一个很好的生态系统。&lt;/p>
&lt;p>对于 Kubernetes，如果你希望将函数作为代码运行并使用事件驱动架构，那么你最好的选择是 &lt;a href="https://itnext.io/scaling-my-app-serverless-vs-kubernetes-cdb8adf446e1">Knative&lt;/a>。Knative 旨在在 Kubernetes 上运行函数，在 Pod 之上创建一个抽象。&lt;/p>
&lt;p>特点：&lt;/p>
&lt;ul>
&lt;li>针对常见应用程序用例的具有更高级别抽象的重点 API。&lt;/li>
&lt;li>在几秒钟内建立一个可扩展、安全、无状态的服务。&lt;/li>
&lt;li>松散耦合的功能让你可以使用所需的部分。&lt;/li>
&lt;li>可插拔组件让你可以使用自己的日志记录和监控、网络和服务网格。&lt;/li>
&lt;li>Knative 是可移植的：在 Kubernetes 运行的任何地方运行它，不用担心供应商锁定。&lt;/li>
&lt;li>惯用的开发者体验，支持 GitOps、DockerOps、ManualOps 等常用模式。&lt;/li>
&lt;li>Knative 可以与常见的工具和框架一起使用，例如 Django、Ruby on Rails、Spring 等等。&lt;/li>
&lt;/ul>
&lt;h3 id="备选-8">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://argoproj.github.io/argo-events/">Argo Events&lt;/a> 为 Kubernetes 提供了一个事件驱动的工作流引擎，可以与 AWS Lambda 等云引擎集成。它不是 FaaS，而是为 Kubernetes 提供了一个事件驱动的架构。&lt;/li>
&lt;li>&lt;a href="https://www.openfaas.com/">OpenFaas&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="kyverno">Kyverno&lt;/h2>
&lt;p>Kubernetes 提供了极大的灵活性，以赋予敏捷的自治团队权力，但能力越大，责任越大。必须有一组&lt;strong>最佳实践和规则&lt;/strong>，以确保以一致且有凝聚力的方式来部署和管理符合公司政策和安全要求的工作负载。&lt;/p>
&lt;p>有几种工具可以实现这一点，但没有一个是 Kubernetes 原生的…… 直到现在。&lt;a href="https://kyverno.io/">Kyverno&lt;/a> 是为 Kubernetes 设计的策略引擎，策略作为 Kubernetes 资源进行管理，并且不需要新的语言来编写策略。Kyverno 策略可以验证、改变和生成 Kubernetes 资源。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263062593080.jpg" alt="">&lt;/p>
&lt;p>你可以应用有关最佳实践、网络或安全性的任何类型的策略。例如，你可以强制所有服务都有标签或所有容器都以非 root 身份运行。你可以在&lt;a href="https://github.com/kyverno/policies/">此处&lt;/a>查看一些政策示例。策略可以应用于整个集群或给定的命名空间。你还可以选择是只想审核策略还是强制执行它们以阻止用户部署资源。&lt;/p>
&lt;h3 id="备选-9">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.openpolicyagent.org/">Open Policy Agent&lt;/a> 是著名的云原生基于策略的控制引擎。它使用自己的声明性语言，并且可以在许多环境中运行，而不仅仅是在 Kubernetes 上。它比 &lt;a href="https://kyverno.io/">Kyverno&lt;/a> 更难管理，但更强大。&lt;/li>
&lt;/ul>
&lt;h2 id="kubevela">Kubevela&lt;/h2>
&lt;p>Kubernetes 的一个问题是开发人员需要非常了解和理解平台和集群配置。许多人会争辩说 &lt;strong>K8s 的抽象级别太低&lt;/strong>，这会给只想专注于编写和交付应用程序的开发人员带来很多摩擦。&lt;/p>
&lt;p>在开放式应用程序模型（&lt;a href="https://oam.dev/">OAM&lt;/a>）的设立是为了克服这个问题。这个想法是围绕应用程序创建更高级别的抽象，它独立于底层运行时。你可以在此处阅读规范。&lt;/p>
&lt;blockquote>
&lt;p>专注于应用程序而不是容器或协调器，开放应用程序模型 [OAM] 带来了模块化、可扩展和可移植的设计，用于使用更高级别但一致的 API 对应用程序部署进行建模。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://kubevela.io/">Kubevela&lt;/a> 是 OAM 模型的一个实现。KubeVela 与运行时无关，可本地扩展，但最重要的是，以应用程序为中心 。在 Kubevela 中，应用程序是作为 Kubernetes 资源实现的一等公民。**集群运营商（Platform Team）和开发者（Application Team）**是有区别的。集群操作员通过定义组件（组成应用程序的可部署/可配置实体，如 Helm Chart）和特征来管理集群和不同的环境。开发人员通过组装组件和特征来定义应用程序。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263064905339.jpg" alt="">&lt;/p>
&lt;p>KubeVela 是一个&lt;a href="https://cncf.io/">云原生计算基金会&lt;/a>沙箱项目，虽然它仍处于起步阶段，但它可以在不久的将来改变我们使用 Kubernetes 的方式，让开发人员无需成为 Kubernetes 专家即可专注于应用程序。但是，我确实对 &lt;strong>OAM&lt;/strong> 在现实世界中的适用性有一些担忧，因为系统应用程序、ML 或大数据过程等一些服务在很大程度上依赖于低级细节，这些细节可能很难融入 OAM 模型中。&lt;/p>
&lt;h3 id="备选-10">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.shipa.io/getting-started/">Shipa&lt;/a> 遵循类似的方法，使平台和开发团队能够协同工作，轻松将应用程序部署到 Kubernetes。&lt;/li>
&lt;/ul>
&lt;h2 id="snyk">Snyk&lt;/h2>
&lt;p>任何开发过程中一个非常重要的方面是安全性，这一直是 Kubernetes 的一个问题，因为想要迁移到 Kubernetes 的公司无法轻松实现其当前的安全原则。&lt;/p>
&lt;p>&lt;a href="https://snyk.io/">Snyk&lt;/a> 试图通过提供一个可以轻松与 Kubernetes 集成的安全框架来缓解这种情况。它可以检测容器映像、你的代码、开源项目等中的漏洞。&lt;/p>
&lt;h3 id="备选-11">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://falco.org/">Falco&lt;/a> 是 Kubernetes 的运行时安全线程检测工具。&lt;/li>
&lt;/ul>
&lt;h2 id="velero">Velero&lt;/h2>
&lt;p>如果你在 Kubernetes 中运行工作负载并使用卷来存储数据，则需要创建和管理备份。&lt;a href="https://velero.io/">Velero&lt;/a> 提供简单的备份/恢复过程、灾难恢复机制和数据迁移。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263066379840.jpg" alt="">&lt;/p>
&lt;p>与其他直接访问 Kubernetes etcd 数据库执行备份和恢复的工具不同，Velero 使用 Kubernetes API 来捕获集群资源的状态并在必要时恢复它们。此外，Velero 使你能够在配置的同时备份和恢复你的应用程序持久数据。&lt;/p>
&lt;h2 id="schema-hero">Schema Hero&lt;/h2>
&lt;p>软件开发中的另一个常见过程是在使用关系数据库时管理&lt;strong>模式演变&lt;/strong>。&lt;/p>
&lt;p>&lt;a href="https://schemahero.io/">SchemaHero&lt;/a> 是一种开源数据库架构迁移工具，可将架构定义转换为可应用于任何环境的迁移脚本。它使用 Kubernetes 声明性来管理数据库模式迁移。你只需指定所需的状态，然后 &lt;strong>SchemaHero&lt;/strong> 管理其余的。&lt;/p>
&lt;h3 id="备选-12">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.liquibase.org/">LiquidBase&lt;/a> 是最著名的替代品。它更难使用，且不是 Kubernetes 原生的，但它具有更多功能。&lt;/li>
&lt;/ul>
&lt;h2 id="bitnami-sealed-secrets">Bitnami Sealed Secrets&lt;/h2>
&lt;p>我们已经介绍了许多 &lt;strong>GitOps&lt;/strong> 工具，例如 &lt;a href="https://argoproj.github.io/argo-cd/">ArgoCD&lt;/a>。我们的目标是将所有内容保留在 Git 中，并使用 Kubernetes 声明性来保持环境同步。我们刚刚看到我们如何（并且应该）在 Git 中保留真实来源，并让自动化流程处理配置更改。&lt;/p>
&lt;p>在 Git 中通常很难保留的一件事是诸如数据库密码或 API 密钥之类的秘密，这是因为你永远不应该在代码存储库中存储秘密。一种常见的解决方案是使用外部保管库（例如 &lt;a href="https://aws.amazon.com/secrets-manager/">AWS Secret Manager&lt;/a> 或 &lt;a href="https://www.vaultproject.io/">HashiCorp Vault&lt;/a>）来存储机密，但这会产生很多摩擦，因为你需要有一个单独的流程来处理机密。理想情况下，我们希望有一种方法可以像任何其他资源一样安全地在 Git 中存储机密。&lt;/p>
&lt;p>&lt;a href="https://github.com/bitnami-labs/sealed-secrets">&lt;strong>Sealed Secrets&lt;/strong>&lt;/a> 旨在克服这个问题，允许你使用强加密将敏感数据存储在 Git 中。Bitnami &lt;strong>Sealed Secrets&lt;/strong> 本地集成在 Kubernetes 中，允许你仅通过在 Kubernetes 中运行的 Kubernetes 控制器而不是其他任何人来解密密钥。控制器将解密数据并创建安全存储的原生 K8s 机密。这使我们能够将所有内容作为代码存储在我们的 repo 中，从而允许我们安全地执行持续部署，而无需任何外部依赖。&lt;/p>
&lt;p>Sealed Secrets 由两部分组成：&lt;/p>
&lt;ul>
&lt;li>集群端控制器&lt;/li>
&lt;li>客户端实用程序：&lt;code>kubeseal&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>该 &lt;code>kubeseal&lt;/code> 实用程序使用非对称加密来加密只有控制器才能解密的机密。这些加密的秘密被编码在一个 &lt;code>SealedSecret&lt;/code> K8s 资源中，你可以将其存储在 Git 中。&lt;/p>
&lt;h3 id="备选-13">备选&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://aws.amazon.com/secrets-manager/">AWS Secret Manager&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.vaultproject.io/">HashiCorp Vault&lt;/a>）&lt;/li>
&lt;/ul>
&lt;h2 id="capsule">Capsule&lt;/h2>
&lt;p>许多公司使用&lt;strong>多租户&lt;/strong>来管理不同的客户。这在软件开发中很常见，但在 Kubernetes 中很难实现。&lt;strong>命名空间&lt;/strong>是将集群的逻辑分区创建为隔离切片的好方法，但这不足以安全地隔离客户，我们需要强制执行网络策略、配额等。你可以为每个名称空间创建网络策略和规则，但这是一个难以扩展的乏味过程。此外，租户将不能使用多个命名空间，这是一个很大的限制。&lt;/p>
&lt;p>创建&lt;strong>分层命名空间&lt;/strong>是为了克服其中一些问题。这个想法是为每个租户拥有一个父命名空间，为租户提供公共网络策略和配额，并允许创建子命名空间。这是一个很大的改进，但它在安全和治理方面没有对租户的本地支持。此外，它还没有达到生产状态，但 1.0 版预计将在未来几个月内发布。&lt;/p>
&lt;p>当前解决此问题的常用方法是为每个客户创建一个集群，这是安全的并提供租户所需的一切，但这很难管理且非常昂贵。&lt;/p>
&lt;p>&lt;a href="https://github.com/clastix/capsule">&lt;strong>Capsule&lt;/strong>&lt;/a> 是一种为单个集群中的多个租户提供原生 Kubernetes 支持的工具。使用 Capsule，你可以为所有租户拥有一个集群。Capsule 将为租户提供 “几乎” 原生体验（有一些小限制），他们将能够创建多个命名空间并使用集群，因为它们完全可用，隐藏了集群实际上是共享的事实。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263070902872.jpg" alt="Capsule 架构">&lt;/p>
&lt;p>在单个集群中，Capsule Controller 在称为 &lt;strong>Tenant&lt;/strong> 的轻量级 Kubernetes 抽象中聚合多个命名空间，这是一组 Kubernetes 命名空间。在每个租户内，用户可以自由创建他们的命名空间并共享所有分配的资源，而策略引擎则使不同的租户彼此隔离。&lt;/p>
&lt;p>租户级别定义的网络和安全策略、资源配额、限制范围、RBAC 和其他策略由租户中的所有命名空间自动继承，类似于分层命名空间。然后用户可以自由地自治操作他们的租户，而无需集群管理员的干预。
Capsule 是 GitOps 就绪的，因为它是声明性的，并且所有配置都可以存储在 Git 中。&lt;/p>
&lt;h2 id="vcluster">vCluster&lt;/h2>
&lt;p>&lt;a href="https://www.vcluster.com/">vCluster&lt;/a> 在多租户方面更进了一步，它在 Kubernetes 集群内提供了虚拟集群。每个集群都在一个常规命名空间上运行，并且是完全隔离的。虚拟集群有自己的 API 服务器和独立的数据存储，所以你在 vCluster 中创建的每个 Kubernetes 对象都只存在于 vcluster 内部。此外，您可以将 kube 上下文与虚拟集群一起使用，以像使用常规集群一样使用它们。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263071651487.jpg" alt="">&lt;/p>
&lt;p>只要您可以在单个命名空间内创建部署，您就可以创建虚拟集群并成为该虚拟集群的管理员，租户可以创建命名空间、安装 CRD、配置权限等等。&lt;/p>
&lt;p>&lt;strong>vCluster&lt;/strong> 使用 &lt;a href="https://k3s.io/">&lt;strong>k3s&lt;/strong>&lt;/a> 作为其 API 服务器，使虚拟集群超轻量级且经济高效；由于 k3s 集群 100% 合规，虚拟集群也 100% 合规。&lt;strong>vClusters&lt;/strong> 是超轻量级的（1 个 pod），消耗很少的资源并且可以在任何 Kubernetes 集群上运行，而无需对底层集群进行特权访问。与 &lt;strong>Capsule&lt;/strong> 相比，它确实使用了更多的资源，但它提供了更多的灵活性，因为多租户只是用例之一。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/15/16263072079021.jpg" alt="">&lt;/p>
&lt;h2 id="其他工具">其他工具&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cloud-bulldozer/kube-burner">kube-burner&lt;/a> 用于&lt;strong>压力测试&lt;/strong>。它提供指标和警报。&lt;/li>
&lt;li>混沌工程的 &lt;a href="https://github.com/litmuschaos/litmus">Litmus&lt;/a>。&lt;/li>
&lt;li>&lt;a href="https://github.com/bitnami-labs/kubewatch">kubewatch&lt;/a> 用于监控，但主要关注基于 Kubernetes 事件（如资源创建或删除）的推送通知。它可以与 Slack 等许多工具集成。&lt;/li>
&lt;li>&lt;a href="https://www.botkube.io/">BotKube&lt;/a> 是一个消息机器人，用于监控和调试 Kubernetes 集群。与 kubewatch 类似，但更新并具有更多功能。&lt;/li>
&lt;li>&lt;a href="https://getmizu.io/">Mizu&lt;/a> 是一个 API 流量查看器和调试器。&lt;/li>
&lt;li>&lt;a href="https://github.com/senthilrch/kube-fledged">kube-fledged&lt;/a> 是一个 Kubernetes 插件，用于直接在 Kubernetes 集群的工作节点上创建和管理容器镜像的缓存。因此，&lt;strong>应用程序 pod 几乎立即启动&lt;/strong>，因为不需要从注册表中提取图像。&lt;/li>
&lt;/ul>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>在本文中，我们回顾了我最喜欢的 Kubernetes 工具。我专注于可以合并到任何 Kubernetes 发行版中的开源项目。我没有涵盖诸如 &lt;a href="https://www.openshift.com/">OpenShift&lt;/a> 或 Cloud Providers Add-Ons 之类的商业解决方案，因为我想让它保持通用性，但我鼓励您探索如果您在云上运行 Kubernetes 或使用商业工具，您的云提供商可以为您提供什么。&lt;/p>
&lt;p>我的目标是向您展示您可以在 &lt;strong>Kubernetes&lt;/strong> 中完成您在本地所做的一切。我还更多地关注鲜为人知的工具，我认为这些工具可能具有很大的潜力，例如 &lt;a href="https://crossplane.io/">Crossplane&lt;/a>、&lt;a href="https://kubevela.io/">Argo Rollouts&lt;/a>或 &lt;a href="https://kubevela.io/">Kubevela&lt;/a>。我更感兴趣的工具是 &lt;a href="https://www.vcluster.com/">vCluster&lt;/a>、&lt;a href="https://crossplane.io/">Crossplane&lt;/a> 和 ArgoCD/Workflows。&lt;/p></description></item><item><title>Rego 不好用？用 Pipy 实现 OPA</title><link>https://atbug.com/pipy-implement-kubernetes-admission-control/</link><pubDate>Tue, 13 Jul 2021 08:44:56 +0800</pubDate><guid>https://atbug.com/pipy-implement-kubernetes-admission-control/</guid><description>
&lt;p>还不知道 Pipy 是什么的同学可以看下 &lt;a href="https://github.com/flomesh-io/pipy">GitHub&lt;/a> 。&lt;/p>
&lt;blockquote>
&lt;p>Pipy 是一个轻量级、高性能、高稳定、可编程的网络代理。Pipy 核心框架使用 C++ 开发，网络 IO 采用 ASIO 库。 Pipy 的可执行文件仅有 5M 左右，运行期的内存占用 10M 左右，因此 Pipy 非常适合做 Sidecar proxy。&lt;/p>
&lt;p>Pipy 内置了自研的 pjs 作为脚本扩展，使得Pipy 可以用 JS 脚本根据特定需求快速定制逻辑与功能。&lt;/p>
&lt;p>Pipy 采用了模块化、链式的处理架构，用顺序执行的模块来对网络数据块进行处理。这种简单的架构使得 Pipy 底层简单可靠，同时具备了动态编排流量的能力，兼顾了简单和灵活。通过使用 REUSE_PORT 的机制（主流 Linux 和 BSD 版本都支持该功能），Pipy 可以以多进程模式运行，使得 Pipy 不仅适用于 Sidecar 模式，也适用于大规模的流量处理场景。 在实践中，Pipy 独立部署的时候用作“软负载”，可以在低延迟的情况下，实现媲美硬件的负载均衡吞吐能力，同时具有灵活的扩展性。&lt;/p>
&lt;/blockquote>
&lt;p>在玩过几次 Pipy 并探究其工作原理后，又有了更多的想法。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/l8JzYRn350fjuCAOoo8pcg">初探可编程网关 Pipy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/_IeRXp9EJnVsvDfg8tUr1A">可编程网关 Pipy 第二弹：编程实现 Metrics 及源码解读&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/iQWunpazsw86X3kEkB1rJw">可编程网关 Pipy 第三弹：事件模型设计&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在使用OPA的时候，一直觉得Rego不是那么顺手，使用pipy js来写规则的想法油然而生。今天就一起试试这个思路。果然，不试不知道，一试发现太多的惊喜～Pipy不止于“代理”，更有很多可以适用的场景：&lt;/p>
&lt;ul>
&lt;li>极小的单一可执行文件（single binary）使得 pipy 可能是最好的 “云原生 sidecar”&lt;/li>
&lt;li>sidecar 不仅仅是代理，还可以做控制器，做运算单元&lt;/li>
&lt;li>proxy 的串路结构适合各种管控类的操作，比如访问控制&lt;/li>
&lt;li>Pipy js 的扩展能力和快速编程能力，很适合做 “规则引擎”，或者用最近流行的说法 “云原生的规则引擎”。对比 OPA 我认为它完全够格做一个 “羽量级规则执行引擎”&lt;/li>
&lt;/ul>
&lt;p>现在我更倾向于定义 pipy 是一个 “云原生的流量编程框架”，代理只是其底层的核心能力，叠加了 pipy js 以后，上层可以做的事情很多，“流量滋养万物”。&lt;/p>
&lt;p>在 &lt;a href="https://mp.weixin.qq.com/s/RvqCVAhClJY3o_46ALu1bQ">使用 Open Policy Agent 实现可信镜像仓库检查&lt;/a> 之后，就在想 Pipy 是否一样可以做到，将内核替换成 Pipy + 规则。所以今天大部分内容和上面这篇是相似的。&lt;/p>
&lt;p>来，一起看看这个“不务正业”的 Pipy 如何实现 Kubernetes 的准入控制器 来做镜像的检查。&lt;/p>
&lt;h2 id="环境">环境&lt;/h2>
&lt;p>继续使用 minikube&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube start
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="创建部署-pipy-的命名空间">创建部署 Pipy 的命名空间&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create namespace pipy
kubens pipy
kubectl label ns pipy pipy/webhook&lt;span class="o">=&lt;/span>ignore &lt;span class="c1">#后面解释&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="规则">规则&lt;/h2>
&lt;p>在 OPA 中，通过 &lt;code>kube-mgmt&lt;/code> 容器监控 &lt;code>configmap&lt;/code> 的改动，将 Policy 推送到同 pod 的 opa 容器中。&lt;/p>
&lt;p>对于 Pipy 为了渐变，直接使用挂载的方式将保存了规则的 &lt;code>configmap&lt;/code> 挂载到 Pipy
的容器中。&lt;/p>
&lt;p>&lt;em>实际的使用中，Pipy 支持轮训的方式检查控制平面中规则的变更，并实时加载；也可以实现与 OPA 的 kube-mgmt 同样的逻辑。&lt;/em>&lt;/p>
&lt;p>实现了&lt;a href="https://atbug.com/image-trusted-repository-with-open-policy-agent/">上一讲功能&lt;/a>的 pipy 规则如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">cat &amp;gt; pipy-rule.js &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">pipy({
&lt;/span>&lt;span class="s"> _repoPrefix: &amp;#39;192.168.64.1&amp;#39;, //192.168.64.1:5000 是笔者本地容器运行的一个私有仓库。
&lt;/span>&lt;span class="s"> _tagSuffix: &amp;#39;:latest&amp;#39;,
&lt;/span>&lt;span class="s">})
&lt;/span>&lt;span class="s">
&lt;/span>&lt;span class="s">.listen(6443, {
&lt;/span>&lt;span class="s"> tls: {
&lt;/span>&lt;span class="s"> cert: os.readFile(&amp;#39;/certs/tls.crt&amp;#39;).toString(),
&lt;/span>&lt;span class="s"> key: os.readFile(&amp;#39;/certs/tls.key&amp;#39;).toString(),
&lt;/span>&lt;span class="s"> },
&lt;/span>&lt;span class="s">})
&lt;/span>&lt;span class="s"> .decodeHttpRequest()
&lt;/span>&lt;span class="s"> .replaceMessage(
&lt;/span>&lt;span class="s"> msg =&amp;gt; (
&lt;/span>&lt;span class="s"> ((req, result, invalids, reason) =&amp;gt; (
&lt;/span>&lt;span class="s"> req = JSON.decode(msg.body),
&lt;/span>&lt;span class="s"> invalids = req.request.object.spec.containers.find(container =&amp;gt; (
&lt;/span>&lt;span class="s"> (!container.image.startsWith(_repoPrefix) ? (
&lt;/span>&lt;span class="s"> reason = `${container.image} repo not start with ${_repoPrefix}`,
&lt;/span>&lt;span class="s"> console.log(reason),
&lt;/span>&lt;span class="s"> true
&lt;/span>&lt;span class="s"> ) : (false))
&lt;/span>&lt;span class="s"> ||
&lt;/span>&lt;span class="s"> (container.image.endsWith(_tagSuffix) ? (
&lt;/span>&lt;span class="s"> reason = `${container.image} tag end with ${_tagSuffix}`,
&lt;/span>&lt;span class="s"> console.log(reason),
&lt;/span>&lt;span class="s"> true
&lt;/span>&lt;span class="s"> ) : (false)
&lt;/span>&lt;span class="s"> ))),
&lt;/span>&lt;span class="s"> invalids != undefined ? (
&lt;/span>&lt;span class="s"> result = {
&lt;/span>&lt;span class="s"> &amp;#34;apiVersion&amp;#34;: &amp;#34;admission.k8s.io/v1beta1&amp;#34;,
&lt;/span>&lt;span class="s"> &amp;#34;kind&amp;#34;: &amp;#34;AdmissionReview&amp;#34;,
&lt;/span>&lt;span class="s"> &amp;#34;response&amp;#34;: {
&lt;/span>&lt;span class="s"> &amp;#34;allowed&amp;#34;: false,
&lt;/span>&lt;span class="s"> &amp;#34;uid&amp;#34;: req.request.uid,
&lt;/span>&lt;span class="s"> &amp;#34;status&amp;#34;: {
&lt;/span>&lt;span class="s"> &amp;#34;reason&amp;#34;: reason,
&lt;/span>&lt;span class="s"> },
&lt;/span>&lt;span class="s"> },
&lt;/span>&lt;span class="s"> }
&lt;/span>&lt;span class="s"> ) : (
&lt;/span>&lt;span class="s"> result = {
&lt;/span>&lt;span class="s"> &amp;#34;apiVersion&amp;#34;: &amp;#34;admission.k8s.io/v1beta1&amp;#34;,
&lt;/span>&lt;span class="s"> &amp;#34;kind&amp;#34;: &amp;#34;AdmissionReview&amp;#34;,
&lt;/span>&lt;span class="s"> &amp;#34;response&amp;#34;: {
&lt;/span>&lt;span class="s"> &amp;#34;allowed&amp;#34;: true,
&lt;/span>&lt;span class="s"> &amp;#34;uid&amp;#34;: req.request.uid
&lt;/span>&lt;span class="s"> },
&lt;/span>&lt;span class="s"> }
&lt;/span>&lt;span class="s"> ),
&lt;/span>&lt;span class="s">
&lt;/span>&lt;span class="s"> console.log(JSON.encode(result)),
&lt;/span>&lt;span class="s">
&lt;/span>&lt;span class="s"> new Message({
&lt;/span>&lt;span class="s"> &amp;#39;status&amp;#39; : 200,
&lt;/span>&lt;span class="s"> &amp;#39;headers&amp;#39;: {
&lt;/span>&lt;span class="s"> &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;
&lt;/span>&lt;span class="s"> }
&lt;/span>&lt;span class="s"> }, JSON.encode(result))
&lt;/span>&lt;span class="s"> ))()
&lt;/span>&lt;span class="s"> )
&lt;/span>&lt;span class="s"> )
&lt;/span>&lt;span class="s"> .encodeHttpResponse()
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将规则保存在 configmap 中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create configmap pipy-rule --from-file&lt;span class="o">=&lt;/span>pipy-rule.js
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在-kubernetes-上部署-pipy">在 Kubernetes 上部署 Pipy&lt;/h2>
&lt;p>Kubernetes 与准入控制器（&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">Admission Controller&lt;/a>）的通信需要使用 TLS。配置 TLS，使用 &lt;code>openssl&lt;/code> 创建证书颁发机构（certificate authority CA）和 OPA 的证书/秘钥对。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">openssl genrsa -out ca.key &lt;span class="m">2048&lt;/span>
openssl req -x509 -new -nodes -key ca.key -days &lt;span class="m">100000&lt;/span> -out ca.crt -subj &lt;span class="s2">&amp;#34;/CN=admission_ca&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为 OPA 创建 TLS 秘钥和证书：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">cat &amp;gt;server.conf &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">[req]
&lt;/span>&lt;span class="s">req_extensions = v3_req
&lt;/span>&lt;span class="s">distinguished_name = req_distinguished_name
&lt;/span>&lt;span class="s">prompt = no
&lt;/span>&lt;span class="s">[req_distinguished_name]
&lt;/span>&lt;span class="s">CN = pipy.pipy.svc
&lt;/span>&lt;span class="s">[ v3_req ]
&lt;/span>&lt;span class="s">basicConstraints = CA:FALSE
&lt;/span>&lt;span class="s">keyUsage = nonRepudiation, digitalSignature, keyEncipherment
&lt;/span>&lt;span class="s">extendedKeyUsage = clientAuth, serverAuth
&lt;/span>&lt;span class="s">subjectAltName = @alt_names
&lt;/span>&lt;span class="s">[alt_names]
&lt;/span>&lt;span class="s">DNS.1 = pipy.pipy.svc
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意 &lt;code>CN&lt;/code> 和 &lt;code>alt_names&lt;/code> 必须与后面创建 Pipy service 的匹配。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">openssl genrsa -out server.key &lt;span class="m">2048&lt;/span>
openssl req -new -key server.key -out server.csr -config server.conf
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days &lt;span class="m">100000&lt;/span> -extensions v3_req -extfile server.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为 OPA 创建保存 TLS 凭证的 Secret：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create secret tls pipy-server --cert&lt;span class="o">=&lt;/span>server.crt --key&lt;span class="o">=&lt;/span>server.key
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 Pipy 部署为准入控制器（admission controller）。为了方便调试，我们使用启动 Pipy 的时候打开了控制台。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">443&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6443&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">gui&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 方便调试&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6060&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6060&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;pipy&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;/opt/data/pipy-rule.js&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;--gui-port=6060&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 方便调试&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># - &amp;#34;--log-level=debug&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">gui&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6060&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6443&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">readOnly&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/certs&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">readOnly&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/opt/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy-rule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy-rule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">configMap&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipy-rule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>暴露控制台的访问：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl expose deploy pipy --name pipy-node --type NodePort
kubectl get svc pipy-port
minikube service --url pipy-node -n pipy
&lt;span class="c1"># 找到控制台端口&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，生成将用于将 Pipy 注册为准入控制器的 manifest。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">cat &amp;gt; webhook-configuration.yaml &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">kind: ValidatingWebhookConfiguration
&lt;/span>&lt;span class="s">apiVersion: admissionregistration.k8s.io/v1beta1
&lt;/span>&lt;span class="s">metadata:
&lt;/span>&lt;span class="s"> name: pipy-validating-webhook
&lt;/span>&lt;span class="s">webhooks:
&lt;/span>&lt;span class="s"> - name: validating-webhook.pipy.flomesh-io.cn
&lt;/span>&lt;span class="s"> namespaceSelector:
&lt;/span>&lt;span class="s"> matchExpressions:
&lt;/span>&lt;span class="s"> - key: pipy/webhook
&lt;/span>&lt;span class="s"> operator: NotIn
&lt;/span>&lt;span class="s"> values:
&lt;/span>&lt;span class="s"> - ignore
&lt;/span>&lt;span class="s"> rules:
&lt;/span>&lt;span class="s"> - operations: [&amp;#34;CREATE&amp;#34;, &amp;#34;UPDATE&amp;#34;]
&lt;/span>&lt;span class="s"> apiGroups: [&amp;#34;*&amp;#34;]
&lt;/span>&lt;span class="s"> apiVersions: [&amp;#34;*&amp;#34;]
&lt;/span>&lt;span class="s"> resources: [&amp;#34;pods&amp;#34;]
&lt;/span>&lt;span class="s"> clientConfig:
&lt;/span>&lt;span class="s"> caBundle: $(cat ca.crt | base64 | tr -d &amp;#39;\n&amp;#39;)
&lt;/span>&lt;span class="s"> service:
&lt;/span>&lt;span class="s"> namespace: pipy
&lt;/span>&lt;span class="s"> name: pipy
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>生成的配置文件包含 CA 证书的 base64 编码，以便可以在 Kubernetes API 服务器和 OPA 之间建立 TLS 连接。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f webhook-configuration.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="测试">测试&lt;/h2>
&lt;p>&lt;code>pod-bad-repo.yaml&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:1.21.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f pod-bad-repo.yaml
Error from server &lt;span class="o">(&lt;/span>nginx:1.21.1 repo not start with 192.168.64.1&lt;span class="o">)&lt;/span>: error when creating &lt;span class="s2">&amp;#34;pod-bad-repo.yaml&amp;#34;&lt;/span>: admission webhook &lt;span class="s2">&amp;#34;validating-webhook.pipy.flomesh-io.cn&amp;#34;&lt;/span> denied the request: nginx:1.21.1 repo not start with 192.168.64.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>pod-bad-tag.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">192.168.64.1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">5000&lt;/span>&lt;span class="l">/nginx:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f pod-bad-tag.yaml
Error from server &lt;span class="o">(&lt;/span>192.168.64.1:5000/nginx:latest tag end with :latest&lt;span class="o">)&lt;/span>: error when creating &lt;span class="s2">&amp;#34;pod-bad-tag.yaml&amp;#34;&lt;/span>: admission webhook &lt;span class="s2">&amp;#34;validating-webhook.pipy.flomesh-io.cn&amp;#34;&lt;/span> denied the request: 192.168.64.1:5000/nginx:latest tag end with :latest
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>pod-ok.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">192.168.64.1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">5000&lt;/span>&lt;span class="l">/nginx:1.21.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f pod-ok.yaml
pod/web-server created
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>OPA 哪哪都好，唯一缺点就是其引进的 &lt;code>Rego&lt;/code> 语言抬高了使用的门槛。而 Pipy 的规则是通过 JavaScrip 来编写的，前端的同学一样可以完成规则的编写。完全替代可能夸张了一些，但确实在部分场景下可以替代 OPA。&lt;/p>
&lt;p>玩到这里，你会发现有了规则，加上功能强大的过滤器（现在我喜欢叫他们 Hook 了），Pipy 的可玩性非常强。&lt;/p>
&lt;p>比如&lt;a href="https://mp.weixin.qq.com/s/lfU3XKP2oAPOLNkxdR2KVg">OPA: Kubernetes 准入控制策略 Top 5&lt;/a>，比如&amp;hellip;。大胆的想象吧。&lt;/p>
&lt;p>想写一个系列，就叫“如何把 Pipy 玩坏”？&lt;/p></description></item><item><title>Kubernetes 的魔力在于企业标准化，而不是应用程序的可移植性</title><link>https://atbug.com/translation-kubernetes-magic-is-in-enterprise-standardization-not-app-portability/</link><pubDate>Sun, 11 Jul 2021 08:05:42 +0800</pubDate><guid>https://atbug.com/translation-kubernetes-magic-is-in-enterprise-standardization-not-app-portability/</guid><description>
&lt;p>笔者：Kubernetes 抽象了资源和工作负载的操作模式，统一了工具集，实现人机接口的标准化。正如类 Docker 工具提供了应用运行时的操作模式；Spring Framework 提供了 Java 应用的开发模式。&lt;/p>
&lt;blockquote>
&lt;p>Kubernetes 是关于跨云的技能、工具和实践的可移植性。不是工作负载的可移植性。 &amp;ndash; Bilgin Lbryam @bibryam&lt;/p>
&lt;/blockquote>
&lt;p>本文翻译自 &lt;a href="https://www.techrepublic.com/google-amp/article/kubernetes-magic-is-in-enterprise-standardization-not-app-portability">Kubernetes magic is in enterprise standardization, not app portability&lt;/a>&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>Kubernetes 不会神奇地使你的应用程序具有可移植性，但它可能会给你带来更好的东西。&lt;/p>
&lt;/blockquote>
&lt;p>云为企业提供了看似无限的选择。然而，根据 &lt;a href="https://juju.is/cloud-native-kubernetes-usage-report-2021">Canonical-sponsored 的一项调查&lt;/a>，这并不是大多数企业采用 &lt;a href="https://www.techrepublic.com/article/kubernetes-the-smart-persons-guide/">Kubernetes&lt;/a> 等云友好技术的原因。相反，Kubernetes 的主要目标是标准化——外观和操作与其他人一样。&lt;/p>
&lt;h2 id="可移植性不是目标">可移植性不是目标&lt;/h2>
&lt;p>我之前已经讨论过这个问题，参考了 Gartner 关于 Kubernetes 和可移植性的指南。许多人认为 Kubernetes（和&lt;a href="https://www.techrepublic.com/article/containers-the-smart-persons-guide">容器&lt;/a>）可以让他们在云之间轻松移植，但事实证明并不是这样的。正如 Gartner 分析师 &lt;a href="https://blogs.gartner.com/marco-meinardi/2020/09/04/adopting-kubernetes-application-portability-not-good-idea/">Marco Meinardi 所写&lt;/a>，当被问及公司是否应该采用“Kubernetes 使他们的应用程序可移植&amp;hellip;&amp;hellip;答案是：不。” 再说一次？&lt;/p>
&lt;blockquote>
&lt;p>调查显示，[在云提供商之间移动应用程序] 的可能性实际上非常低。一旦部署在供应商中，应用程序往往会留在那里。这是因为数据湖难以移植且成本高昂，因此最终成为迁移的重心。&lt;/p>
&lt;/blockquote>
&lt;p>因此 Kubernetes 通常不会被公司接受，以增强应用程序的可移植性；相反，谈论人员可移植性或换言之，技能可移植性更接近事实。Weaveworks 首席执行官亚历克西斯·理查森（Alexis Richardson）&lt;a href="https://twitter.com/monadic/status/1302257531025264642">将这个主题打回家&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>重点是“技能可移植性”，因为使用标准操作模型和工具链。大型组织希望开发人员使用标准的工作方式，因为这可以降低培训成本，并消除员工在不同项目之间转移的障碍。如果你的“平台”（或多个平台）基于相同的核心云原生工具集，那么它也可以更轻松、更便宜地应用策略。&lt;/p>
&lt;/blockquote>
&lt;p>这让我们回到规范调查。&lt;/p>
&lt;h2 id="samesies">Samesies&lt;/h2>
&lt;p>当被问及确定与采用 Kubernetes 等云原生技术相关的技术目标时，调查受访者将可移植性排在最后，将更直接的问题排在第一位：&lt;/p>
&lt;ul>
&lt;li>改进维护、监控和自动化 - 64.6%。&lt;/li>
&lt;li>基础设施现代化 - 46.4%。&lt;/li>
&lt;li>更快的上线时间 - 26.5%。&lt;/li>
&lt;li>删除供应商依赖项 - 12.8%。&lt;/li>
&lt;li>全球覆盖率 - 12.5%。&lt;/li>
&lt;li>围绕流量高峰的敏捷性 - 9.2%。&lt;/li>
&lt;li>确保便携性 - 8.9%&lt;/li>
&lt;/ul>
&lt;p>我喜欢 Google Cloud 的开发者倡导者 Kelsey Hightower 在调查报告中评论这些结果的方式：&lt;/p>
&lt;blockquote>
&lt;p>很多人认为组织转向 Kubernetes 是因为规模，或者因为他们想成为超大规模者，或者与 Twitter 拥有相同的流量水平。对于大多数组织而言，情况并非一定如此。很多人都喜欢 K8s 中内置了许多决策，例如日志记录、监控和负载平衡。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>人们往往会忘记事情有多么复杂，只是为了构建一个没有所有自动化的应用程序。如果你在公有云上，你可以使用一些本机集成和工具。但是，如果你在本地，那不是给定的——你必须自己将解决方案粘合在一起。使用 Kubernetes，你几乎将 25 种不同的工具合二为一。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这就是人们所说的“现代基础设施”的意思——他们并不是在谈论做一些以前从未做过的事情。他们谈论的是过去 10 年或 15 年一直在生产的东西。Kubernetes 是当今所有“现代模式”的检查站。&lt;/p>
&lt;/blockquote>
&lt;p>换句话说，人们真正想要从 Kubernetes 获得的是一种标准的基础设施思考方式。回到 Richardson 之前的观点，虽然 Kubernetes 和云原生技术使公司能够以更高的速度运营，但最大的好处可能是使技能在组织之间可以互换——这为雇主和员工都创造了巨大的绩效收益。这是企业不断增加对 Kubernetes 投资的另一个原因。&lt;/p>
&lt;p>&lt;em>声明：我为 AWS 工作，但此处表达的观点是我的。&lt;/em>&lt;/p></description></item><item><title>Kubernetes CKA 证书备考笔记</title><link>https://atbug.com/notes-for-cka-preparation/</link><pubDate>Fri, 02 Jul 2021 08:02:15 +0800</pubDate><guid>https://atbug.com/notes-for-cka-preparation/</guid><description>
&lt;p>Kubernetes 使用有好几年了，但在今年 5 月才完成 CKA 的考试。虽说用了几年，还是提前刷了部分题熟悉下。&lt;/p>
&lt;p>绝大部分题都是有在 minikube 的环境上操作过，只有部分比如升级集群受限于环境问题没有实地操作。&lt;/p>
&lt;h2 id="写在最前">写在最前&lt;/h2>
&lt;ol>
&lt;li>保存常用文档进书签，如果有 Alfred 启用浏览器书签 workflow。效果见下图&lt;/li>
&lt;li>kubectl 自动补全 &lt;code>echo &amp;quot;source &amp;lt;(kubectl completion bash)&amp;quot; &amp;gt;&amp;gt; ~/.bashrc; source ~/.bashrc&lt;/code>&lt;/li>
&lt;li>每道题开始前要切换 context 和 namespace，直接复制题目里的命令即可&lt;/li>
&lt;li>必要的 alias&lt;/li>
&lt;li>善用 &lt;code>--dry-run=client -o yaml&lt;/code> 避免手动敲太多&lt;/li>
&lt;li>善用 &lt;code>kubectl explain [resource[.field]]&lt;/code>&lt;/li>
&lt;li>看懂题目最重要，输出正确的结果更重要（重要的事讲三遍）&lt;/li>
&lt;li>看懂题目最重要，输出正确的结果更重要（重要的事讲三遍）&lt;/li>
&lt;li>看懂题目最重要，输出正确的结果更重要（重要的事讲三遍）&lt;/li>
&lt;/ol>
&lt;p>书签地址：&lt;a href="https://gist.github.com/addozhang/3ca950ce9b38930abfe7c5fb067e74de">K8s-CKA-CAKD-Bookmarks.html&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/07/01/20210630162758.png" alt="alfred-bookmarks-workflow">&lt;/p>
&lt;h2 id="安全rbac">安全：RBAC&lt;/h2>
&lt;blockquote>
&lt;p>在默认命名空间中创建一个名为 dev-sa 的服务帐户，dev-sa 可以在 dev 命名空间中创建以下组件：
&lt;code>Deployment&lt;/code>、&lt;code>StatefulSet&lt;/code>、&lt;code>DaemonSet&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点">知识点&lt;/h3>
&lt;ul>
&lt;li>role&lt;/li>
&lt;li>sa&lt;/li>
&lt;li>rolebinding&lt;/li>
&lt;li>auth can-i&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#command-line-utilities">https://kubernetes.io/docs/reference/access-authn-authz/rbac/#command-line-utilities&lt;/a>&lt;/p>
&lt;h3 id="解题思路">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl create sa dev-sa
$ kubectl create role dev-role --verb&lt;span class="o">=&lt;/span>create --resource&lt;span class="o">=&lt;/span>deployment,statefulset,daemonset
&lt;span class="c1">#检查&lt;/span>
$ kubectl describe role dev-role
Name: dev-role
Labels: &amp;lt;none&amp;gt;
Annotations: &amp;lt;none&amp;gt;
PolicyRule:
Resources Non-Resource URLs Resource Names Verbs
--------- ----------------- -------------- -----
daemonsets.apps &lt;span class="o">[]&lt;/span> &lt;span class="o">[]&lt;/span> &lt;span class="o">[&lt;/span>create&lt;span class="o">]&lt;/span>
deployments.apps &lt;span class="o">[]&lt;/span> &lt;span class="o">[]&lt;/span> &lt;span class="o">[&lt;/span>create&lt;span class="o">]&lt;/span>
statefulsets.apps &lt;span class="o">[]&lt;/span> &lt;span class="o">[]&lt;/span> &lt;span class="o">[&lt;/span>create&lt;span class="o">]&lt;/span>
$ kubectl create rolebinding dev --serviceaccount default:dev-sa --role dev-role
&lt;span class="c1">#检查&lt;/span>
$ kubectl auth can-i create deployment --as system:serviceaccount:default:dev-sa
yes
$ kubectl auth can-i create statefulset --as system:serviceaccount:default:dev-sa
yes
$ kubectl auth can-i create daemonset --as system:serviceaccount:default:dev-sa
yes
$ kubectl auth can-i create pod --as system:serviceaccount:default:dev-sa
no
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="多容器-pod">多容器 Pod&lt;/h2>
&lt;blockquote>
&lt;p>创建一个pod名称日志，容器名称 &lt;code>log-pro&lt;/code> 使用image &lt;code>busybox&lt;/code>，在 &lt;code>/log/data/output.log&lt;/code> 输出重要信息。然后另一个容器名称 &lt;code>log-cus&lt;/code> 使用 image &lt;code>busybox&lt;/code>，在 &lt;code>/log/data/output.log&lt;/code> 加载 &lt;code>output.log&lt;/code> 并打印它。 请注意，此日志文件只能在 pod 内共享。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-1">知识点&lt;/h3>
&lt;ul>
&lt;li>pod&lt;/li>
&lt;li>volume: emptyDir&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir">https://kubernetes.io/docs/concepts/storage/volumes/#emptydir&lt;/a>&lt;/p>
&lt;h3 id="解题思路-1">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl run log --image busybox --dry-run&lt;span class="o">=&lt;/span>client -o yaml &amp;gt; log.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 log.yaml&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">sh&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">c&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">echo important information &amp;gt; /log/data/output.log; sleep 1d&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log-pro&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/log/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">sh&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">c&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">tail -f /log/data/output.log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log-cus&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/log/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行创建 &lt;code>kubectl apply -f log.yaml&lt;/code>&lt;/p>
&lt;p>检查&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl logs log -c log-cus
important information
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安全网络策略-networkpolicy">安全：网络策略 NetworkPolicy&lt;/h2>
&lt;blockquote>
&lt;p>只有命名空间 &lt;code>mysql&lt;/code> 的 pod 只能被另一个命名空间 &lt;code>internal&lt;/code> 的 pod 通过 8080 端口进行访问&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-2">知识点&lt;/h3>
&lt;ul>
&lt;li>NetworkPolicy&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#the-networkpolicy-resource">https://kubernetes.io/docs/concepts/services-networking/network-policies/#the-networkpolicy-resource&lt;/a>&lt;/p>
&lt;h3 id="解题思路-2">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cka-network&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">target&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#目的命名空间&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">policyTypes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">Ingress&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#策略影响入栈流量&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ingress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">from&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#允许流量的来源&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">namespaceSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ns&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">source&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#源命名空间的 label&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#允许访问的端口&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="节点状态及污点">节点状态及污点&lt;/h2>
&lt;blockquote>
&lt;p>统计这个集群中没有污染的就绪节点，并输出到文件 &lt;code>/root/cka/readyNode.txt&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-3">知识点&lt;/h3>
&lt;ul>
&lt;li>Node&lt;/li>
&lt;li>Taint（污点）&lt;/li>
&lt;/ul>
&lt;p>参考文档：https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/&lt;/p>
&lt;h3 id="解题思路-3">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># Ready 状态的数量&lt;/span>
$ kubectl get node &lt;span class="p">|&lt;/span> grep -w Ready &lt;span class="p">|&lt;/span> wc -l
&lt;span class="c1"># 查看含有 Taint 的数量，需要排除掉这些&lt;/span>
$ kubectl describe node &lt;span class="p">|&lt;/span> grep Taints &lt;span class="p">|&lt;/span> grep -i NoSchedule &lt;span class="p">|&lt;/span> wc -l
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="资源">资源&lt;/h2>
&lt;blockquote>
&lt;p>将占用CPU资源最多的pod名称输出到文件 &lt;code>/root/cka/name.txt&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-4">知识点&lt;/h3>
&lt;ul>
&lt;li>kubectl top 命令&lt;/li>
&lt;li>metrics&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-4">解题思路&lt;/h3>
&lt;p>如果是 minikube 环境，报错 &lt;code>error: Metrics API not available&lt;/code>，可以执行 &lt;code>minikube addons enable metrics-server&lt;/code> 命令开启 metrics server。&lt;/p>
&lt;p>通过 &lt;code>kubectl top&lt;/code> 命令找到 cpu 最高的 pod，将其名字写入 &lt;code>/root/cka/name.txt&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl top pod
&lt;span class="c1"># 或者&lt;/span>
$ kubectl top pod &lt;span class="p">|&lt;/span> sort -k &lt;span class="m">2&lt;/span> -n
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="网络dns">网络：DNS&lt;/h2>
&lt;blockquote>
&lt;p>有 pod 名称 &lt;code>pod-nginx&lt;/code>，创建服务名称 &lt;code>service-nginx&lt;/code>，使用 &lt;code>nodePort&lt;/code> 暴露pod。 然后创建一个 pod 使用 image &lt;code>busybox&lt;/code> 来 &lt;code>nslookup&lt;/code> pod &lt;code>pod-nginx&lt;/code> 和 service &lt;code>service-nginx&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-5">知识点&lt;/h3>
&lt;ul>
&lt;li>service with nodePort&lt;/li>
&lt;li>kubectl expose&lt;/li>
&lt;li>kubectl run&lt;/li>
&lt;/ul>
&lt;p>参考文档：https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/&lt;/p>
&lt;h3 id="解题思路-5">解题思路&lt;/h3>
&lt;p>使用 &lt;code>kubectl expose&lt;/code> 创建 service。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># 创建 service&lt;/span>
kubectl expose pod pod-nginx --name service-nginx --type NodePort --target-port &lt;span class="m">80&lt;/span>
&lt;span class="c1"># 创建 pod&lt;/span>
kubectl run busybox --image busybox:latest --command sleep 1h
&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取 pod 的 ip 地址，pod 的 dns lookup 需要用用到 ip。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get po -o wide
NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES
busybox 1/1 Running &lt;span class="m">0&lt;/span> 2m17s 172.17.0.5 cka &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
pod-nginx 1/1 Running &lt;span class="m">0&lt;/span> 59m 172.17.0.4 cka &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行 nslookup&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl &lt;span class="nb">exec&lt;/span> busybox -it -- nslookup 172.17.0.4
4.0.17.172.in-addr.arpa &lt;span class="nv">name&lt;/span> &lt;span class="o">=&lt;/span> 172-17-0-4.service-nginx.default.svc.cluster.local.
$ kubectl &lt;span class="nb">exec&lt;/span> busybox -it -- nslookup service-nginx
Server: 10.96.0.10
Address: 10.96.0.10#53
Name: service-nginx.default.svc.cluster.local
Address: 10.110.253.70
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="工作负载扩容">工作负载：扩容&lt;/h2>
&lt;blockquote>
&lt;p>将命名空间 &lt;code>dev&lt;/code> 中的 Deployment &lt;code>scale-deploy&lt;/code> 缩放到三个 pod 并记录下来。&lt;/p>
&lt;/blockquote>
&lt;p>参考文档：https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment&lt;/p>
&lt;h3 id="知识点-6">知识点&lt;/h3>
&lt;ul>
&lt;li>deployment scale up&lt;/li>
&lt;li>kubectl scale&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-6">解题思路&lt;/h3>
&lt;p>&lt;code>kubectl scale&lt;/code> 的使用，需要参数 &lt;code>--record&lt;/code> 进行记录（将操作命令记录到 deployment 的 &lt;code>kubernetes.io/change-cause&lt;/code> annotation 中）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl scale deployment scale-deploy --replicas &lt;span class="m">3&lt;/span> --record
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="集群备份及恢复">集群备份及恢复&lt;/h2>
&lt;blockquote>
&lt;p>备份 etcd 并将其保存在主节点上的 &lt;code>/root/cka/etcd-backup.db&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>最后恢复备份。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-7">知识点&lt;/h3>
&lt;ul>
&lt;li>etcd 的备份及恢复&lt;/li>
&lt;/ul>
&lt;p>参考文档：https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster&lt;/p>
&lt;h3 id="解题思路-7">解题思路&lt;/h3>
&lt;p>Kubernetes 的所有数据都记录在 etcd 中，对 etcd 进行备份就是对集群进行备份。&lt;/p>
&lt;p>连接 etcd 需要证书，证书可以从 apiserver 获取，因为 apiserver 需要连接 etcd。新版本的 apiserver 都是以 static pod 的方式运行，证书是通过 volume 挂载到 pod 中的。&lt;/p>
&lt;p>比如 minikube 环境，证书是从 node 节点的 &lt;code>/var/lib/minikube/certs&lt;/code> 挂载进去的。&lt;/p>
&lt;p>要先 ssh 到 master 节点上。命令的执行非常快，如果长时间没结束，那就说名有问题了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#备份&lt;/span>
$ &lt;span class="nv">ETCDCTL_API&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> etcdctl snapshot save /root/cka/etcd-backup.db &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--endpoints&lt;span class="o">=&lt;/span>https://127.0.0.1:2379 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--cacert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/etcd/ca.crt &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--cert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.crt &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--key&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.key
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于只说了 restore，所以就执行 restore 的命令，默认会恢复到当前目录的 &lt;code>default.etcd&lt;/code> 下。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#恢复&lt;/span>
$ &lt;span class="nv">ETCDCTL_API&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> etcdctl snapshot restore /root/cka/etcd-backup.db &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--endpoints&lt;span class="o">=&lt;/span>https://127.0.0.1:2379 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--cacert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/etcd/ca.crt &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--cert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.crt &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--key&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.key
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="集群节点升级">集群节点升级&lt;/h2>
&lt;blockquote>
&lt;p>将master节点版本从 1.20.0 升级到 1.21.0，确保 master 节点上的 pod 重新调度到其他节点，升级完成后，使 master 节点可用。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-8">知识点&lt;/h3>
&lt;ul>
&lt;li>drain&lt;/li>
&lt;li>cordon&lt;/li>
&lt;/ul>
&lt;p>参考文档：https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/#upgrading-control-plane-nodes&lt;/p>
&lt;h3 id="解题思路-8">解题思路&lt;/h3>
&lt;p>受限于环境，没有实地操作。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># 将节点设置为不可调度&lt;/span>
$ kubectl cordon master
&lt;span class="c1"># 驱逐 master 节点上的 pod&lt;/span>
$ kubectl drain master --ignore-daemonsets
&lt;span class="c1"># 进行升级&lt;/span>
$ apt-mark unhold kubelet kubectl &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt-get install -y &lt;span class="nv">kubelet&lt;/span>&lt;span class="o">=&lt;/span>1.21.0-00 &lt;span class="nv">kubectl&lt;/span>&lt;span class="o">=&lt;/span>1.21.0-00 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>apt-mark hold kubelet kubectl
&lt;span class="c1"># 重新启动kubelet&lt;/span>
$ systemctl daemon-reload
$ systemctl restart kubelet
&lt;span class="c1"># 将节点设置为可调度&lt;/span>
$ kubectl uncordon master
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="集群节点故障排查">集群：节点故障排查&lt;/h2>
&lt;blockquote>
&lt;p>现在 node01 还没有准备好，请找出根本原因并使其准备好，然后创建一个确保它在 node01 上运行的 pod。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-9">知识点&lt;/h3>
&lt;ul>
&lt;li>节点故障排查&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-9">解题思路&lt;/h3>
&lt;p>这种问题大概率问题出在 kubelet 上&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">ssh node01
systemctl status kubelet
systemctl restart kubelet
&lt;span class="c1"># 再检查node状态&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>插播一个故障，本地安装 2 个节点的 minikube 集群时，第二个节点持续 &lt;code>NotReady&lt;/code>。使用 &lt;code>systemctl status kubelet&lt;/code> 看到 &lt;code>unable to update cni config: no networks found in /etc/cni/net.mk&lt;/code>。&lt;/p>
&lt;p>检查该目录确实没有文件，从 master 节点复制到该节点后重启 kubelet 解决。&lt;/p>
&lt;h2 id="存储持久化卷">存储：持久化卷&lt;/h2>
&lt;blockquote>
&lt;p>集群中有一个持久卷名称 &lt;code>dev-pv&lt;/code>，创建一个持久卷声明名称 &lt;code>dev-pvc&lt;/code>，确保这个持久卷声明会绑定持久卷，然后创建一个 pod 名称 &lt;code>test-pvc&lt;/code>，将这个 pvc 挂载到 path &lt;code>/tmp/data&lt;/code>，使用 nginx 镜像。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-10">知识点&lt;/h3>
&lt;ul>
&lt;li>PersistentVolume&lt;/li>
&lt;li>PersistentVolumeClaim&lt;/li>
&lt;li>Mount Volume&lt;/li>
&lt;/ul>
&lt;p>参考文档：https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume&lt;/p>
&lt;h3 id="解题思路-10">解题思路&lt;/h3>
&lt;p>创建 pvc 前先获取 pv的信息&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pv dev-pv -o yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 pv&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; pvc.yaml &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">apiVersion: v1
&lt;/span>&lt;span class="s">kind: PersistentVolumeClaim
&lt;/span>&lt;span class="s">metadata:
&lt;/span>&lt;span class="s"> name: dev-pvc
&lt;/span>&lt;span class="s">spec:
&lt;/span>&lt;span class="s"> accessModes:
&lt;/span>&lt;span class="s"> - ReadWriteOnce
&lt;/span>&lt;span class="s"> resources:
&lt;/span>&lt;span class="s"> requests:
&lt;/span>&lt;span class="s"> storage: 1Gi
&lt;/span>&lt;span class="s">EOF&lt;/span>
$ kubectl apply -f pvc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 pod 的 manifest，记得使用 &lt;code>kubectl run --dry-run=client -o yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl run test-pvc --image nginx --dry-run&lt;span class="o">=&lt;/span>client -o yaml &amp;gt; test-pvc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改之后得到最终的 pod yaml&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeClaim&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">claimName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dev-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/tmp/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>理论上只要 pod 能运行，就说明成功。也可以进一步确认挂载是否成功，在 pod 的 &lt;code>/tmp/data&lt;/code> 中 touch 个文件，然后到节点的目录中查看是有该文件。&lt;/p>
&lt;h2 id="工作负载多容器的-deployment">工作负载：多容器的 Deployment&lt;/h2>
&lt;blockquote>
&lt;p>创建一个名为 &lt;code>deploy-important&lt;/code> 的 Deployment，标签为 &lt;code>id=very-important&lt;/code>（pod 也应该有这个标签）和命名空间 dev 中的 3 个副本。 它应该包含两个容器，第一个名为 &lt;code>container1&lt;/code> 并带有镜像，第二个名为 container2 的图像为 &lt;code>kubernetes/pause&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在一个工作节点上应该只运行该部署的一个 Pod。 我们有两个工作节点：&lt;code>cluster1-worker1&lt;/code> 和 &lt;code>cluster1-worker2&lt;/code>。 因为 Deployment 有三个副本，所以结果应该是在两个节点上都有一个 Pod 正在运行。 不会调度第三个 Pod，除非添加新的工作节点。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-11">知识点&lt;/h3>
&lt;ul>
&lt;li>deployment&lt;/li>
&lt;li>pod label&lt;/li>
&lt;li>replicas&lt;/li>
&lt;li>multi container pod&lt;/li>
&lt;li>pod anti affinity&lt;/li>
&lt;/ul>
&lt;p>官方文档参考：https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#never-co-located-in-the-same-node&lt;/p>
&lt;h3 id="解题思路-11">解题思路&lt;/h3>
&lt;p>先创建模板&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl create deployment deploy-important --image nginx --replicas &lt;span class="m">3&lt;/span> --dry-run&lt;span class="o">=&lt;/span>client -o yaml &amp;gt; deploy-important.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改后的 yaml&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">very-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">very-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">strategy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">very-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">affinity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">podAntiAffinity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requiredDuringSchedulingIgnoredDuringExecution&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">labelSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchExpressions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">In&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">values&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">very-important&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">topologyKey&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kubernetes.io/hostname&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">container1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kubernetes/pause&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">container2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>minikube 上测试只能调度一个 pod，符合预期&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kgpo
NAME READY STATUS RESTARTS AGE
deploy-important-659d54fc47-6cp8r 0/2 Pending &lt;span class="m">0&lt;/span> 3h10m
deploy-important-659d54fc47-92z4d 2/2 Running &lt;span class="m">0&lt;/span> 3h10m
deploy-important-659d54fc47-c6llc 0/2 Pending &lt;span class="m">0&lt;/span> 3h10m
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="存储secret的使用">存储：Secret的使用&lt;/h2>
&lt;blockquote>
&lt;p>在 &lt;code>secret&lt;/code> 命名空间下，使用镜像 &lt;code> busybox:1.31.1&lt;/code> 创建一个名为 &lt;code>secret-pod&lt;/code> 的 pod，并保证 pod 运行一段时间&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>有个名为 &lt;code>sercret1.yaml&lt;/code> 的 Secret 文件，在 &lt;code>secret&lt;/code> 命名空间下创建 Secret，并以只读的方式挂在到 Pod 的 &lt;code>/tmp/secret1&lt;/code> 目录
创建一个新的 Secret &lt;code>secret2&lt;/code> 包含 &lt;code>user=user1&lt;/code> 和 &lt;code>pass=1234&lt;/code>，分别以缓解变量 &lt;code>APP_USER&lt;/code> 和 &lt;code>APP_PASS&lt;/code> 输入到 Pod 中&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-12">知识点&lt;/h3>
&lt;ul>
&lt;li>secret&lt;/li>
&lt;li>toleration&lt;/li>
&lt;li>taints&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets">https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets&lt;/a>
&lt;a href="https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables">https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables&lt;/a>&lt;/p>
&lt;h3 id="解题思路-12">解题思路&lt;/h3>
&lt;p>创建 namespace&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl create ns secret
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 pod 模板&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ kubectl run secret-pod --image busybox:1.31.1 --dry-run=client -o yaml --command -- sleep 1d &amp;gt; secret-pod.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 secret1.yaml，使用 secret namespace&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">halt&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IyEvYmluL2Jhc2g=&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2021-05-15T07:48:02Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Opaque&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 secret2&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl create secret generic secret2 --from-literal &lt;span class="nv">user&lt;/span>&lt;span class="o">=&lt;/span>user1 --from-literal &lt;span class="nv">pass&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1234&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改模板&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">sleep&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">1d&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox:1.31.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">APP_USER&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">valueFrom&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretKeyRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">user&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">APP_PASS&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">valueFrom&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretKeyRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pass&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/tmp/secret1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sec&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sec&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl &lt;span class="nb">exec&lt;/span> secret-pod -- cat /tmp/secret1/halt
&lt;span class="c1">#!/bin/bash&lt;/span>
$ kubectl &lt;span class="nb">exec&lt;/span> secret-pod -- env &lt;span class="p">|&lt;/span> grep &lt;span class="s1">&amp;#39;APP_&amp;#39;&lt;/span>
&lt;span class="nv">APP_USER&lt;/span>&lt;span class="o">=&lt;/span>user1
&lt;span class="nv">APP_PASS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1234&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="工作负载静态-pod">工作负载：静态 Pod&lt;/h2>
&lt;blockquote>
&lt;p>在 &lt;code>cluster3-master1&lt;/code> 上的 &lt;code>default&lt;/code> 命名空间中创建一个名为 &lt;code>my-static-pod&lt;/code> 的静态 Pod。 使用镜像 &lt;code>nginx:1.16-alpine&lt;/code> 并分配 10m CPU 和 20Mi 内存的资源。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Then create a NodePort Service named static-pod-service which exposes that static Pod on port 80 and check if it has Endpoints and if its reachable through the cluster3-master1 internal IP address. You can connect to the internal node IPs from your main terminal.
然后创建一个名为&lt;code> static-pod-service&lt;/code> 的 NodePort Service，该服务在端口 80 上公开该静态 Pod，并检查它是否具有端点以及是否可以通过 &lt;code>cluster3-master1&lt;/code> 内部 IP 地址访问它。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-13">知识点&lt;/h3>
&lt;ul>
&lt;li>static pod&lt;/li>
&lt;li>resource&lt;/li>
&lt;li>nodeport service&lt;/li>
&lt;li>endpoints&lt;/li>
&lt;/ul>
&lt;p>参考文档：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/">https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory">https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-13">解题思路&lt;/h3>
&lt;p>创建pod模板&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl run my-static-pod --image nginx:1.16-alpine --dry-run&lt;span class="o">=&lt;/span>client -o yaml &amp;gt; static-pod.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改模板，增加资源配置&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-static-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-static-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:1.16-alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-static-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cpu&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;10m&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">memory&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;20Mi&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ssh 到主机，找到 kubelet 配置文件的位置 &lt;code>ps -ef | grep kubelet&lt;/code>&lt;/p>
&lt;p>查看配置文件（minikube：/var/lib/kubelet/config.yaml）中 &lt;code>staticPodPath&lt;/code> 配置的就是静态 pod 的 manifest 的位置（minikube：/etc/kubernetes/manifests）&lt;/p>
&lt;p>将 &lt;code>static-pod.yaml&lt;/code> 放到正确的文件夹中，然后重启 kubelet&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ systemctl restart kubelet
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查pod是否正确运行&lt;/p>
&lt;p>创建 node port&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl expose pod my-static-pod --name static-pod-service --type NodePort --port &lt;span class="m">80&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查是否创建成功&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get svc
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span class="o">(&lt;/span>S&lt;span class="o">)&lt;/span> AGE
static-pod-service NodePort 10.97.248.99 &amp;lt;none&amp;gt; 80:31938/TCP 68s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取 node 的 ip&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get node -o wide
NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME
cka Ready master 10h v1.18.8 192.168.64.3 &amp;lt;none&amp;gt; Buildroot 2020.02.10 4.19.171 docker://20.10.4
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 minikube 的环境下可直接通过 &lt;code>minikube ip&lt;/code> 获取&lt;/p>
&lt;p>测试&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ http 192.168.64.3:31938 --headers
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
Accept-Ranges: bytes
Connection: keep-alive
Content-Length: &lt;span class="m">612&lt;/span>
Content-Type: text/html
Date: Sat, &lt;span class="m">15&lt;/span> May &lt;span class="m">2021&lt;/span> 08:35:11 GMT
ETag: &lt;span class="s2">&amp;#34;5d52db33-264&amp;#34;&lt;/span>
Last-Modified: Tue, &lt;span class="m">13&lt;/span> Aug &lt;span class="m">2019&lt;/span> 15:45:55 GMT
Server: nginx/1.16.1
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="调度污点和容忍度">调度：污点和容忍度&lt;/h2>
&lt;blockquote>
&lt;p>在命名空间 &lt;code>default&lt;/code> 中创建图像 &lt;code>httpd:2.4.41-alpine&lt;/code> 的单个 Pod。Pod 应命名为 &lt;code>pod1&lt;/code>，容器名为 &lt;code>pod1-container&lt;/code>。在不给任何节点添加新标签的前提下，将该 pod 调度到主节点上。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-14">知识点&lt;/h3>
&lt;ul>
&lt;li>Taint&lt;/li>
&lt;li>Label&lt;/li>
&lt;li>Tolerance&lt;/li>
&lt;/ul>
&lt;p>参考文档：https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/&lt;/p>
&lt;h3 id="解题思路-14">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">#找出master节点（一般考试只有一个节点）
$ kubectl get node
#找到 master 节点的 taints，需要在 pod 的 .spec.tolerations 排除掉
$ kubectl describe node xxxx | grep -w Taints
#找到 master 节点的 labels
$ kubectl describe node xxxx | grep -w Labels -A10
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建pod模板&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl run pod1 --image httpd:2.4.41-alpine --dry-run&lt;span class="o">=&lt;/span>client -o yaml &amp;gt; pod1.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改模板： 这里假设主节点的 Taint 为 &lt;code>node-role.kubernetes.io/master=:NoSchedule&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># minikube 集群名为 cka，主节点同名&lt;/span>
$ kubectl describe node cka &lt;span class="p">|&lt;/span> grep -i taint
Taints: node-role.kubernetes.io/master:NoSchedule
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终的 pod 如下&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpd:2.4.41-alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tolerations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node-role.kubernetes.io/master&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">effect&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NoSchedule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">nodeSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">node-role.kubernetes.io/master&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后检查下是否调度到主节点上：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod -o wide
NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES
pod1 1/1 Running &lt;span class="m">0&lt;/span> 102s 10.244.0.3 cka &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kubectl-命令和排序">kubectl 命令和排序&lt;/h2>
&lt;blockquote>
&lt;p>所有命名空间中都有各种 Pod。 将命令写入 /opt/course/5/find_pods.sh，其中列出所有按 AGE 排序的 Pod（metadata.creationTimestamp）。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>将第二个命令写入 /opt/course/5/find_pods_uid.sh，其中列出按字段 metadata.uid 排序的所有 Pod。对这两个命令都使用 kubectl 排序。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-15">知识点&lt;/h3>
&lt;ul>
&lt;li>kubectl 命令的使用，主要是 &lt;code>--all-namespaces&lt;/code> （缩写 &lt;code>-A&lt;/code>） 和 &lt;code>--sort-by&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-15">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; /opt/course/5/find_pods.sh &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">kubectl get pod -A --sort-by &amp;#39;.metadata.creationTimestamp&amp;#39;
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; /opt/course/5/find_pods_uid.sh &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">kubectl get pod -A --sort-by &amp;#39;.metadata.uid&amp;#39;
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="存储持久化卷和挂载">存储：持久化卷和挂载&lt;/h2>
&lt;blockquote>
&lt;p>创建一个名为 &lt;code>safari-pv&lt;/code> 的新 &lt;code>PersistentVolume&lt;/code>。它应该具有 2Gi 的容量、&lt;code>accessMode&lt;/code> &lt;code>ReadWriteOnce&lt;/code>、&lt;code>hostPath&lt;/code> &lt;code>/Volumes/Data&lt;/code> 并且没有定义 &lt;code>storageClassName&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>接下来在命名空间 &lt;code>project-tiger&lt;/code> 中创建一个名为 &lt;code>safari-pvc&lt;/code> 的新 &lt;code>PersistentVolumeClaim&lt;/code>。 它应该请求 2Gi 存储，&lt;code>accessMode&lt;/code> &lt;code>ReadWriteOnce&lt;/code> 并且不应定义 &lt;code>storageClassName&lt;/code>。 PVC 应该正确绑定到 PV。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>最后在命名空间 &lt;code>project-tiger&lt;/code> 中创建一个新的 Deployment &lt;code>safari&lt;/code>，它将该卷挂载到 &lt;code>/tmp/safari-data&lt;/code>。该 Deployment 的 Pod 应该是镜像 httpd:2.4.41-alpine。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-16">知识点&lt;/h3>
&lt;ul>
&lt;li>pv&lt;/li>
&lt;li>pvc&lt;/li>
&lt;li>pod 使用 pvc&lt;/li>
&lt;li>deployment&lt;/li>
&lt;li>mount PVC volume&lt;/li>
&lt;/ul>
&lt;p>参考文档：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume">https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim">https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-16">解题思路&lt;/h3>
&lt;p>创建 pv&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">safari-pv&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">local&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capacity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">2Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteOnce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/Volumes/Data&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 pvc&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolumeClaim&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">safari-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteOnce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">2Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查是否绑定成功&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pvc
NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE
safari-pvc Bound pvc-d4c15825-2de3-470f-8ed0-9519cacaad21 2Gi RWO standard 24s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 deployment 模板&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl create deployment safari --image httpd:2.4.41-alpine --dry-run&lt;span class="o">=&lt;/span>client -o yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终的yaml&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">safari&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">safari&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">safari&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">strategy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">safari&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpd:2.4.41-alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/tmp/safari-data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeClaim&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">claimName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">safari-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kubectl-命令和-context">kubectl 命令和 context&lt;/h2>
&lt;blockquote>
&lt;p>可以通过 kubectl 上下文从主终端访问多个集群。将所有这些上下文名称写入 /opt/course/1/contexts。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>接下来在 /opt/course/1/context_default_kubectl.sh 中写一个显示当前上下文的命令，该命令应该使用kubectl。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>最后在 /opt/course/1/context_default_no_kubectl.sh 中写入第二个执行相同操作的命令，但不使用 kubectl。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-17">知识点&lt;/h3>
&lt;p>kubectl config 相关命令的使用&lt;/p>
&lt;h3 id="解题思路-17">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl config get-contexts -o name &amp;gt; /opt/course/1/contexts
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">cat &amp;gt; /opt/course/1/context_default_kubectl.sh &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">kubectl config current-context
&lt;/span>&lt;span class="s">EOF&lt;/span>
chmod +x /opt/course/1/context_default_kubectl.sh
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">cat ~/.kube/config &lt;span class="p">|&lt;/span> grep current-context &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{print $2}&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="工作负载缩容">工作负载：缩容&lt;/h2>
&lt;blockquote>
&lt;p>命名空间 &lt;code>project-c13&lt;/code> 中有两个名为 &lt;code>o3db-*&lt;/code> 的 Pod。 C13 管理层要求将 Pod 缩减为一个副本以节省资源。 记录动作。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-18">知识点&lt;/h3>
&lt;ul>
&lt;li>scale&lt;/li>
&lt;li>deploy&lt;/li>
&lt;li>statefulset&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/zh/docs/tasks/run-application/scale-stateful-set/">https://kubernetes.io/zh/docs/tasks/run-application/scale-stateful-set/&lt;/a>
&lt;a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment">https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment&lt;/a>&lt;/p>
&lt;h3 id="解题思路-18">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl scale &amp;lt;resource&amp;gt; xxx --replicas&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>scale 命令需要确认资源类型：deployment/statefulset&lt;/p>
&lt;h2 id="应用就绪和探活">应用就绪和探活&lt;/h2>
&lt;blockquote>
&lt;p>在命名空间 &lt;code>default&lt;/code> 中执行以下操作。为 &lt;code>nginx:1.16.1-alpine&lt;/code> 创建一个名为 &lt;code>ready-if-service-ready&lt;/code> 的 Pod。配置一个 &lt;code>LivenessProbe&lt;/code>，它只是运行 &lt;code>true&lt;/code>。还要配置一个 &lt;code>ReadinessProbe&lt;/code> 来检查 &lt;code>url&lt;/code> &lt;code>http://service-am-i-ready:80&lt;/code> 是否可达，可以使用 &lt;code>wget -T2 -O- http://service-am-i-ready:80&lt;/code>。 启动 Pod 并确认它因为 &lt;code>ReadinessProbe&lt;/code> 而没有准备好。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>创建第二个名为 &lt;code>am-i-ready&lt;/code> 的 Pod 镜像 &lt;code>nginx:1.16.1-alpine&lt;/code>，标签 &lt;code>id:cross-server-ready&lt;/code>。已经存在的服务 &lt;code>service-am-i-ready&lt;/code> 现在应该有第二个 Pod 作为端点。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-19">知识点&lt;/h3>
&lt;ul>
&lt;li>probe&lt;/li>
&lt;li>pod&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&lt;/a>&lt;/p>
&lt;h3 id="解题思路-19">解题思路&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">kubectl run ready-if-service-ready --image nginx:1.16.1-alpine --dry-run=client -o yaml &amp;gt; ready-if-service-ready.yaml
kubectl run am-i-ready --image nginx:1.16.1-alpine --labels id=cross-server-ready --dry-run=client -o yaml &amp;gt; am-i-ready.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加 probes&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ready-if-service-ready&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ready-if-service-ready&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:1.16.1-alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ready-if-service-ready&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">livenessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">echo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">hi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">readinessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">wget&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">T2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">O-&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">http://service-am-i-ready:80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="集群控制平面">集群：控制平面&lt;/h2>
&lt;blockquote>
&lt;p>使用 &lt;code>ssh cluster1-master1&lt;/code> ssh 进入主节点。检查 master 组件 kubelet、kube-apiserver、kube-scheduler、kube-controller-manager 和 etcd 如何在 master 节点上启动/安装。还要找出 DNS 应用的名称以及它是如何在主节点上启动/安装的。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>将结果写入文件 /opt/course/8/master-components.txt。该文件的结构应如下所示：&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"># /opt/course/8/master-components.txt
kubelet: [TYPE]
kube-apiserver: [TYPE]
kube-scheduler: [TYPE]
kube-controller-manager: [TYPE]
etcd: [TYPE]
dns: [TYPE] [NAME]
&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;blockquote>
&lt;p>Choices of [TYPE] are: not-installed, process, static-pod, pod&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-20">知识点&lt;/h3>
&lt;p>Kubernetes components 的安装方式&lt;/p>
&lt;h3 id="解题思路-20">解题思路&lt;/h3>
&lt;p>当前比较的组件都是以static pod的形式运行的，而 static pod 都是由 Kubelet 管理的，所以从 kubelet 处入手。&lt;/p>
&lt;p>以 minikube 为例：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ps -ef &lt;span class="p">|&lt;/span> grep -w kubelet
root &lt;span class="m">140597&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> May15 ? 00:36:00 /var/lib/minikube/binaries/v1.18.8/kubelet --bootstrap-kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/bootstrap-kubelet.conf --config&lt;span class="o">=&lt;/span>/var/lib/kubelet/config.yaml --container-runtime&lt;span class="o">=&lt;/span>docker --hostname-override&lt;span class="o">=&lt;/span>cka --kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/kubelet.conf --node-ip&lt;span class="o">=&lt;/span>192.168.64.3
$ systemctl is-active kubelet
active
&lt;span class="c1">#kubelet: process&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据前面进程中的信息，查看 &lt;code>/var/lib/kubelet/config.yaml&lt;/code>中的内容。可以得到：&lt;/p>
&lt;p>etcd: static-pod
kube-apiserver: static-pod
kube-controller-manager: static-pod&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat /var/lib/kubelet/config.yaml &lt;span class="p">|&lt;/span> grep -i staticpod
staticPodPath: /etc/kubernetes/manifests
ls /etc/kubernetes/manifests
etcd.yaml kube-apiserver.yaml kube-controller-manager.yaml kube-scheduler.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后上下dns，查看下pod，得知 dns: pod&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod -A &lt;span class="p">|&lt;/span> grep dns
kube-system coredns-66bff467f8-6k2br 1/1 Running &lt;span class="m">0&lt;/span> 32h
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后将上面的结果写入到 &lt;code>/opt/course/8/master-components.txt&lt;/code>，不能前功尽弃。&lt;/p>
&lt;h2 id="集群pod-调度">集群：Pod 调度&lt;/h2>
&lt;blockquote>
&lt;p>使用 &lt;code>ssh cluster2-master1&lt;/code> ssh 进入主节点。暂时停止 &lt;code>kube-scheduler&lt;/code>，这意味着可以在之后再次启动它。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>为镜像 &lt;code>httpd:2.4-alpine&lt;/code> 创建一个名为 &lt;code>manual-schedule&lt;/code> 的 Pod，确认它已启动但未在任何节点上调度。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>现在您是调度程序并拥有所有权力，在节点 &lt;code>cluster2-master1&lt;/code> 上手动调度该 Pod。 确保它正在运行。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>再次启动 &lt;code>kube-scheduler&lt;/code> 并通过在镜像 &lt;code>httpd:2.4-alpine&lt;/code> 创建第二个名为 &lt;code>manual-schedule2&lt;/code> 的 Pod 并检查它是否在 &lt;code>cluster2-worker1&lt;/code> 上运行来确认其运行正常。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-21">知识点&lt;/h3>
&lt;ul>
&lt;li>kubernetes 组件的运行方式&lt;/li>
&lt;li>创建 pod&lt;/li>
&lt;li>pod 调度&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-21">解题思路&lt;/h3>
&lt;p>kube-scheduler 是以 static pod 的方式运行，因此我们需要 ssh 到节点上，将 scheduler 的 yaml 移出（记住不要删掉，还要还原回去），重启 kubelet&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ps -ef &lt;span class="p">|&lt;/span> grep -w kubelet
root &lt;span class="m">140597&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> May15 ? 00:36:00 /var/lib/minikube/binaries/v1.18.8/kubelet --bootstrap-kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/bootstrap-kubelet.conf --config&lt;span class="o">=&lt;/span>/var/lib/kubelet/config.yaml --container-runtime&lt;span class="o">=&lt;/span>docker --hostname-override&lt;span class="o">=&lt;/span>cka --kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/kubelet.conf --node-ip&lt;span class="o">=&lt;/span>192.168.64.3
$ cat /var/lib/kubelet/config.yaml &lt;span class="p">|&lt;/span> grep -i staticpod
staticPodPath: /etc/kubernetes/manifests
$ ls /etc/kubernetes/manifests
etcd.yaml kube-apiserver.yaml kube-controller-manager.yaml kube-scheduler.yaml
$ mv /etc/kubernetes/manifests/kube-scheduler.yaml /etc/kubernetes
$ systemctl restart kubelet
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查下 schedule pod 没有运行，然后尝试创建 pod，并查看 pod 处于 pending 状态，即没有 kube-scheduler 为其调度。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl run manual-schedule --image httpd:2.4-alpine
$ kubectl get pod &lt;span class="p">|&lt;/span> grep manual-schedule
manual-schedule 0/1 Pending &lt;span class="m">0&lt;/span> 16s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>手动调度，即为 pod 指定一个 &lt;code>nodeName&lt;/code>，我的 minikube 只有一个 node 名为 cka，修改pod：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod manual-schedule -o yaml &amp;gt; manual-schedule.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加 nodeName 之后&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2021-05-16T07:27:16Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manual-schedule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manual-schedule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dev&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;84805&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selfLink&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/api/v1/namespaces/dev/pods/manual-schedule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uid&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">c4b592f6-1e07-4911-a7fe-867d813c7a55&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpd:2.4-alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manual-schedule&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">terminationMessagePath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/dev/termination-log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">terminationMessagePolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">File&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/var/run/secrets/kubernetes.io/serviceaccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default-token-v7f28&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">readOnly&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">nodeName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cka&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#node name here&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">enableServiceLinks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">priority&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">schedulerName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default-scheduler&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">securityContext&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceAccount&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceAccountName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">terminationGracePeriodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tolerations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">effect&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NoExecute&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node.kubernetes.io/not-ready&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Exists&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tolerationSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">300&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">effect&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NoExecute&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node.kubernetes.io/unreachable&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Exists&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tolerationSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">300&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default-token-v7f28&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">defaultMode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">420&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default-token-v7f28&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">phase&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pending&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">qosClass&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">BestEffort&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>强制更新 pod（运行时只能修改部分内容）：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl replace -f manual-schedule.yaml --force
pod &lt;span class="s2">&amp;#34;manual-schedule&amp;#34;&lt;/span> deleted
pod/manual-schedule replaced
&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次检查&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod &lt;span class="p">|&lt;/span> grep manual-schedule
manual-schedule 1/1 Running &lt;span class="m">0&lt;/span> 15s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>恢复 kube-scheduler 的运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ mv /etc/kubernetes/kube-scheduler.yaml /etc/kubernetes/manifests
$ systemctl restart kubelet
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查是否运行&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod -A &lt;span class="p">|&lt;/span> grep kube-scheduler
kube-system kube-scheduler-cka 1/1 Running &lt;span class="m">0&lt;/span> 66s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建第二个pod，并检查是否在运行（running）状态&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl run manual-schedule2 --image httpd:2.4-alpine
pod/manual-schedule2 created
kubectl get pod manual-schedule2
NAME READY STATUS RESTARTS AGE
manual-schedule2 1/1 Running &lt;span class="m">0&lt;/span> 6s
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="集群备份及恢复-1">集群：备份及恢复&lt;/h2>
&lt;blockquote>
&lt;p>对在 &lt;code>cluster3-master1&lt;/code> 上运行的 etcd 进行备份，并将其保存在主节点上的 &lt;code>/tmp/etcd-backup.db&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>然后在集群中创建一个你喜欢的 Pod。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>最后恢复备份，确认集群仍在工作并且创建的 Pod 不再与我们在一起。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-22">知识点&lt;/h3>
&lt;ul>
&lt;li>etc 的作用：存储集群的状态信息，包括 pod 信息&lt;/li>
&lt;li>etc 的备份和恢复&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster">https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster&lt;/a>&lt;/p>
&lt;h3 id="解题思路-22">解题思路&lt;/h3>
&lt;p>etcd的命令执行，记得设置API的版本 &lt;code>ETCDCTL_API=3&lt;/code>&lt;/p>
&lt;p>操作 etcd 需要 &lt;code>endpoints&lt;/code>、&lt;code>cacert&lt;/code>、&lt;code>cert&lt;/code>、&lt;code>key&lt;/code>。Kubernetes 的所有组件与 etcd 的数据交互都是通过 api-server 完成的，我只需要找到 api-server 的运行命令就行，两种方式：到 master 主机查看 api-server 的进程；或者去 api-server 的 pod 查看 &lt;code>.spec.containers[].command&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#ssh to master&lt;/span>
$ ps -ef &lt;span class="p">|&lt;/span> grep kube-apiserver
$ kubectl get pod -n kube-system kube-apiserver-cka -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.spec.containers[].command}&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>etcd 备份，命令直接从 Kubernetes 官方文档复制再修改&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#ssh to master&lt;/span>
&lt;span class="nv">$ETCDCTL_API&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> etcdctl --endpoints&lt;span class="o">=&lt;/span>https://127.0.0.1:2379 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --cacert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/etcd/ca.crt --cert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.crt --key&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.key &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> snapshot save /tmp/etcd-backup.db
Snapshot saved at /tmp/etcd-backup.db
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 pod&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl run sleep1d --image busybox --command -- sleep 1d
&lt;span class="c1">#检查 pod 运行情况&lt;/span>
$ kubectl get pod
NAME READY STATUS RESTARTS AGE
sleep1d 1/1 Running &lt;span class="m">0&lt;/span> 10s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>恢复 etcd 的备份，复制前面的命令并修改，恢复备份到 &lt;code>/var/lib/etcd-backup&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ &lt;span class="nv">ETCDCTL_API&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> etcdctl --endpoints&lt;span class="o">=&lt;/span>https://127.0.0.1:2379 --cacert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/etcd/ca.crt --cert&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.crt --key&lt;span class="o">=&lt;/span>/var/lib/minikube/certs/apiserver-etcd-client.key snapshot restore /tmp/etcd-backup.db --data-dir /var/lib/etcd-backup
2021-05-16 08:09:17.797061 I &lt;span class="p">|&lt;/span> mvcc: restore compact to &lt;span class="m">85347&lt;/span>
2021-05-16 08:09:17.803208 I &lt;span class="p">|&lt;/span> etcdserver/membership: added member 8e9e05c52164694d &lt;span class="o">[&lt;/span>http://localhost:2380&lt;span class="o">]&lt;/span> to cluster cdf818194e3a8c32
&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改 etcd 的配置， &lt;code>/etc/kubernetes/manifests/etcd.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/var/lib/minikube/certs/etcd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DirectoryOrCreate&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">etcd-certs&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/var/lib/etcd-backup &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#原来是/var/lib/minikube/etcd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DirectoryOrCreate&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">etcd-data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>保存后重启kubelet&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ systemctl restart kubelet
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查pod是否存在：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod sleep1d
Error from server &lt;span class="o">(&lt;/span>NotFound&lt;span class="o">)&lt;/span>: pods &lt;span class="s2">&amp;#34;sleep1d&amp;#34;&lt;/span> not found
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安全网络策略">安全：网络策略&lt;/h2>
&lt;blockquote>
&lt;p>发生了一起安全事件，入侵者能够从一个被黑的后端 Pod 访问整个集群。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>为了防止这种情况，在命名空间 &lt;code>project-snake&lt;/code> 中创建一个名为 &lt;code>np-backend&lt;/code> 的 &lt;code>NetworkPolicy&lt;/code>。它应该只允许 &lt;code>backend-*&lt;/code> Pods：&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>连接到端口 &lt;code>1111&lt;/code> 上的 &lt;code>db1-*&lt;/code> Pod
连接到端口 &lt;code>2222&lt;/code> 上的 &lt;code>db2-*&lt;/code> Pod
在策略中使用 Pod 的应用程序标签。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>实施后，例如，端口 3333 上从 &lt;code>backend-*&lt;/code> Pod 到 &lt;code>vault-*&lt;/code> Pod 的连接应该不再有效。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-23">知识点&lt;/h3>
&lt;ul>
&lt;li>NetworkPolicy&lt;/li>
&lt;/ul>
&lt;p>参考文档：
&lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies">https://kubernetes.io/docs/concepts/services-networking/network-policies&lt;/a>&lt;/p>
&lt;h3 id="解题思路-23">解题思路&lt;/h3>
&lt;p>为 backend-* pod 设置 egress 的 NetworkPolicy，只允许其访问 db1-* 的 1111 端口和 db2-* 的 2222 端口，策略中使用 app label 来进行匹配。&lt;/p>
&lt;p>从 Kubernetes 官网文档中复制一段yaml配置进行修改。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">np-backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">project-snake&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">policyTypes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">Egress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">egress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">to&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">db1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1111&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">to&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">db2 &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2222&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设 backend pod 的 app label 为 backend，db1 的 为 db1，db2 的为 db2。&lt;/p>
&lt;p>创建环境：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl run backend --image nginx --labels &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>backend
$ kubectl run db1 --image nginx --labels &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>db1
$ kubectl run db2 --image nginx --labels &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>db2
$ kubectl run vault --image nginx --labels &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>vault
$ kubectl get pod -L app
NAME READY STATUS RESTARTS AGE APP
backend 1/1 Running &lt;span class="m">0&lt;/span> 13s backend
db1 1/1 Running &lt;span class="m">0&lt;/span> 66s db1
db2 1/1 Running &lt;span class="m">0&lt;/span> 71s db2
vault 1/1 Running &lt;span class="m">0&lt;/span> 79s vault
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于我们用的 nginx 镜像，将前面的 NetworkPolicy 端口修改一下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">np-backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">policyTypes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">Egress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">egress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">to&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">db1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">to&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">db2 &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查一下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get networkpolicy
NAME POD-SELECTOR AGE
np-backend &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>backend 31s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试下网络：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#获取pod ip&lt;/span>
$ kubectl get pod -o wide
NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES
backend 1/1 Running &lt;span class="m">0&lt;/span> 3m15s 172.17.0.7 cka &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
db1 1/1 Running &lt;span class="m">0&lt;/span> 4m8s 172.17.0.6 cka &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
db2 1/1 Running &lt;span class="m">0&lt;/span> 4m13s 172.17.0.3 cka &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
vault 1/1 Running &lt;span class="m">0&lt;/span> 4m21s 172.17.0.4 cka &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="集群kubelet-启动方式">集群：kubelet 启动方式&lt;/h2>
&lt;blockquote>
&lt;p>节点 &lt;code>cluster2-worker1&lt;/code> 已使用 kubeadm 和 TLS 引导添加到集群中。
找到 &lt;code>cluster2-worker1&lt;/code> 的 “Issuer” 和 “Extended Key Usage” 值：
kubelet 客户端证书，用于向外连接到 kube-apiserver 的证书。
kubelet 服务器证书，用于来自 kube-apiserver 的传入连接。
将信息写入文件 &lt;code>/opt/course/23/certificate-info.txt&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="知识点-24">知识点&lt;/h2>
&lt;ul>
&lt;li>kubelet 的功能：连接 api-server；接受来自 api-server 的响应。两种情况都需要 TLS&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-24">解题思路&lt;/h3>
&lt;p>kubelet 连接 apiserver 的方式在配置文件中，先找出配置文件的保存位置。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># ssh 到节点上，查看 kubelet 的启动命令&lt;/span>
$ ps -ef &lt;span class="p">|&lt;/span> grep kubelet
root &lt;span class="m">3935&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 12:54 ? 00:00:23 /var/lib/minikube/binaries/v1.20.0/kubelet --bootstrap-kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/bootstrap-kubelet.conf --cni-conf-dir&lt;span class="o">=&lt;/span>/etc/cni/net.mk --config&lt;span class="o">=&lt;/span>/var/lib/kubelet/config.yaml --container-runtime&lt;span class="o">=&lt;/span>docker --hostname-override&lt;span class="o">=&lt;/span>cka-m02 --kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/kubelet.conf --network-plugin&lt;span class="o">=&lt;/span>cni --node-ip&lt;span class="o">=&lt;/span>192.168.64.9
docker &lt;span class="m">13653&lt;/span> &lt;span class="m">13616&lt;/span> &lt;span class="m">0&lt;/span> 13:22 pts/0 00:00:00 grep kubelet
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#kubelet 连接 api server 的信息， client cert 的配置所在 /var/lib/kubelet/pki/kubelet-client-current.pem&lt;/span>
cat /var/lib/kubelet/config.yaml
&lt;span class="c1">#kubelet 的启动信息， servert cert 的配置所在 /var/lib/minikube/certs/ca.crt&lt;/span>
cat /etc/kubernetes/kubelet.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem &lt;span class="p">|&lt;/span> grep -i issuer
Issuer: &lt;span class="nv">CN&lt;/span> &lt;span class="o">=&lt;/span> minikubeCA
$ openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem &lt;span class="p">|&lt;/span> grep -i -A1 extended
X509v3 Extended Key Usage:
TLS Web Client Authentication
$ openssl x509 -noout -text -in /var/lib/minikube/certs/ca.crt &lt;span class="p">|&lt;/span> grep -i issuer
Issuer: &lt;span class="nv">CN&lt;/span> &lt;span class="o">=&lt;/span> minikubeCA
$ openssl x509 -noout -text -in /var/lib/minikube/certs/ca.crt &lt;span class="p">|&lt;/span> grep -i -A1 extended
X509v3 Extended Key Usage:
TLS Web Client Authentication, TLS Web Server Authentication
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后记得将信息写入到 &lt;code>/opt/course/23/certificate-info.txt&lt;/code>&lt;/p>
&lt;h2 id="集群证书">集群：证书&lt;/h2>
&lt;blockquote>
&lt;p>检查 kube-apiserver 服务器证书在 &lt;code>cluster2-master1&lt;/code> 上的有效期。使用 openssl 或 cfssl 执行此操作。将到期日期写入 &lt;code>/opt/course/22/expiration&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>同时运行正确的 kubeadm 命令以列出到期日期并确认两种方法显示相同的日期。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>将更新 apiserver 服务器证书的正确 kubeadm 命令写入 &lt;code>/opt/course/22/kubeadm-renew-certs.sh&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-25">知识点&lt;/h3>
&lt;ul>
&lt;li>api-server&lt;/li>
&lt;li>openssl&lt;/li>
&lt;li>kubeadm&lt;/li>
&lt;/ul>
&lt;p>参考文档：https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration&lt;/p>
&lt;h3 id="解题思路-25">解题思路&lt;/h3>
&lt;p>通过 kube-apiserver pod 的启动命令，或者 ssh 到 master 来查看命令参数，&lt;code>tls-cert-file=/var/lib/minikube/certs/apiserver.crt&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ openssl x509 -noout -text -in /var/lib/minikube/certs/apiserver.crt &lt;span class="p">|&lt;/span> grep -i valid -A2
Validity
Not Before: May &lt;span class="m">13&lt;/span> 22:33:43 &lt;span class="m">2021&lt;/span> GMT
Not After : May &lt;span class="m">14&lt;/span> 22:33:43 &lt;span class="m">2022&lt;/span> GMT
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 &lt;code>May 14 22:33:43 2022 GMT&lt;/code> 写入 &lt;code>/opt/course/22/expiration&lt;/code>&lt;/p>
&lt;p>通过 kubeadm 来检查&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ kubeadm certs check-expiration | grep -i apiserver
#macos 无法安装 kubeadm
#minikube 无法使用 kubeadm 检查
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 &lt;code>kubeadm certs renew apiserver&lt;/code> 写入 /opt/course/22/kubeadm-renew-certs.sh&lt;/p>
&lt;h2 id="集群升级节点">集群：升级节点&lt;/h2>
&lt;blockquote>
&lt;p>你的同事说节点 &lt;code>cluster3-worker2&lt;/code> 运行的是较旧的 Kubernetes 版本，甚至不属于集群的一部分。将 kubectl 和 kubeadm 更新为在 &lt;code>cluster3-master1&lt;/code> 上运行的确切版本。然后将此节点添加到集群中，您可以为此使用kubeadm。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-26">知识点&lt;/h3>
&lt;ul>
&lt;li>kubeadm 升级集群&lt;/li>
&lt;/ul>
&lt;p>参考文档：&lt;/p>
&lt;h3 id="解题思路-26">解题思路&lt;/h3>
&lt;p>检查node&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get nodes
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查当前组件版本&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ssh cluster3-worker2
$ kubeadm version
$ kubectl version --short
Client Version: vx.xx.x
Server Version: vx.xx.x
$ kubelet --version
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">#使用命令并升级各个组件，并重启 kubelet
#如果启动失败，一般是需要token连接到api-server，需要ssh到master上运行 kubeadm create token --print-join-command
#再ssh到 node上，执行打印的命令，重启kubelet并检查装填
#最后检查node是否成功加入集群
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-命令">Docker 命令&lt;/h2>
&lt;blockquote>
&lt;p>在命名空间 &lt;code>project-tiger&lt;/code> 中创建一个名为 &lt;code>Tigers-reunite&lt;/code> 的 Pod 镜像 &lt;code>httpd:2.4.41-alpine&lt;/code>，标签为 &lt;code>pod=container&lt;/code> 和 &lt;code>container=pod&lt;/code>。找出 Pod 被安排在哪个节点上。ssh 进入该节点并找到属于该 Pod 的 docker 容器。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>将容器的 docker ID 和这些正在运行的进程/命令写入 &lt;code>/opt/course/17/pod-container.txt&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>最后，使用 docker 命令将主 Docker 容器（来自 yaml 中指定的那个）的日志写入 &lt;code>/opt/course/17/pod-container.log&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="知识点-27">知识点&lt;/h3>
&lt;ul>
&lt;li>docker 命令：ps、logs、inspect&lt;/li>
&lt;/ul>
&lt;h3 id="解题思路-27">解题思路&lt;/h3>
&lt;p>创建 pod&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl run tigers-reunite --image httpd:2.4.41-alpine --labels &lt;span class="nv">pod&lt;/span>&lt;span class="o">=&lt;/span>container,container&lt;span class="o">=&lt;/span>pod
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查 pod 的信息&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pods --show-labels
NAME READY STATUS RESTARTS AGE LABELS
tigers-reunite 1/1 Running &lt;span class="m">0&lt;/span> 34s &lt;span class="nv">container&lt;/span>&lt;span class="o">=&lt;/span>pod,pod&lt;span class="o">=&lt;/span>container
&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取pod所在的节点&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod tigers-reunite -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.spec.nodeName}&amp;#39;&lt;/span>
cka
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ssh到节点上&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker ps &lt;span class="p">|&lt;/span> grep tigers-reunite
e6ff69b437bc 54b0995a6305 &lt;span class="s2">&amp;#34;httpd-foreground&amp;#34;&lt;/span> About a minute ago Up About a minute k8s_tigers-reunite_tigers-reunite_dev_53391212-911d-4275-a19d-e8f8b0f85a98_0
06d3ca65eb08 k8s.gcr.io/pause:3.2 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> About a minute ago Up About a minute k8s_POD_tigers-reunite_dev_53391212-911d-4275-a19d-e8f8b0f85a98_0
&lt;span class="c1">#使用docker inspect 或者 进入容器直接查看进程&lt;/span>
$ docker inspect e6ff69b437bc &lt;span class="p">|&lt;/span> grep -i &lt;span class="s1">&amp;#39;cmd\|entrypoint&amp;#39;&lt;/span> -A1
&lt;span class="s2">&amp;#34;Cmd&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;httpd-foreground&amp;#34;&lt;/span>
--
&lt;span class="s2">&amp;#34;Entrypoint&amp;#34;&lt;/span>: null,
&lt;span class="s2">&amp;#34;OnBuild&amp;#34;&lt;/span>: null,
$ docker inspect 06d3ca65eb08 &lt;span class="p">|&lt;/span> grep -i &lt;span class="s1">&amp;#39;cmd\|entrypoint&amp;#39;&lt;/span> -A1
&lt;span class="s2">&amp;#34;Cmd&amp;#34;&lt;/span>: null,
&lt;span class="s2">&amp;#34;Image&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;k8s.gcr.io/pause:3.2&amp;#34;&lt;/span>,
--
&lt;span class="s2">&amp;#34;Entrypoint&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果写入文件&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">e6ff69b437bc httpd-foreground
06d3ca65eb08 pause
&lt;/code>&lt;/pre>&lt;/div>&lt;p>写日志到文件&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="l">docker logs e6ff69b437bc &amp;gt; /opt/course/17/pod-container.log&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>常用的几款工具让 Kubernetes 集群上的工作更容易</title><link>https://atbug.com/tools-accelerate-work-on-kubernetes-cluster/</link><pubDate>Sat, 26 Jun 2021 12:16:28 +0800</pubDate><guid>https://atbug.com/tools-accelerate-work-on-kubernetes-cluster/</guid><description>
&lt;p>之前写过一篇 &lt;a href="https://mp.weixin.qq.com/s/CXJ1zUoktdI3c3CHVju0gA">介绍了工具加速云原生 Java 开发&lt;/a>。&lt;/p>
&lt;p>其实日常工作中在集群上的操作也非常多，今天就来介绍我所使用的工具。&lt;/p>
&lt;h2 id="kubectl-alias">kubectl-alias&lt;/h2>
&lt;p>使用频率最高的工具，我自己稍微修改了一下，加入了 &lt;code>StatefulSet&lt;/code> 的支持。&lt;/p>
&lt;p>这个是我的 &lt;a href="https://github.com/addozhang/kubectl-aliases">https://github.com/addozhang/kubectl-aliases&lt;/a>，基于 &lt;a href="https://github.com/ahmetb/kubectl-aliases">https://github.com/ahmetb/kubectl-aliases&lt;/a>。&lt;/p>
&lt;p>比如输出某个 pod 的 json，&lt;code>kgpoojson xxx&lt;/code> 等同于 &lt;code>kubectl get pod xxx -o json&lt;/code>。&lt;/p>
&lt;p>结合 &lt;a href="https://stedolan.github.io/jq/">jq&lt;/a> 使用效果更好 😂。&lt;/p>
&lt;h3 id="语法解读">语法解读&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&lt;code>k&lt;/code>&lt;/strong>=&lt;code>kubectl&lt;/code>
&lt;ul>
&lt;li>&lt;strong>&lt;code>sys&lt;/code>&lt;/strong>=&lt;code>--namespace kube-system&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>commands:
&lt;ul>
&lt;li>&lt;strong>&lt;code>g&lt;/code>&lt;/strong>=&lt;code>get&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>d&lt;/code>&lt;/strong>=&lt;code>describe&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>rm&lt;/code>&lt;/strong>=&lt;code>delete&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>a&lt;/code>&lt;/strong>:&lt;code>apply -f&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>ak&lt;/code>&lt;/strong>:&lt;code>apply -k&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>k&lt;/code>&lt;/strong>:&lt;code>kustomize&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>ex&lt;/code>&lt;/strong>: &lt;code>exec -i -t&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>lo&lt;/code>&lt;/strong>: &lt;code>logs -f&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>resources:
&lt;ul>
&lt;li>&lt;strong>&lt;code>po&lt;/code>&lt;/strong>=pod, &lt;strong>&lt;code>dep&lt;/code>&lt;/strong>=&lt;code>deployment&lt;/code>, &lt;strong>&lt;code>ing&lt;/code>&lt;/strong>=&lt;code>ingress&lt;/code>, &lt;strong>&lt;code>svc&lt;/code>&lt;/strong>=&lt;code>service&lt;/code>, &lt;strong>&lt;code>cm&lt;/code>&lt;/strong>=&lt;code>configmap&lt;/code>, &lt;strong>&lt;code>sec&lt;/code>=&lt;code>secret&lt;/code>&lt;/strong>,&lt;strong>&lt;code>ns&lt;/code>&lt;/strong>=&lt;code>namespace&lt;/code>, &lt;strong>&lt;code>no&lt;/code>&lt;/strong>=&lt;code>node&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>flags:
&lt;ul>
&lt;li>output format: &lt;strong>&lt;code>oyaml&lt;/code>&lt;/strong>, &lt;strong>&lt;code>ojson&lt;/code>&lt;/strong>, &lt;strong>&lt;code>owide&lt;/code>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;code>all&lt;/code>&lt;/strong>: &lt;code>--all&lt;/code> or &lt;code>--all-namespaces&lt;/code> depending on the command&lt;/li>
&lt;li>&lt;strong>&lt;code>sl&lt;/code>&lt;/strong>: &lt;code>--show-labels&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>w&lt;/code>&lt;/strong>=&lt;code>-w/--watch&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>value flags (should be at the end):
&lt;ul>
&lt;li>&lt;strong>&lt;code>n&lt;/code>&lt;/strong>=&lt;code>-n/--namespace&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>f&lt;/code>&lt;/strong>=&lt;code>-f/--filename&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>l&lt;/code>&lt;/strong>=&lt;code>-l/--selector&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="kubectx--kubens">kubectx + kubens&lt;/h2>
&lt;p>&lt;a href="https://github.com/ahmetb/kubectx#installation">安装看这里&lt;/a>&lt;/p>
&lt;p>&lt;code>kubectx&lt;/code> 用于在不同的集群间进行快速切换。假如用 &lt;code>kubectl&lt;/code>，你需要：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># context 列表&lt;/span>
kubectl config current-context
&lt;span class="c1"># 设置 context&lt;/span>
kubectl config use-context coffee
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/kubectxdemo.gif" alt="kubectx-demo">&lt;/p>
&lt;p>&lt;code>kubens&lt;/code> 就是在不同 namespace 间快速切换的工具。用 &lt;code>kubectl&lt;/code> 的话，需要：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># namespace 列表&lt;/span>
kbuectl get ns
&lt;span class="c1"># kubectl config set-context --current --namespace=kube-system&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/kubensdemo.gif" alt="kubens-demo">&lt;/p>
&lt;h2 id="k9s">k9s&lt;/h2>
&lt;p>没错，只比 k8s 多了个 1 😂。&lt;/p>
&lt;p>&lt;a href="https://github.com/derailed/k9s">k9s&lt;/a> 提供了终端 UI 与 Kubernetes 集群进行编辑交互。本人常用的比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>F&lt;/code> 配置端口转发&lt;/li>
&lt;li>&lt;code>l&lt;/code> 输出 pod 日志&lt;/li>
&lt;li>&lt;code>e&lt;/code> 修改资源对象&lt;/li>
&lt;li>&lt;code>s&lt;/code> pod 终端交互模式&lt;/li>
&lt;li>&lt;code>y&lt;/code> yaml 方式输出资源对象&lt;/li>
&lt;li>&lt;code>d&lt;/code> describe 资源对象&lt;/li>
&lt;li>&lt;code>ctrl+d&lt;/code> 删除 pod&lt;/li>
&lt;/ul>
&lt;p>启动方式&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># 指定 namespace 运行&lt;/span>
k9s -n mycoolns
&lt;span class="c1"># 指定 context 运行&lt;/span>
k9s --context coolCtx
&lt;span class="c1"># 只读模式运行&lt;/span>
k9s --readonly
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/20210626102731.png" alt="k9s-pod">&lt;/p>
&lt;p>键入问号“?” 就可以打开快捷操作指引。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/20210626103012.png" alt="help">&lt;/p>
&lt;h2 id="stern">stern&lt;/h2>
&lt;p>&lt;a href="https://github.com/wercker/stern">stern&lt;/a> 可以用来 &lt;code>tail&lt;/code> 集群上的多个 pod 和 pod 中多个容器的日志。不同的 pod 和容器以不同的颜色区分，方便 debug。&lt;/p>
&lt;p>比如使用命令 &lt;code>stern -l tier=control-plane -n kube-system&lt;/code> 可以输出 &lt;code>kube-system&lt;/code> 命名空间下控制平面（&lt;code>label&lt;/code> 为 &lt;code>tier=control-plane&lt;/code>） pod 的日志。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/20210626104458.png" alt="stern-control-plane">&lt;/p>
&lt;p>命令行选项&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">Tail multiple pods and containers from Kubernetes
Usage:
stern pod-query &lt;span class="o">[&lt;/span>flags&lt;span class="o">]&lt;/span>
Flags:
-A, --all-namespaces If present, tail across all namespaces. A specific namespace is ignored even &lt;span class="k">if&lt;/span> specified with --namespace.
--color string Color output. Can be &lt;span class="s1">&amp;#39;always&amp;#39;&lt;/span>, &lt;span class="s1">&amp;#39;never&amp;#39;&lt;/span>, or &lt;span class="s1">&amp;#39;auto&amp;#39;&lt;/span> &lt;span class="o">(&lt;/span>default &lt;span class="s2">&amp;#34;auto&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
--completion string Outputs stern command-line completion code &lt;span class="k">for&lt;/span> the specified shell. Can be &lt;span class="s1">&amp;#39;bash&amp;#39;&lt;/span> or &lt;span class="s1">&amp;#39;zsh&amp;#39;&lt;/span>
-c, --container string Container name when multiple containers in pod &lt;span class="o">(&lt;/span>default &lt;span class="s2">&amp;#34;.*&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
--container-state string If present, tail containers with status in running, waiting or terminated. Default to running. &lt;span class="o">(&lt;/span>default &lt;span class="s2">&amp;#34;running&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
--context string Kubernetes context to use. Default to current context configured in kubeconfig.
-e, --exclude strings Regex of log lines to exclude
-E, --exclude-container string Exclude a Container name
--field-selector string Selector &lt;span class="o">(&lt;/span>field query&lt;span class="o">)&lt;/span> to filter on. If present, default to &lt;span class="s2">&amp;#34;.*&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> the pod-query.
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> stern
-i, --include strings Regex of log lines to include
--init-containers Include or exclude init containers &lt;span class="o">(&lt;/span>default &lt;span class="nb">true&lt;/span>&lt;span class="o">)&lt;/span>
--kubeconfig string Path to kubeconfig file to use
-n, --namespace strings Kubernetes namespace to use. Default to namespace configured in Kubernetes context. To specify multiple namespaces, repeat this or &lt;span class="nb">set&lt;/span> comma-separated value.
-o, --output string Specify predefined template. Currently support: &lt;span class="o">[&lt;/span>default, raw, json&lt;span class="o">]&lt;/span> &lt;span class="o">(&lt;/span>default &lt;span class="s2">&amp;#34;default&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
-l, --selector string Selector &lt;span class="o">(&lt;/span>label query&lt;span class="o">)&lt;/span> to filter on. If present, default to &lt;span class="s2">&amp;#34;.*&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> the pod-query.
-s, --since duration Return logs newer than a relative duration like 5s, 2m, or 3h. Defaults to 48h.
--tail int The number of lines from the end of the logs to show. Defaults to -1, showing all logs. &lt;span class="o">(&lt;/span>default -1&lt;span class="o">)&lt;/span>
--template string Template to use &lt;span class="k">for&lt;/span> log lines, leave empty to use --output flag
-t, --timestamps Print timestamps
--timezone string Set timestamps to specific timezone &lt;span class="o">(&lt;/span>default &lt;span class="s2">&amp;#34;Local&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
-v, --version Print the version and &lt;span class="nb">exit&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="lens">Lens&lt;/h2>
&lt;p>&lt;a href="https://k8slens.dev/">Lens&lt;/a> 是用来控制 Kubernetes 的 IDE，开源且免费。&lt;/p>
&lt;p>消除了集群操作的复杂性、提供了实时的可观察性、方便故障排查、支持多系统的桌面客户端、兼容多种集群。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/20210626113853.png" alt="Lens">&lt;/p>
&lt;h2 id="infra-app">Infra App&lt;/h2>
&lt;p>&lt;a href="https://infra.app/">Infra App&lt;/a> 跟 Lens 差不多，UI 较 Lens 好些，但是功能就弱很多，类似 Lens 的只读模式。&lt;/p>
&lt;p>免费版比收费版的区别只在于支持的集群数量，免费版只支持一个集群。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/20210626114417.png" alt="Infra">&lt;/p>
&lt;h2 id="kubefwd">kubefwd&lt;/h2>
&lt;p>&lt;a href="https://github.com/txn2/kubefwd">kubefwd&lt;/a>，这个一直有安装但是使用次数寥寥，因为应用之间的访问没有走 service，不过偶尔做些实验的时候会用的上。&lt;/p>
&lt;blockquote>
&lt;p>kubefwd 是一个用于端口转发Kubernetes中指定namespace下的全部或者部分pod的命令行工具。 kubefwd 使用本地的环回IP地址转发需要访问的service，并且使用与service相同的端口。 kubefwd 会临时将service的域条目添加到 /etc/hosts 文件中。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>启动kubefwd后，在本地就能像在Kubernetes集群中一样使用service名字与端口访问对应的应用程序。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/kubefwdani.gif" alt="kubefwd_ani">&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/26/16246803227515.jpg" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>善用工具可以提升效率，但并不是不可或缺的。&lt;/p>
&lt;p>如果你有其他的工具，欢迎留言提出。&lt;/p></description></item><item><title>Jenkins 如何与 Kubernetes 集群的 Tekton Pipeline 交互？</title><link>https://atbug.com/jenkins-interact-with-tekton-pipelines-via-plugin/</link><pubDate>Wed, 23 Jun 2021 07:58:45 +0800</pubDate><guid>https://atbug.com/jenkins-interact-with-tekton-pipelines-via-plugin/</guid><description>
&lt;p>本文详细介绍了 Jenkins 如何通过 &lt;a href="https://github.com/jenkinsci/tekton-client-plugin">tekton-client-plugin&lt;/a> 实现与 Kubernetes 上的 Tekton Pipeline 交互，包括 Kubernetes 上安装 Jenkins、Tekton Pipelines 等。&lt;/p>
&lt;p>关于如何使用 Tekton Pipeline 实现 CICD 可以看这篇文章 &lt;a href="https://atbug.com/tekton-pipeline-practice/">云原生 CICD: Tekton Pipeline 实战&lt;/a>&lt;/p>
&lt;p>本文用于构建的项目以及所有 manifest yaml 都在可以在&lt;a href="https://github.com/addozhang/tekton-test">这里&lt;/a>下载。&lt;/p>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>惯例，先上总结。&lt;code>tekton-client-plugin&lt;/code> 虽然还是处于初期阶段，但是 &lt;em>其价值非常明显，尤其是对先用使用 Jenkins 作为 CICD 实现的用户来说。从 Jenkins 迁移到云原生的 Tekton 时，可以省掉用户界面的开发成本，而且尽可能少的改变用户习惯&lt;/em> ，依靠版本管理可以控制迁移的节奏。&lt;/p>
&lt;p>&lt;code>tekton-client-plugin&lt;/code> 在今年 5 月 7 日发布的 &lt;code>1.0.0&lt;/code> 版本，目前为 &lt;code>1.0.02&lt;/code>。目前还处于初期阶段，我个人感觉目前仅仅算是打通 Jenkins 与 Tekton 交互这条路，扩展性还不够好。&lt;/p>
&lt;p>比如目前仅仅支持如下几个参数注入到 &lt;code>PipelineRun&lt;/code> 中，难以支撑复杂的流程控制，&lt;a href="https://github.com/jenkinsci/tekton-client-plugin/blob/1.0.2/src/main/java/org/waveywaves/jenkins/plugins/tekton/client/build/create/CreateRaw.java#L292">支持的 Pipeline 参数 hardcode 在代码中&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>BUILD_ID - the build id/number of the Jenkins job&lt;/li>
&lt;li>JOB_NAME - the name of the jenkins job that triggered this pipeline&lt;/li>
&lt;li>PULL_BASE_REF - name of the base branch&lt;/li>
&lt;li>PULL_PULL_SHA - the commit sha of the pull request or branch&lt;/li>
&lt;li>REPO_NAME - name of the repository&lt;/li>
&lt;li>REPO_OWNER - owner of the repository&lt;/li>
&lt;li>REPO_URL - the URL of the repository&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>希望后面会支持自定义参数，比如将更多的项目元数据信息注册到 &lt;code>Pipeline&lt;/code> 中。&lt;/p>
&lt;p>值得一提的是，&lt;code>tekton-client-plugin&lt;/code> 提供了对 Job DSL 的支持，本文后面没有用这种方式，而是用的 FreeStyle Project。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">pipeline {
agent any
stages {
stage(&amp;#39;Stage&amp;#39;) {
steps {
checkout scm
tektonCreateRaw(inputType: &amp;#39;FILE&amp;#39;, input: &amp;#39;.tekton/pipeline.yaml&amp;#39;)
}
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="前置条件">前置条件&lt;/h2>
&lt;h3 id="环境">环境&lt;/h3>
&lt;ul>
&lt;li>Kubernetes：推荐 minikube&lt;/li>
&lt;li>Jenkins：建议在 Kubernetes 上安装&lt;/li>
&lt;li>Tekton&lt;/li>
&lt;li>用于构建的项目&lt;/li>
&lt;/ul>
&lt;h3 id="工具">工具&lt;/h3>
&lt;ul>
&lt;li>kubectl&lt;/li>
&lt;li>tektoncd-cli&lt;/li>
&lt;li>&lt;a href="https://github.com/ahmetb/kubectx">kubectx、kubens&lt;/a>&lt;/li>
&lt;li>helm&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes-上安装-jenkinshelm">Kubernetes 上安装 Jenkins（Helm）&lt;/h2>
&lt;p>Jenkins 这里使用 Helm 安装到 Kubernetes 上。&lt;/p>
&lt;p>初始化命名空间、持久化卷、ServiceAccount 等。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create namespace jenkins
kubens jenkins
&lt;span class="c1"># 持久化存储，笔者将容量修改为 5G&lt;/span>
http https://raw.githubusercontent.com/jenkins-infra/jenkins.io/master/content/doc/tutorials/kubernetes/installing-jenkins-on-kubernetes/jenkins-volume.yaml --body &amp;gt; jenkins-volume.yaml
&lt;span class="c1"># 创建 PV&lt;/span>
kubectl apply -f jenkins-volume.yaml
&lt;span class="c1"># 创建 service account&lt;/span>
kubectl apply -f https://raw.githubusercontent.com/jenkins-infra/jenkins.io/master/content/doc/tutorials/kubernetes/installing-jenkins-on-kubernetes/jenkins-sa.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="准备-helm-环境并添加-jenkins-chartrepo">准备 helm 环境并添加 Jenkins ChartRepo&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># homebrew 安装 helm&lt;/span>
brew install helm
&lt;span class="c1"># 添加 jenkins chart repo&lt;/span>
helm repo add jenkinsci https://charts.jenkins.io
helm repo update
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-jenkins-chart">配置 Jenkins Chart&lt;/h3>
&lt;ol>
&lt;li>下载官方的 values yaml进行修改：&lt;code>http https://raw.githubusercontent.com/jenkinsci/helm-charts/main/charts/jenkins/values.yaml &amp;gt; jenkins-values.yaml&lt;/code>&lt;/li>
&lt;li>修改 &lt;code>serviceType&lt;/code> 为 &lt;code>NodePort&lt;/code>，并增加 &lt;code>nodePort: 32000&lt;/code>。用于从 minikube 外访问 Jenkins&lt;/li>
&lt;li>修改 &lt;code>storageClass&lt;/code> 为 &lt;code>jenkins-pv&lt;/code>。前面创建 PV 的时候使用了 &lt;code>jenkins-pv&lt;/code> 作为 &lt;a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/">Dynamic Volume Provisioning&lt;/a> 的 &lt;code>storageClass&lt;/code>&lt;/li>
&lt;li>修改 &lt;code>serviceAccount&lt;/code> 部分，将 &lt;code>create&lt;/code> 设置为 &lt;code>false&lt;/code>（上面已经创建了 &lt;code>serviceAccount&lt;/code>），同时将 &lt;code>name&lt;/code> 指定为前面的 sa 名字 &lt;code>jenkins&lt;/code>&lt;/li>
&lt;li>&lt;code>installPlugins&lt;/code> 下增加 &lt;code>tekton-client:1.0.2&lt;/code>&lt;/li>
&lt;li>修改 &lt;code>adminPassword&lt;/code> 为 &lt;code>admin&lt;/code>。指定初始密码（不指定也可以通过安装输出的说明获取初始密码）&lt;/li>
&lt;li>修改 &lt;code>persistence&lt;/code> 的 &lt;code>size&lt;/code> 为 &lt;code>5Gi&lt;/code> （我的 minikube 的虚拟机只有 20Gi 大小）&lt;/li>
&lt;/ol>
&lt;p>修改后的文件在&lt;a href="https://github.com/addozhang/tekton-test/blob/main/tekton-client-sample/jenkins-values.yaml">这里 jenkins-values.yaml&lt;/a>。&lt;/p>
&lt;h3 id="执行安装">执行安装&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nv">chart&lt;/span>&lt;span class="o">=&lt;/span>jenkinsci/jenkins
helm install jenkins -n jenkins -f jenkins-values.yaml &lt;span class="nv">$chart&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME: jenkins
LAST DEPLOYED: Sun Jun 20 22:05:53 2021
NAMESPACE: jenkins
STATUS: deployed
REVISION: 1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取 Jenkins 的访问地址 &lt;code>echo $(minikube ip):$(kubectl get svc jenkins -o jsonpath=&amp;quot;{.spec.ports[0].nodePort}&amp;quot;)&lt;/code>，然后使用前面设置的账号登录。&lt;/p>
&lt;h2 id="tekton-安装">Tekton 安装&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create ns tekton-pipelines
kubens tekton-pipelines
kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-cli">安装 CLI&lt;/h3>
&lt;p>&lt;code>brew install tektoncd-cli&lt;/code>&lt;/p>
&lt;h3 id="rbac">RBAC&lt;/h3>
&lt;p>Tekton Pipeline 安装完成后，需要给前面创建的 ServiceAccount &lt;code>jenkins&lt;/code> 增加 tekon 资源的操作权限。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="l">//tekton-role.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Role&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-role&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-pipelines&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pods&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pods/log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">get&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">list&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">watch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">tekton.dev&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">tasks&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">taskruns&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pipelines&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pipelineruns&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">create&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">delete&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">deletecollection&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">get&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">list&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">patch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">update&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">watch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-role-binding&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-pipelines&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Role&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-role&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">jenkins&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">jenkins&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="jenkins-与-tekton-交互">Jenkins 与 Tekton 交互&lt;/h2>
&lt;p>前面大篇幅的都只是准备工作，Jenkins 安装时我们已经添加了 &lt;code>tekton-client-plugin&lt;/code> 插件。&lt;/p>
&lt;p>添加一个名为 &lt;code>tekton-client-sample&lt;/code> 的 &lt;code>FreeStyle project&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/22/20210622-151450.png" alt="创建作业">&lt;/p>
&lt;p>SCM 这里填入用于构建的项目仓库地址以及分支。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/22/20210622-151523.png" alt="配置代码仓库">&lt;/p>
&lt;p>Build 模块中选择 &lt;code>Tekton: Create Resource (RAW)&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/22/20210622-151544.png" alt="增加 Tekton step">&lt;/p>
&lt;p>这里选择 &lt;code>FILE&lt;/code> 类型，因为我已经将 &lt;code>PipelineRun&lt;/code> 的 yaml 放进了代码仓库中了。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/22/20210622151734.png" alt="配置 Resource">&lt;/p>
&lt;p>执行一次构建&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/22/20210622153535.png" alt="构建结束">&lt;/p>
&lt;p>检查下应用&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ kubectl get pod &lt;span class="p">|&lt;/span> grep tekton-test
tekton-test-75975dcc88-xkzb6 1/1 Running &lt;span class="m">0&lt;/span> 3m13s
tekton-test-c26lw-deploy-to-k8s-28trp-pod-w8tgc 0/1 Completed &lt;span class="m">0&lt;/span> 3m18s
tekton-test-c26lw-fetch-from-git-pv66g-pod-nm5qh 0/1 Completed &lt;span class="m">0&lt;/span> 6m30s
tekton-test-c26lw-source-to-image-k8mpg-pod-qh7g4 0/2 Completed &lt;span class="m">0&lt;/span> 6m15s
$ curl &lt;span class="k">$(&lt;/span>minikube ip&lt;span class="k">)&lt;/span>:&lt;span class="k">$(&lt;/span>kubectl get svc tekton-test -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>/hi
hello world
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.jenkins.io/doc/book/installing/kubernetes/">Jenkins on Kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/jenkinsci/tekton-client-plugin/blob/master/docs/tutorial.md">Tekton Client Plugin Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/blog/2021/04/21/tekton-plugin/#easily-reuse-tekton-and-jenkins-x-from-jenkins">Easily reuse Tekton and Jenkins X from Jenkins&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>云原生 CICD: Tekton Pipeline 实战</title><link>https://atbug.com/tekton-pipeline-practice/</link><pubDate>Tue, 22 Jun 2021 07:19:33 +0800</pubDate><guid>https://atbug.com/tekton-pipeline-practice/</guid><description>
&lt;p>更新历史：&lt;/p>
&lt;ul>
&lt;li>v1：2020.1.21 基于 Tekton Pipline &lt;a href="https://github.com/tektoncd/pipeline/tree/v0.9.0/docs#tekton-pipelines">v0.9.0&lt;/a>&lt;/li>
&lt;li>v2（当前）：2021.6.22 基于 Tekton Pipeline &lt;a href="https://github.com/tektoncd/pipeline/tree/v0.25.0/docs#tekton-pipelines">v0.25.0&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>Tekton 是 Google 开源的 Kubernetes 原生CI/CD 系统, 功能强大扩展性强. 前身是 Knavite 里的 build-pipeline 项目, 后期孵化成&lt;a href="https://github.com/tektoncd/pipeline">独立的项目&lt;/a>. 并成为 &lt;a href="https://cd.foundation/projects/">CDF&lt;/a> 下的四个项目之一, 其他三个分别是 Jenkins, Jenkins X, Spinnaker.&lt;/p>
&lt;p>为什么说 Tekton 是 Kubernetes 原生的, 以内其基于 Kubernetes 的 CRD 定义了 Pipeline 流水线.&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/bquuTV.jpg" alt="">&lt;/p>
&lt;p>CRD 及说明:&lt;/p>
&lt;ul>
&lt;li>Task: 构建任务, 可以定义一些列的 steps. 每个 step 由一个 container 执行.&lt;/li>
&lt;li>TaskRun: task 实际的执行, 并提供执行所需的参数. 这个对象创建后, 就会有 pod 被创建.&lt;/li>
&lt;li>Pipeline: 定义一个或者多个 task 的执行, 以及 PipelineResource 和各种定义参数的集合&lt;/li>
&lt;li>PipelineRun: 类似 task 和 taskrun 的关系: 一个定义一个执行. PipelineRun 则是 pipeline 的实际执行. 创建后也会创建 pod 来执行各个 task.&lt;/li>
&lt;li>&lt;del>PipelineResource: 流水线的输入资源, 比如 github/gitlab 的源码, 某种存储服务的文件, 或者镜像等. 执行时, 也会作为 pod 的其中一个 container 来运行(比如拉取代码).&lt;/del> PipelineResource 目前处于 Alaha，至于原因可以看&lt;a href="https://github.com/tektoncd/pipeline/blob/v0.25.0/docs/resources.md#why-arent-pipelineresources-in-beta">Why Aren&amp;rsquo;t PipelineResources in Beta?&lt;/a>&lt;/li>
&lt;li>Condition: 在 pipeline 的 task 执行时通过添加 condition 来对条件进行评估, 进而判断是否执行 task. 目前是WIP的状态, 待&lt;a href="https://github.com/tektoncd/pipeline/issues/1137">#1137&lt;/a>的完成.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>组件:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>tekton-pipelines-controller&lt;/code>: 监控 CRD 对象(TaskRun, PipelineRun)的创建, 为该次执行创建 pod.&lt;/li>
&lt;li>&lt;code>tekton-pipelines-webhook&lt;/code>: 对 apiserver 提供 http 接口做 CRD 对象的校验.&lt;/li>
&lt;/ul>
&lt;h2 id="前置条件">前置条件&lt;/h2>
&lt;p>文中使用的一些工具，基本都可以通过 homebrew 安装：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stedolan.github.io/jq/">jq&lt;/a> ：操作 json 的命令行工具&lt;/li>
&lt;li>&lt;a href="https://httpie.io/">httpie&lt;/a>：HTTP 客户端命令行工具&lt;/li>
&lt;li>&lt;a href="https://minikube.sigs.k8s.io/docs/start/">minikube 环境&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>文中的 Java 项目以及 tekton 的相关 yaml 都已经提交到了 &lt;a href="https://github.com/addozhang/tekton-test">tekton-test&lt;/a>.&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>参考&lt;a href="https://atbug.com/tekton-installation-and-sample/">上一篇文章&lt;/a>, 文章中有个简单的&amp;quot;hello world&amp;quot;.&lt;/p>
&lt;h2 id="实践">实践&lt;/h2>
&lt;p>到了这里相信已经安装好了 Tekton. 我们使用&lt;a href="https://start.spring.io/">Spring Initializer&lt;/a>生成的项目为例, 演示如何使用 Tekton 实现 CICD.&lt;/p>
&lt;p>开始之前简单整理下这个项目的 CICD 流程:&lt;/p>
&lt;ol>
&lt;li>拉取代码&lt;/li>
&lt;li>maven 打包&lt;/li>
&lt;li>构建镜像并推送&lt;/li>
&lt;li>部署&lt;/li>
&lt;/ol>
&lt;p>&lt;em>注: 所有的操作都是在 &lt;code>tekton-pipelines&lt;/code> namespace 下操作&lt;/em>&lt;/p>
&lt;h3 id="0x00-添加-dockerfile-和部署用的-yaml">0x00 添加 Dockerfile 和部署用的 yaml&lt;/h3>
&lt;p>用于构建镜像的Dockerfile&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">FROM openjdk:8-jdk-alpine
RUN mkdir /app
WORKDIR /app
COPY target/*.jar /app/app.jar
ENTRYPOINT [&amp;#34;sh&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;java -Xmx128m -Xms64m -jar app.jar&amp;#34;]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>用于部署 K8s Deployment 的 deployment.yml，同时通过创建 &lt;code>NodePort&lt;/code> 类型的 Service 用于访问应用。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;apps/v1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Deployment&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;tekton-test&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;tekton-test&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;tekton-test&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;tekton-test&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;addozhang/tekton-test:latest&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Always&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">livenessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">failureThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">httpGet&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/actuator/info&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scheme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;HTTP&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">initialDelaySeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">60&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">periodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">successThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">timeoutSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;tekton-test&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;http&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;TCP&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">readinessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">failureThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">httpGet&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/actuator/info&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scheme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;HTTP&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">initialDelaySeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">periodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">successThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">timeoutSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NodePort &lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0x01-rbac">0x01 RBAC&lt;/h3>
&lt;p>创建 ServiceAccount 用于 Pipeline 的运行。&lt;/p>
&lt;p>&lt;strong>注：这里为了方便，授予了 &lt;code>ClusterRole&lt;/code> &lt;code>admin&lt;/code>。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="c"># serviceaccount.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pipeline-admin-binding&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admin&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># user cluster role admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-pipelines&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0x02-拉取代码">0x02 拉取代码&lt;/h3>
&lt;p>代码作为构建的输入, 需要提供一个 Pipeline CRD 对象来表示输入是从 git 仓库来获取代码。&lt;/p>
&lt;p>访问 Tekton Hub 可以找到现成的 &lt;a href="https://hub.tekton.dev/tekton/task/git-clone">git-clone task&lt;/a>。&lt;/p>
&lt;p>使用 kubectl 安装：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/main/task/git-clone/0.4/git-clone.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者使用 tekton-cli 安装：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">tkn hub install task git-clone
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0x03-maven-打包">0x03 maven 打包&lt;/h3>
&lt;p>Task &lt;code>source-to-image.yaml&lt;/code>的 step &lt;code>maven&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maven&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maven:3.5.0-jdk-8-alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workingDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">$(workspaces.source.path)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">mvn&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">clean&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">install&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">DskipTests&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">m2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/root/.m2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">m2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/home/docker/.m2 &lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明:&lt;/strong>&lt;/p>
&lt;p>有了代码下一步就是执行 maven 的编译打包, 在&lt;code>maven:3.5.0-jdk-8-alpine&lt;/code>镜像中执行&lt;code>mvn&lt;/code>的相关命令.&lt;/p>
&lt;p>这里挂在了一个本地的volume, 避免每次构建重复下载依赖包, 同时里面还有&lt;code> settings.xml&lt;/code>&lt;/p>
&lt;p>&lt;em>注意: 对于 minikube, hostPath 请使用/data/.m2, 否则minikube重启后无法持久化&lt;/em>&lt;/p>
&lt;h3 id="0x04-构建镜像并推送">0x04 构建镜像并推送&lt;/h3>
&lt;p>Task &lt;code>source-to-image.yaml&lt;/code> 的 step &lt;code>build-and-push&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">spec:
params:
- name: pathToDockerFile
description: The path to the dockerfile to build (relative to the context)
default: Dockerfile
- name: imageUrl
description: Url of image repository
- name: imageTag
description: Tag to apply to the built image
default: latest
workspaces:
- name: source
- name: dockerconfig
mountPath: /kaniko/.docker # config.json 的挂载目录
steps:
- name: build-and-push
image: gcr.io/kaniko-project/executor:v1.6.0-debug
command:
- /kaniko/executor
args:
- --dockerfile=$(params.pathToDockerFile)
- --destination=$(params.imageUrl):$(params.imageTag)
- --context=$(workspaces.source.path)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明:&lt;/strong>&lt;/p>
&lt;p>镜像的构建, 我们采用了 kaniko。&lt;/p>
&lt;p>镜像仓库我们选择了Docker Hub, 推送的时候需要使用 credentials。&lt;/p>
&lt;p>kaniko 需要将 docker config 的文件存在于 &lt;code>/kanika/.docker&lt;/code> 目录下。这里的思路是将 docker 的 &lt;code>config.json&lt;/code>，以 &lt;code>secret&lt;/code> 的方式持久化，在通过先添加&lt;code> docker-registry&lt;/code>类型的 &lt;code>secret&lt;/code>，然后通过 &lt;code>workspace&lt;/code> 的方式输入到 kaniko 运行环境中。&lt;/p>
&lt;p>&lt;code>config.json&lt;/code> 里面保存的 json 结构化的数据，为了方便通过 dry run 创建&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create secret docker-registry dockerhub --docker-server&lt;span class="o">=&lt;/span>https://index.docker.io/v1/ --docker-username&lt;span class="o">=[&lt;/span>USERNAME&lt;span class="o">]&lt;/span> --docker-password&lt;span class="o">=[&lt;/span>PASSWORD&lt;span class="o">]&lt;/span> --dry-run&lt;span class="o">=&lt;/span>client -o json &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.data.&amp;#34;.dockerconfigjson&amp;#34;&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> base64 -d &amp;gt; /tmp/config.json &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> kubectl create secret generic docker-config --from-file&lt;span class="o">=&lt;/span>/tmp/config.json &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> rm -f /tmp/config.json
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>执行:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f tasks/source-to-image.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0x05-部署">0x05 部署&lt;/h3>
&lt;p>deploy-to-k8s.yaml:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton.dev/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Task&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-to-k8s&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">inputs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pathToYamlFile&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">The path to the yaml file to deploy within the git source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deployment.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">run-kubectl&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">lachlanevenson/k8s-kubectl&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;kubectl&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;apply&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;-f&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;/workspace/git-source/$(inputs.params.pathToYamlFile)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>pathToYamlFile: 指定部署应用的 yaml。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>执行:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f tasks/deploy-to-k8s.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0x06-组装流水线">0x06 组装流水线&lt;/h3>
&lt;p>&lt;code>build-pipeline.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton.dev/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pipeline&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">build-pipeline&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-url&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-revision&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pathToContext&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">The path to the build context, used by Kaniko - within the workspace&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">imageUrl&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Url of image repository&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">imageTag&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Tag to apply to the built image&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tasks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fetch-from-git&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">taskRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-clone&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">url&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;$(params.git-url)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">revision&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;$(params.git-revision)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">output&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">source-to-image&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">taskRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">source-to-image&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">imageUrl&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;$(params.imageUrl)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">imageTag&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;$(params.imageTag)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dockerconfig&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runAfter&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">fetch-from-git&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-to-k8s&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">taskRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-to-k8s&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pathToYamlFile&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deployment.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runAfter&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">source-to-image&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>执行:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f tasks/deploy-to-k8s.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0x07-执行流水线">0x07 执行流水线&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton.dev/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PipelineRun&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">generateName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">generic-pr-&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">generic-pipeline-run&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pipelineRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">build-pipeline&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-revision&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-url&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://github.com/addozhang/tekton-test.git &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">imageUrl&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">addozhang/tekton-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">imageTag&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeClaimTemplate&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteOnce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">1Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceAccountName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-build&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>执行:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f run/run.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0x08-结果">0x08 结果&lt;/h3>
&lt;p>执行流水线后, 可以看到分别创建了下面的几个 pod:&lt;/p>
&lt;ul>
&lt;li>generic-pipeline-run-deploy-to-k8s-xxx&lt;/li>
&lt;li>generic-pipeline-run-fetch-from-git-xxx&lt;/li>
&lt;li>generic-pipeline-run-source-to-image-xxx&lt;/li>
&lt;/ul>
&lt;p>以及我们的应用 &lt;code>tekton-test-xxx&lt;/code>，发起请求测试：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ http &lt;span class="k">$(&lt;/span>minikube ip&lt;span class="k">)&lt;/span>:&lt;span class="k">$(&lt;/span>kubectl get svc tekton-test -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;{.spec.ports[0].nodePort}&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>/hi --body
hello world
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>目前 Tekton 进入 beta 阶段, 最新的版本是 &lt;code>0.25.0&lt;/code>。基于 CRD 的实现让 Tekton 在实际使用中可以灵活的设计自己的 CICD 流程.&lt;/p>
&lt;p>生态也越来越完善，比如 &lt;a href="https://hub.tekton.dev/">Tekton Hub&lt;/a> 提供了大量的可重用最佳实现的 Task 和 Pipeline。&lt;/p>
&lt;p>下一篇，我们尝试下如何在 Jenkins 中与 Tekton Pipeline 进行交互。&lt;/p>
&lt;p>更多文章:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/_hK6bqODJv3LrwnQaou-hA">Tekton 的工作原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://atbug.com/tekton-dashboard-installation/">Tekton Dashboard 安装&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://atbug.com/tekton-trigger-glance/">Tekton Trigger 介绍&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://atbug.com/tekton-trigger-practice/">Tekton Trigger 实战&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>源码解析：一文读懂 Kubelet</title><link>https://atbug.com/kubelet-source-code-analysis/</link><pubDate>Tue, 15 Jun 2021 08:25:25 +0800</pubDate><guid>https://atbug.com/kubelet-source-code-analysis/</guid><description>
&lt;p>本文主要介绍 kubelet 功能、核心组件，以及启动流程的源码分析，总结了 kubelet 的工作原理。&lt;/p>
&lt;h2 id="kubelet-简介">kubelet 简介&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210613091144.png" alt="Kubernetes 的架构图">&lt;/p>
&lt;p>从官方的架构图中很容易就能找到 &lt;code>kubelet&lt;/code>&lt;/p>
&lt;p>执行 &lt;code>kubelet -h&lt;/code> 看到 kubelet 的功能介绍：&lt;/p>
&lt;ul>
&lt;li>kubelet 是每个 Node 节点上都运行的主要“节点代理”。使用如下的一个向 apiserver 注册 Node 节点：主机的 &lt;code>hostname&lt;/code>；覆盖 &lt;code>host&lt;/code> 的参数；或者云提供商指定的逻辑。&lt;/li>
&lt;li>kubelet 基于 &lt;code>PodSpec&lt;/code> 工作。&lt;code>PodSpec&lt;/code> 是用 &lt;code>YAML&lt;/code> 或者 &lt;code>JSON&lt;/code> 对象来描述 Pod。Kubelet 接受通过各种机制（主要是 apiserver）提供的一组 &lt;code>PodSpec&lt;/code>，并确保里面描述的容器良好运行。&lt;/li>
&lt;/ul>
&lt;p>除了由 apiserver 提供 &lt;code>PodSpec&lt;/code>，还可以通过以下方式提供：&lt;/p>
&lt;ul>
&lt;li>文件&lt;/li>
&lt;li>HTTP 端点&lt;/li>
&lt;li>HTTP 服务器&lt;/li>
&lt;/ul>
&lt;p>kubelet 功能归纳一下就是上报 Node 节点信息，和管理（创建、销毁）Pod。 功能看似简单，实际不然。每一个点拿出来都需要很大的篇幅来讲，比如 Node 节点的计算资源，除了传统的 CPU、内存、硬盘，还提供扩展来支持类似 GPU 等资源；Pod 不仅仅有容器，还有相关的网络、安全策略等。&lt;/p>
&lt;h2 id="kubelet-架构">kubelet 架构&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210614215508.png" alt="2021-06-14-21-55-08">&lt;/p>
&lt;h3 id="重要组件">重要组件&lt;/h3>
&lt;p>kubelet 的架构由 N 多的组件组成，下面简单介绍下比较重要的几个：&lt;/p>
&lt;h4 id="pleg">PLEG&lt;/h4>
&lt;p>即 &lt;strong>Pod Lifecycle Event Generator&lt;/strong>，字面意思 Pod 生命周期事件（&lt;code>ContainerStarted&lt;/code>、&lt;code>ContainerDied&lt;/code>、&lt;code>ContainerRemoved&lt;/code>、&lt;code>ContainerChanged&lt;/code>）生成器。&lt;/p>
&lt;p>其维护着 Pod 缓存；定期通过 &lt;code>ContainerRuntime&lt;/code> 获取 Pod 的信息，与缓存中的信息比较，生成如上的事件；将事件写入其维护的通道（channel）中。&lt;/p>
&lt;h4 id="podworkers">PodWorkers&lt;/h4>
&lt;p>处理事件中 Pod 的同步。核心方法 &lt;code>managePodLoop()&lt;/code> 间接调用 &lt;code>kubelet.syncPod()&lt;/code> 完成 Pod 的同步：&lt;/p>
&lt;ul>
&lt;li>如果 Pod 正在被创建，记录其延迟&lt;/li>
&lt;li>生成 Pod 的 API Status，即 &lt;code>v1.PodStatus&lt;/code>：从运行时的 status 转换成 api status&lt;/li>
&lt;li>记录 Pod 从 &lt;code>pending&lt;/code> 到 &lt;code>running&lt;/code> 的耗时&lt;/li>
&lt;li>在 &lt;code>StatusManager&lt;/code> 中更新 pod 的状态&lt;/li>
&lt;li>杀掉不应该运行的 Pod&lt;/li>
&lt;li>如果网络插件未就绪，只启动使用了主机网络（host network）的 Pod&lt;/li>
&lt;li>如果 static pod 不存在，为其创建镜像（Mirror）Pod&lt;/li>
&lt;li>为 Pod 创建文件系统目录：Pod 目录、卷目录、插件目录&lt;/li>
&lt;li>使用 &lt;code>VolumeManager&lt;/code> 为 Pod 挂载卷&lt;/li>
&lt;li>获取 image pull secrets&lt;/li>
&lt;li>调用容器运行时（container runtime）的 &lt;code>#SyncPod()&lt;/code> 方法&lt;/li>
&lt;/ul>
&lt;h4 id="podmanager">PodManager&lt;/h4>
&lt;p>存储 Pod 的期望状态，kubelet 服务的不同渠道的 Pod&lt;/p>
&lt;h4 id="statsprovider">StatsProvider&lt;/h4>
&lt;p>提供节点和容器的统计信息，有 &lt;code>cAdvisor&lt;/code> 和 &lt;code>CRI&lt;/code> 两种实现。&lt;/p>
&lt;h4 id="containerruntime">ContainerRuntime&lt;/h4>
&lt;p>顾名思义，容器运行时。与遵循 CRI 规范的高级容器运行时进行交互。&lt;/p>
&lt;h4 id="depspodconfig">Deps.PodConfig&lt;/h4>
&lt;p>PodConfig 是一个配置多路复用器，它将许多 Pod 配置源合并成一个单一的一致结构，然后按顺序向监听器传递增量变更通知。&lt;/p>
&lt;p>配置源有：文件、apiserver、HTTP&lt;/p>
&lt;h4 id="syncloop">&lt;code>#syncLoop&lt;/code>&lt;/h4>
&lt;p>接收来自 &lt;code>PodConfig&lt;/code> 的 Pod 变更通知、定时任务、&lt;code>PLEG&lt;/code> 的事件，以及 &lt;code>ProbeManager&lt;/code> 的事件，将 Pod 同步到&lt;strong>期望状态&lt;/strong>。&lt;/p>
&lt;h4 id="podadmithandlers">PodAdmitHandlers&lt;/h4>
&lt;p>Pod admission 过程中调用的一系列处理器，比如 eviction handler（节点内存有压力时，不会驱逐 QoS 设置为 &lt;code>BestEffort&lt;/code> 的 Pod）、shutdown admit handler（当节点关闭时，不处理 pod 的同步操作）等。&lt;/p>
&lt;h4 id="oomwatcher">OOMWatcher&lt;/h4>
&lt;p>从系统日志中获取容器的 OOM 日志，将其封装成事件并记录。&lt;/p>
&lt;h4 id="volumemanger">VolumeManger&lt;/h4>
&lt;p>VolumeManager 运行一组异步循环，根据在此节点上调度的 pod 确定需要附加/挂载/卸载/分离哪些卷并执行操作。&lt;/p>
&lt;h4 id="certificatemanager">CertificateManager&lt;/h4>
&lt;p>处理证书轮换。&lt;/p>
&lt;h4 id="probemanager">ProbeManager&lt;/h4>
&lt;p>实际上包含了三种 Probe，提供 probe 结果缓存和通道。&lt;/p>
&lt;ul>
&lt;li>LivenessManager&lt;/li>
&lt;li>ReadinessManager&lt;/li>
&lt;li>StartupManager&lt;/li>
&lt;/ul>
&lt;h4 id="evictionmanager">EvictionManager&lt;/h4>
&lt;p>监控 Node 节点的资源占用情况，根据驱逐规则驱逐 Pod 释放资源，缓解节点的压力。&lt;/p>
&lt;h4 id="pluginmanager">PluginManager&lt;/h4>
&lt;p>PluginManager 运行一组异步循环，根据此节点确定哪些插件需要注册/取消注册并执行。如 CSI 驱动和设备管理器插件（Device Plugin）。&lt;/p>
&lt;h5 id="csi">CSI&lt;/h5>
&lt;p>Container Storage Interface，由存储厂商实现的存储驱动。&lt;/p>
&lt;h5 id="设备管理器插件device-plugin">设备管理器插件（Device Plugin）&lt;/h5>
&lt;p>Kubernetes 提供了一个 设备插件框架，你可以用它来将系统硬件资源发布到 Kubelet。&lt;/p>
&lt;p>供应商可以实现设备插件，由你手动部署或作为 DaemonSet 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。&lt;/p>
&lt;h2 id="kubelet-的启动流程">kubelet 的启动流程&lt;/h2>
&lt;p>要分析 kubelet 的启动流程，可以从 kubelet 运行方式着手。找一个 Node 节点，很容易就能找到 kubelet 的进程。由于其是以 &lt;code>systemd&lt;/code> 的方式启动，也可以通过 &lt;code>systemctl&lt;/code> 查看其状态。&lt;/p>
&lt;h3 id="kubelet-启动命令">kubelet 启动命令&lt;/h3>
&lt;p>kubelet 的启动命令（minikube 环境）&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ ps -aux &lt;span class="p">|&lt;/span> grep &lt;span class="s1">&amp;#39;/kubelet&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> grep -v grep
root &lt;span class="m">4917&lt;/span> 2.6 0.3 &lt;span class="m">1857652&lt;/span> &lt;span class="m">106152&lt;/span> ? Ssl 01:34 13:05 /var/lib/minikube/binaries/v1.21.0/kubelet --bootstrap-kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/bootstrap-kubelet.conf --config&lt;span class="o">=&lt;/span>/var/lib/kubelet/config.yaml --container-runtime&lt;span class="o">=&lt;/span>docker --hostname-override&lt;span class="o">=&lt;/span>1.21.0 --kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/kubelet.conf --node-ip&lt;span class="o">=&lt;/span>192.168.64.5
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ systemctl status kubelet.service
● kubelet.service - kubelet: The Kubernetes Node Agent
Loaded: loaded &lt;span class="o">(&lt;/span>/usr/lib/systemd/system/kubelet.service&lt;span class="p">;&lt;/span> disabled&lt;span class="p">;&lt;/span> vendor preset: enabled&lt;span class="o">)&lt;/span>
Drop-In: /etc/systemd/system/kubelet.service.d
└─10-kubeadm.conf
Active: active &lt;span class="o">(&lt;/span>running&lt;span class="o">)&lt;/span> since Sun 2021-06-13 01:34:42 UTC&lt;span class="p">;&lt;/span> 11h ago
Docs: http://kubernetes.io/docs/
Main PID: &lt;span class="m">4917&lt;/span> &lt;span class="o">(&lt;/span>kubelet&lt;span class="o">)&lt;/span>
Tasks: &lt;span class="m">15&lt;/span> &lt;span class="o">(&lt;/span>limit: 38314&lt;span class="o">)&lt;/span>
Memory: 39.4M
CGroup: /system.slice/kubelet.service
└─4917 /var/lib/minikube/binaries/v1.21.0/kubelet --bootstrap-kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/bootstrap-kubelet.conf --config&lt;span class="o">=&lt;/span>/var/lib/kubelet/config.yaml --container-runtime&lt;span class="o">=&lt;/span>docker --hostname-override&lt;span class="o">=&lt;/span>1.21.0 --kubeconfig&lt;span class="o">=&lt;/span>/etc/kubernetes/kubelet.conf --node-ip&lt;span class="o">=&lt;/span>192.168.64
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="源码分析">源码分析&lt;/h3>
&lt;p>从 &lt;code>git@github.com:kubernetes/kubernetes.git&lt;/code> 仓库获取代码，使用最新的 &lt;code>release-1.21&lt;/code> 分支。&lt;/p>
&lt;ul>
&lt;li>&lt;code>cmd/kubelet/kubelet.go:35&lt;/code> 的 &lt;code>main&lt;/code> 方法为程序入口。
&lt;ul>
&lt;li>调用 &lt;code>NewKubeletCommand&lt;/code> 方法，创建 command&lt;/li>
&lt;li>执行 command
&lt;ul>
&lt;li>&lt;code>cmd/kubelet/app/server.go:434&lt;/code> 的 &lt;code>Run&lt;/code> 方法。
&lt;ul>
&lt;li>调用 &lt;code>RunKubelet&lt;/code> 方法。
&lt;ul>
&lt;li>调用 &lt;code>createAndInitKubelet&lt;/code> 方法，创建并初始化 kubelet
&lt;ul>
&lt;li>&lt;code>pkg/kubelet/kubelet.go&lt;/code> 的 &lt;code>NewMainKubelet&lt;/code> 方法，创建 kubelet的 各种组件。共十几个组件，见 &lt;a href="#kubelet-%E6%9E%B6%E6%9E%84">kubelet 的构架&lt;/a>。&lt;/li>
&lt;li>调用 &lt;code>BirtyCry&lt;/code> 方法：放出 &lt;code>Starting&lt;/code> 事件&lt;/li>
&lt;li>调用 &lt;code>StartGarbageCollection&lt;/code> 方法，开启 &lt;code>ContainerGC&lt;/code> 和 &lt;code>ImageGC&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>调用 &lt;code>startKubelet&lt;/code> 方法（大量使用 goroutine 和通道）
&lt;ul>
&lt;li>goroutine：&lt;code>kubelet.Run()&lt;/code>
&lt;ul>
&lt;li>初始化模块
&lt;ul>
&lt;li>metrics 相关&lt;/li>
&lt;li>创建文件系统目录目录&lt;/li>
&lt;li>创建容器日志目录&lt;/li>
&lt;li>启动 &lt;code>ImageGCManager&lt;/code>&lt;/li>
&lt;li>启动 &lt;code>ServerCertificateManager&lt;/code>&lt;/li>
&lt;li>启动 &lt;code>OOMWatcher&lt;/code>&lt;/li>
&lt;li>启动 &lt;code>ResourceAnalyzer&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>goroutine：&lt;code>VolumeManager.Run()&lt;/code> 开始处理 Pod Volume 的卸载和挂载&lt;/li>
&lt;li>goroutine：状态更新 &lt;code>fastStatusUpdateOnce()&lt;/code> （更新 Pod CIDR -&amp;gt; 更新 &lt;code>ContainerRuntime&lt;/code> 状态 -&amp;gt; 更新 Node 节点状态）&lt;/li>
&lt;li>goroutine： &lt;code>NodeLeaseController.Run()&lt;/code> 更新节点租约&lt;/li>
&lt;li>goroutine：&lt;code>podKiller.PerformPodKillingWork&lt;/code> 杀掉未被正确处理的 pod&lt;/li>
&lt;li>&lt;code>StatusManager.Start()&lt;/code> 开始向 apiserver 更新 Pod 状态&lt;/li>
&lt;li>&lt;code>RuntimeClassManager.Start()&lt;/code>&lt;/li>
&lt;li>&lt;code>PLEG.Start()&lt;/code>：持续从 &lt;code>ContainerRuntime&lt;/code> 获取 Pod/容器的状态，并与 kubelet 本地 cache 中的比较，生成对应的 &lt;code>Event&lt;/code>&lt;/li>
&lt;li>&lt;code>syncLoop()&lt;/code> 重点，&lt;strong>&lt;em>持续监控并处理来自文件、apiserver、http 的变更&lt;/em>&lt;/strong>。包括 Pod 的增加、更新、优雅删除、非优雅删除、调和。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>启动 server，暴露 &lt;code>/healthz&lt;/code> 端点&lt;/li>
&lt;li>通知 &lt;code>systemd&lt;/code> &lt;code>kuberlet&lt;/code> 服务已经启动&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="kubelet-的工作原理">kubelet 的工作原理&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210615000611.png" alt="">&lt;/p>
&lt;ol>
&lt;li>来静态文件、apiserver 以及 HTTP 请求的 Pod 配置变更，被发送到 &lt;code>kubelet.syncLoop&lt;/code>&lt;/li>
&lt;li>PLEG 会定期通过容器运行时获取节点上 Pod 的状态，与其缓存中的 Pod 信息进行比较，封装成事件，进入 PLEG 的通道&lt;/li>
&lt;li>定期检查工作队列中的 Pod&lt;/li>
&lt;li>ProbeManager 的通道中的 Pod&lt;/li>
&lt;li>以上 1~4，都会进入 &lt;code>syncLoopIteration&lt;/code>，并从对应的通道中获取到对应 Pod，将 Pod 的信息保存到 &lt;code>PodManager&lt;/code>；然后分发给 &lt;code>PodWorker&lt;/code>，&lt;a href="#PodWorkers">完成一些列的同步工作&lt;/a>。&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>kubelet 启动流量就讲到这里，虽然复杂，还是有迹可循。只要了解了 kubelet 在 Kubernetes 中的定位及角色，就很容易理解其工作流量。&lt;/p>
&lt;p>后面会再深入分析 Pod 创建及启动流程。&lt;/p></description></item><item><title>Kubernetes 上如何控制容器的启动顺序？</title><link>https://atbug.com/k8s-1.18-container-start-sequence-control/</link><pubDate>Fri, 30 Apr 2021 07:43:54 +0800</pubDate><guid>https://atbug.com/k8s-1.18-container-start-sequence-control/</guid><description>
&lt;p>去年写过一篇博客：&lt;a href="https://mp.weixin.qq.com/s/5UXhXpwPDBh2xuGKq9Nqig">控制 Pod 内容器的启动顺序&lt;/a>，分析了 &lt;a href="https://github.com/tektoncd">TektonCD&lt;/a> 的容器启动控制的原理。&lt;/p>
&lt;p>为什么要做容器启动顺序控制？我们都知道 Pod 中除了 &lt;code>init-container&lt;/code> 之外，是允许添加多个容器的。类似 TektonCD 中 &lt;code>task&lt;/code> 和 &lt;code>step&lt;/code> 的概念就分别与 &lt;code>pod&lt;/code> 和 &lt;code>container&lt;/code> 对应，而 &lt;code>step&lt;/code> 是按照顺序执行的。此外还有服务网格的场景，sidecar 容器需要在服务容器启动之前完成配置的加载，也需要对容器的启动顺序加以控制。否则，服务容器先启动，而 sidecar 还无法提供网络上的支持。&lt;/p>
&lt;h3 id="现实">现实&lt;/h3>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/30/sidecarlifecycle1.gif" alt="sidecar-lifecycle-1">&lt;/p>
&lt;h3 id="期望">期望&lt;/h3>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/30/sidecarlifecycle2.gif" alt="sidecar-lifecycle-2">&lt;/p>
&lt;p>到了这里肯定有同学会问，&lt;code>spec.containers[]&lt;/code> 是一个数组，数组是有顺序的。Kubernetes 也确实是按照顺序来创建和启动容器，但是 &lt;strong>容器启动成功，并不表示容器可以对外提供服务&lt;/strong>。&lt;/p>
&lt;p>在 Kubernetes 1.18 非正式版中曾在 Lifecycle 层面提供了对 &lt;code>sidecar 类型容器的&lt;/code> 支持，但是最终该功能并&lt;a href="https://github.com/kubernetes/enhancements/issues/753#issuecomment-713471597">没有落地&lt;/a>。&lt;/p>
&lt;p>那到底该怎么做？&lt;/p>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>笔者准备了一个简单的 &lt;a href="https://github.com/addozhang/k8s-container-sequence-sample">go 项目&lt;/a>，用于模拟 sidecar 的启动及配置加载。&lt;/p>
&lt;p>克隆代码后可以通过 &lt;code>make build&lt;/code> 构建出镜像，假如你是用的 minikube 进行的实验，可以通过命令 &lt;code>make load-2-minikube&lt;/code> 将镜像加载到 minikube 节点中。&lt;/p>
&lt;p>使用 Deployment 的方式进行部署，直接用 Pod 也可以。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">strategy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">addozhang/k8s-container-sequence-sidecar:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sidecar&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">lifecycle&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">postStart&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/entrypoint&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">wait&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;date; echo &amp;#39;app container started&amp;#39;; tail -f /dev/null&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面的截图中，演示了在 &lt;code>sample&lt;/code> 命名空间中，pod 内两个容器的执行顺序。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/30/20210430-062819.gif" alt="2021-04-30 06.28.19">&lt;/p>
&lt;h2 id="kubernetes-源码">Kubernetes 源码&lt;/h2>
&lt;p>在 kubelet 的源码 &lt;code>pkg/kubelet/kuberuntime/kuberuntime_manager.go&lt;/code> 中，&lt;code>#SyncPod&lt;/code> 方法用于创建 Pod，步骤比较繁琐，直接看第 7 步：创建普通容器。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// SyncPod syncs the running pod into the desired pod by executing following steps:
&lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">// 1. Compute sandbox and container changes.
&lt;/span>&lt;span class="c1">// 2. Kill pod sandbox if necessary.
&lt;/span>&lt;span class="c1">// 3. Kill any containers that should not be running.
&lt;/span>&lt;span class="c1">// 4. Create sandbox if necessary.
&lt;/span>&lt;span class="c1">// 5. Create ephemeral containers.
&lt;/span>&lt;span class="c1">// 6. Create init containers.
&lt;/span>&lt;span class="c1">// 7. Create normal containers.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeGenericRuntimeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SyncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Secret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">backOff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">flowcontrol&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Backoff&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">result&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSyncResult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="c1">// Step 7: start containers in podContainerChanges.ContainersToStart.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainersToStart&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;container&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">containerStartSpec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>#start&lt;/code> 方法中调用了 &lt;code>#startContainer&lt;/code> 方法，该方法会启动容器，并返回容器启动的结果。注意，这里的结果还 &lt;strong>包含了容器的 Lifecycle hooks 调用&lt;/strong>。&lt;/p>
&lt;p>也就是说，假如容器的 &lt;code>PostStart&lt;/code> hook 没有正确的返回，kubelet 便不会去创建下一个容器。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// startContainer starts a container and returns a message indicates why it is failed on error.
&lt;/span>&lt;span class="c1">// It starts the container through the following steps:
&lt;/span>&lt;span class="c1">// * pull the image
&lt;/span>&lt;span class="c1">// * create the container
&lt;/span>&lt;span class="c1">// * start the container
&lt;/span>&lt;span class="c1">// * run the post start lifecycle hooks (if applicable)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeGenericRuntimeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">startContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podSandboxID&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podSandboxConfig&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">runtimeapi&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSandboxConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">spec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">startSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Secret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podIP&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podIPs&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="c1">// Step 4: execute the post start hook.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Lifecycle&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Lifecycle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PostStart&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kubeContainerID&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerID&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runtimeName&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">ID&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">handlerErr&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runner&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">kubeContainerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Lifecycle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PostStart&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">handlerErr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">recordContainerEvent&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubeContainerID&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EventTypeWarning&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">events&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FailedPostStartHook&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">msg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">killContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubeContainerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;FailedPostStartHook&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">reasonFailedPostStartHook&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ErrorS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s: %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ErrPostStartHook&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">handlerErr&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;Failed to kill container&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;pod&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">KObj&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="s">&amp;#34;podUID&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;containerName&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;containerID&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubeContainerID&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">String&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s: %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ErrPostStartHook&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">handlerErr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="实现方案">实现方案&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/30/16197365667225.jpg" alt="">&lt;/p>
&lt;p>&lt;a href="https://github.com/addozhang/k8s-container-sequence-sample/blob/main/cmd/entrypoint/wait.go#L26">cmd/entrypoint/wait.go#L26&lt;/a> （这里参考了 Istio 的 pilot-agent 实现 ）&lt;/p>
&lt;p>在 &lt;code>PostStart&lt;/code> 中持续的去检查 &lt;code>/ready&lt;/code> 断点，可以 hold 住当前容器的创建流程。保证 &lt;code>/ready&lt;/code> 返回 &lt;code>200&lt;/code> 后，kubelet 才会去创建下一个容器。&lt;/p>
&lt;p>这样就达到了前面截图中演示的效果。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">for&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">Before&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">timeoutAt&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">checkIfReady&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sidecar is ready&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sidecar is not ready&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Duration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">periodMillis&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sidecar is not ready in %d second(s)&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timeoutSeconds&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://banzaicloud.com/blog/k8s-sidecars/">Sidecar container lifecycle changes in Kubernetes 1.18&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@marko.luksa/delaying-application-start-until-sidecar-is-ready-2ec2d21a7b74">Delaying application start until sidecar is ready&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>服务网格平稳落地：Istio 中精准控制 Sidecar 的注入</title><link>https://atbug.com/how-to-control-istio-sidecar-injection/</link><pubDate>Wed, 21 Apr 2021 08:13:04 +0800</pubDate><guid>https://atbug.com/how-to-control-istio-sidecar-injection/</guid><description>
&lt;h2 id="为什么">为什么&lt;/h2>
&lt;p>说起服务网格，这幅图大家肯定不会陌生。这就是服务网格的网络，也是网格架构的终极形态。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/21/cleanshot-20210420-at-2314142x.png" alt="">&lt;/p>
&lt;p>那在迁移到网格架构之前，我们的系统是什么样的？&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/21/cleanshot-20210420-at-2316432x.png" alt="">&lt;/p>
&lt;p>我们的系统在演进的过程中，不可避免的会遇到各种 0 到 1 过程中的中间态。比如下面这种，可以比较直观的看出 Istio 或者网格是部分覆盖的。这个过程中，我们需要平滑、可控的推进，才能在保障系统可用性的前提下进行架构的演进。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/21/cleanshot-20210420-at-2318242x.png" alt="">&lt;/p>
&lt;h2 id="怎么做">怎么做&lt;/h2>
&lt;p>Sidecar 的注入分两种：手动和自动。&lt;/p>
&lt;h3 id="手动">手动&lt;/h3>
&lt;p>手动就是利用 Istio 的 cli 工具 &lt;code>istioctl kube-inject&lt;/code> 对资源 yaml 进行修改：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ istioctl kube-inject -f samples/sleep/sleep.yaml &lt;span class="p">|&lt;/span> kubectl apply -f -
serviceaccount/sleep created
service/sleep created
deployment.apps/sleep created
&lt;/code>&lt;/pre>&lt;/div>&lt;p>手动的方式比较适合开发阶段使用。&lt;/p>
&lt;h3 id="自动">自动&lt;/h3>
&lt;p>sidecar 的自动注入则是通过 &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">mutating webhook admission controller&lt;/a> 实现的。其原理简单说就是拦截 pod的创建请求来对 pod 的资源定义进行修改。&lt;/p>
&lt;p>我们对截取了 &lt;code>istio-sidecar-injector&lt;/code> &lt;code>MutatingWebhookConfiguration&lt;/code> 的部分内容。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">webhooks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Exact&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sidecar-injector.istio.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespaceSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">istio-injection&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">enabled&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">objectSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchExpressions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sidecar.istio.io/inject&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NotIn&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">values&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;false&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiVersions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">CREATE&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pods&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scope&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;*&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>这里的 &lt;code>matchPolicy: Exact&lt;/code> 针对的是 #4 中的 &lt;code>apiGroups&lt;/code>与&lt;code>apiVersions&lt;/code> 的组合，即精确匹配 &lt;code>v1/pods&lt;/code> 的 &lt;code>CREATE&lt;/code> 请求&lt;/li>
&lt;li>顾名思义，匹配符合条件的 &lt;code>namespace&lt;/code>&lt;/li>
&lt;li>同2，匹配符合条件的 &lt;code>object&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>注： #2、#3 支持 Kubernetes 的&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">标签选择语法&lt;/a>&lt;/p>
&lt;p>按照前面的说明，这个 hook 会拦截打了 &lt;code>istio-injection: enabled&lt;/code> label 的 namespace 下，没有打 &lt;code>sidecar.istio.io/inject: false&lt;/code> 标签的 &lt;code>v1/pod&lt;/code> 的创建。通过 &lt;code>https://istiod.istio-system:443/inject&lt;/code> 端点对 pod 的定义进行定制（添加 &lt;code>init-container&lt;/code>、sidecar 容器等）。&lt;/p>
&lt;p>有人可能会说这样还不够精准，因为可能某个 namespace 下只有部分对象才会注入 sidecar。&lt;/p>
&lt;p>这就需要借助 &lt;code>istiod&lt;/code> 的逻辑了。&lt;/p>
&lt;h3 id="只针对特定-pod-注入sidecar-或忽略注入">只针对特定 pod 注入sidecar 或忽略注入&lt;/h3>
&lt;p>在 &lt;code>configmap&lt;/code> &lt;code>istio-sidecar-injector&lt;/code> 中有两个字段 &lt;code>alwaysInjectSelector&lt;/code> 和 &lt;code>neverInjectSelector&lt;/code>。从名字来看这两个分别提供了白名单、黑名单的功能。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">alwaysInjectSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="l">neverInjectSelector:[]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们只需如下调整（需要重启 istiod），然后为需要注入 sidecar 的资源打上相应的标签即可。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">alwaysInjectSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchExpressions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sidecar.istio.io/inject&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">In&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">values&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;enabled&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;yes&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>分布式系统在 Kubernetes 上的进化</title><link>https://atbug.com/translation-distributed-systems-kubernetes/</link><pubDate>Mon, 29 Mar 2021 23:11:25 +0800</pubDate><guid>https://atbug.com/translation-distributed-systems-kubernetes/</guid><description>
&lt;p>本文译自 &lt;a href="https://www.infoq.com/articles/distributed-systems-kubernetes/">The Evolution of Distributed Systems on Kubernetes&lt;/a>&lt;/p>
&lt;p>在 3 月份的 QCon 上，我做了一个关于 Kubernetes 的分布式系统进化的演讲。首先，我想先问一个问题，微服务之后是什么？我相信大家都有各自的答案，我也有我的答案。你会在最后发现我的想法是什么。为了达到这个目的，我建议大家看看分布式系统的需求是什么？以及这些需求在过去是如何发展的，从单体应用开始到 Kubernetes，再到最近的 Dapr、Istio、Knative 等项目，它们是如何改变我们做分布式系统的方式。我们将尝试对未来做一些预测。&lt;/p>
&lt;h2 id="现代分布式应用">现代分布式应用&lt;/h2>
&lt;p>为了给这个话题提供更多的背景信息，我认为的分布式系统是由数百个组件组成的系统。这些组件可以是有状态的、无状态的或者无服务器的。此外，这些组件可以用不同的语言创建，运行在混合环境上，并开发开源技术、开放标准和互操作性。我相信你可以使用闭源软件来构建这样的系统，也可以在 AWS 和其他地方构建。具体到这次演讲，我将关注 Kubernetes 生态系统，以及你如何在 Kubernetes 平台上构建这样一个系统。&lt;/p>
&lt;p>我们从分布式系统的需求讲起。我认为是我们要创建一个应用或者服务，并写一些业务逻辑。那从运行时的平台到构建分布式系统，我们还需要什么呢？在底层，最开始是我们要一些生命周期的能力。当你用任一语言开发你的应用时，我们希望有能力把这个应用可靠地打包和部署、回滚、健康检查。并且能够把应用部署到不同的节点上，并实现资源隔离、扩展、配置管理，以及所有这些。这些都是你创建分布式应用所需要的第一点。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/55image0011616431697020.jpg" alt="">&lt;/p>
&lt;p>第二点是围绕网络。我们有了应用之后，我们希望它能够可靠地连接到其他服务，无论该服务是在集群内部还是在外部。我们希望其具有服务发现、负载均衡的能力。为了不同的发布策略或是其他的一些原因的我们希望有流量转移的能力。然后我们还希望其具有与其他系统进行弹性通信的能力，无论是通过重试、超时还是断路器。要有适当的安全保障，并且要有足够的监控、追踪、可观察性等等。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/25image0021616431698392.jpg" alt="">&lt;/p>
&lt;p>我们有了网络之后，接下来就是我们希望有能力与不同的 API 和端点交互，即资源绑定&amp;ndash;与其他协议和不同的数据格式交互。甚至能够从一种数据格式转换成另一种数据格式。我还会在这里加入诸如滤光的功能，也就是说，当我们订阅一个主题时，我们也许只对某些事件感兴趣。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/45image0031616431697873.jpg" alt="">&lt;/p>
&lt;p>你认为最后一类是什么？是状态。当我在说状态和有状态的抽象时，我并不是在谈论实际的状态管理，比如数据库或者文件系统的功能。我要说的更多是有关幕后依赖状态的开发人员抽象。可能，你需要具有工作流管理的能力。也许你想管理运行时间长的进程或者做临时调度或者某些定时任务来定期运行服务。也许你还想进行分布式缓存，具有幂等性或者支持回滚。所有这些都是开发人员级的原语，但在幕后，它们依赖于具有某种状态。你想随意使用这些抽象俩创建完善的分布式系统。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/26image0041616431697348.jpg" alt="">&lt;/p>
&lt;p>我们将使用这个分布式系统原语的框架来评估它们在 Kubernetes 和其他项目上的变化情况。&lt;/p>
&lt;h2 id="单体架构----传统中间件功能">单体架构 &amp;ndash; 传统中间件功能&lt;/h2>
&lt;p>假设我们从单体架构以及如何获得这些能力开始。在那种情况下，首先是当我说单体的时候，在分布式应用的情况下我想到的是 ESB。ESB 是相当强大的，当我们检查我们的需求列表时，我们会说 ESB 对所有有状态的抽象有很好的支持。&lt;/p>
&lt;p>使用 ESB，你可以进行长时间运行的流程的编排、分布式事务、回滚和幂等。此外，ESB 还提供了出色的资源绑定能力，并且有数百个连接器，支持转换、编排，甚至有联网功能。最后，ESB 甚至可以做服务发现和负载均衡。&lt;/p>
&lt;p>它具有围绕网络连接的弹性的所有功能，因此它可以进行重试。可能 ESB 本质上不是很分布式，所以它不需要非常高级的网络和发布能力。ESB 欠缺的主要是生命周期管理。因为它是单一运行时，所以第一件事就是你只能使用一种语言。通常是创建实际运行时的语言，Java、.NET、或者其他的语言。然后，因为是单一运行时，我们不能轻松地进行声明式的部署或者自动防止。部署是相当大且非常重的，所以它通常涉及到人机交互。这种单体架构的另一个难点是扩展：“我们无法扩展单个组件。”&lt;/p>
&lt;p>最后却并非最不重要的一点是，围绕隔离，无论是资源隔离还是故障隔离。使用单体架构无法完成所有这些工作。从我们的需求框架来看，ESB 的单体架构不符合条件。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/40image0051616431696438.jpg" alt="">&lt;/p>
&lt;h2 id="云原生架构----微服务和-kubernetes">云原生架构 &amp;ndash; 微服务和 Kubernetes&lt;/h2>
&lt;p>接下来，我建议我们研究一下云原生架构以及这些需求是如何变化的。如果我们从一个非常高的层面来看，这些架构是如何发生变化的，云原生可能始于微服务运动。微服务使我们可以按业务领域进行拆分单体应用。事实证明，容器和 Kubernetes 实际上是管理这些微服务的优秀平台。让我们来看一下 Kubernetes 对于微服务特别有吸引力的一些具体特性和功能。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/13image0061616431699209.jpg" alt="">&lt;/p>
&lt;p>从一开始，进行健康状况探测的能力就是 Kubernetes 受欢迎的原因。在实践中，这意味着当你将容器部署到 Pod 中时，Kubernetes 会检查进程的运行状况。通常情况下，该过程模型还不够好。你可能仍然有一个已启动并正在运行的进程，但是它并不健康。这就是为什么还可以使用就绪度和存活度检查的原因。Kubernetes 会做一个就绪度检查，以确定你的应用在启动期间何时准备接受流量。它将进行活跃度检查，以检查服务的运行状况。在 Kubernetes 之前，这并不是很流行，但今天几乎所有语言、所有框架、所有运行时都有健康检查功能，你可以在其中快速启动端点。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/29image0071616431696697.jpg" alt="">&lt;/p>
&lt;p>Kubernetes 引入的下一个特性是围绕应用程序的托管生命周期&amp;ndash;我的意思是，你不再控制何时启动、何时关闭服务。你相信平台可以做到这一点。Kubernetes 可以启动你的应用；它可以将其关闭，然后在不同的节点上移动它。为此，你必须正确执行平台在应用启动和关闭期间告诉你的事件。&lt;/p>
&lt;p>Kubernetes 刘兴的另一件特性是围绕着声明式部署。这意味着你不再需要启动服务；检查日志是否已经启动。你不必手动升级实例&amp;ndash;支持声明式部署的 Kubernetes 可以为你做到这一点。根据你选择的策略，它可以停止旧实例并启动新实例。此外，如果出现问题，可以进行回滚。&lt;/p>
&lt;p>另外就是声明你的资源需求。创建服务时，将其容器化。最好告诉平台该服务将需要多少 CPU 和内存。Kubernetes 利用这些信息为你的工作负载找到最佳节点。在使用 Kubernetes 之前，我们必须根据我们的标准将实例手动放置到一个节点上。现在，我们可以根据自己的偏好来指导 Kubernetes，它将为我们做出最佳的决策。&lt;/p>
&lt;p>如今，在 Kubernetes 上，你可以进行多语言配置管理。无需在应用程序运行时进行配置查找就可以进行任何操作。Kubernetes 会确保配置最终在工作负载所在的同一节点上。这些配置被映射为卷或环境变量，以供你的应用程序使用。&lt;/p>
&lt;p>事实证明，我刚才谈到的那些特定功能也是相关的。比如说，如果要进行自动放置，则必须告诉 Kubernetes 服务的资源需求。然后，你必须告诉它要使用的部署策略。为了让策略正确运行，你的应用程序必须执行来自环境的事件。它必须执行健康检查。一旦采用了所有这些最佳实践并使用所有这些功能，你的应用就会成为出色的云原生公民，并且可以在 Kubernetes 上实现自动化了（这是在 Kubernetes 上运行工作负载的基本模式）。最后，还有围绕着构建 Pod 中的容器、配置管理和行为，还有其他模式。&lt;/p>
&lt;p>我要简要介绍的下一个主题是工作负载。从生命周期的角度来看，我们希望能够运行不同的工作负载。我们也可以在 Kubernetes 上做到这一点。运行十二要素应用程序和无状态微服务非常简单。Kubernetes 可以做到这一点。这不是你将要承担的唯一工作量。可能你还有有状态的工作负载，你可以使用有状态集在 Kubernetes 上完成此工作。&lt;/p>
&lt;p>你可能还有的另一个工作负载是单例。也许你希望某个应用程序的实例是整个集群中应用程序的唯一一个实例&amp;ndash;你希望它成为可靠的单例。如果失败，则重新启动。因此，你可以根据需求以及是否希望单例至少具有一种或最多一种语义来在有状态集和副本集之间进行选择。你可能还有的另一个工作负载是围绕作业和定时作业&amp;ndash;有了 Kubernetes，你也可以实现这些。&lt;/p>
&lt;p>如果我们将所有这些 Kubernetes 功能映射到我们的需求，则 Kubernetes 可以满足生命周期需求。我通常创建的需求列表主要是由 Kubernetes 今天提供给我们的。这些是任何平台上的预期功能，而 Kubernetes 可以为你的部署做的是配置管理、资源隔离和故障隔离。此外，除了无服务器本身之外，它还支持其他工作负载。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/12image0081616431698134.jpg" alt="">&lt;/p>
&lt;p>然后，如果这就是 Kubernetes 给开发者提供的全部功能，那么我们该如何扩展 Kubernetes 呢？以及如何使它具有更多功能？因此，我想描述当今使用的两种常用方法。&lt;/p>
&lt;h2 id="进程外扩展机制">进程外扩展机制&lt;/h2>
&lt;p>首先是 Pod 的概念，Pod 是用于在节点上部署容器的抽象。此外，Pod 给我们提供了两组保证：&lt;/p>
&lt;ul>
&lt;li>第一组是部署保证 &amp;ndash; Pod 中的所有容器始终位于同一个节点上。这意味着它们可以通过 localhost 相互通信，也可以使用文件系统或通过其他 IPC 机制进行异步通信。&lt;/li>
&lt;li>Pod 给我们的另一组保证是围绕生命周期的。Pod 中的所有容器并非都相等。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/22image0091616431698660.jpg" alt="">&lt;/p>
&lt;p>根据使用的是 init 容器还是应用程序容器，你会获得不同的保证。例如，init 容器在开始时运行；当 Pod 启动时，它按顺序一个接一个地运行。他们仅在之前的容器已成功完成时运行。它们有助于实现由容器驱动的类似工作流的逻辑。&lt;/p>
&lt;p>另一方面，应用程序容器是并行运行的。它们在整个 Pod 的生命周期中运行，这也是 sidecar 模式的基础。sidecar 可以运行多个容器，这些容器可以协作并共同为用户提供价值。这也是当今我们看到的扩展 Kubernetes 附加功能的主要机制之一。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/9image0101616431695489.jpg" alt="">&lt;/p>
&lt;p>为了解释以下功能，我必须简要地告诉你 Kubernetes 内部的工作方式。它是基于调谐循环的。调谐循环的思想是将期望状态驱动到实际状态。在 Kubernetes 中，很多功能都是靠这个来实现的。例如，当你说我要两个 Pod 实例，这系统的期望状态。有一个控制循环不断地运行，并检查你的 Pod 是否有两个实例。如果不存在两个实例，它将计算差值。它将确保存在两个实例。&lt;/p>
&lt;p>这方面的例子有很多。一些是副本集或有状态集。资源定义映射到控制器是什么，并且每个资源定义都有一个控制器。该控制器确保现实世界与所需控制器相匹配，你甚至可以编写自己的自定义控制器。&lt;/p>
&lt;p>当在 Pod 中运行应用程序时，你将无法在运行时加载任何配置文件更改。然而，你可以编写一个自定义控制器，检测 config map 的变化，重新启动 Pod 和应用程序&amp;ndash;从而获取配置更改。&lt;/p>
&lt;p>事实证明，即使 Kubernetes 拥有丰富的资源集合，但它们并不能满足你的所有不同需求。Kubernetes 引入了自定义资源定义的概念。这意味着你可以对需求进行建模并定义适用于 Kubernetes 的 API。它与其他 Kubernetes 原生资源共存。你可以用能理解模型的任何语言编写自己的控制器。你可以设计一个用 Java 实现的 ConfigWatcher，描述我们前面所解释的内容。这就是 operator 模式，即与自定义资源定义一起使用的控制器。如今，我们看到很多 operator 假如，这就是第二种扩展 Kubernetes 附加功能的方式。&lt;/p>
&lt;p>接下来，我想简单介绍一下基于 Kubernetes 构建的一些平台，这些平台大量使用 sidecar 和 operator 来给开发者提供额外的功能。&lt;/p>
&lt;h2 id="什么是服务网格">什么是服务网格？&lt;/h2>
&lt;p>让我们从服务网格开始，什么是服务网格？&lt;/p>
&lt;p>我们有两个服务，服务 A 要调用服务 B，并且可以用任何语言。把这个当做是我们的应用工作负载。服务网格使用 sidecar 控制器，并在我们的服务旁边注入一个代理。你最终会在 Pod 中得到两个容器。代理是一个透明的代理，你的应用对这个代理完全无感知&amp;ndash;它拦截所有传入和传出的流量。此外，代理还充当数据防火墙。&lt;/p>
&lt;p>这些服务代理的集合代表了你的数据平面，并且很小且无状态。为了获得所有状态和配置，它们依赖于控制平面。控制平面是保持所有配置，收集指标，做出决定并与数据平面进行交互的有状态部分。此外，它们是不同控制平面和数据平面的正确选择。事实证明，我们还需要一个组件-一个 API 网关，以将数据获取到我们的集群中。一些服务网格具有自己的 API 网关，而某些使用第三方。如果你研究下所有这些组件，它们将提供我们所需的功能。&lt;/p>
&lt;p>API 网关主要专注于抽象我们服务的实现。它隐藏细节并提供边界功能。服务网格则相反。在某种程度上，它增强了服务内的可见性和可靠性。可以说，API 网关和服务网格共同提供了所有网络需求。要在 Kubernetes 上获得网络功能，仅使用服务是不够的：“你需要一些服务网格。”&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/19image0111616431696146.jpg" alt="">&lt;/p>
&lt;h2 id="什么是-knative">什么是 Knative？&lt;/h2>
&lt;p>我要讨论的下一个主题是 Knative，这是 Google 几年前启动的一个项目。它是 Kubernetes 之上的一层，可为您提供无服务器功能，并具有两个主要模块：&lt;/p>
&lt;ul>
&lt;li>Knative 服务 - 围绕着请求-应答交互，以及&lt;/li>
&lt;li>Knative Eventing - 更多的是用于事件驱动的交互。&lt;/li>
&lt;/ul>
&lt;p>只是让你感受一下，Knative Serving 是什么？通过 Knative Serving，你可以定义服务，但这不同于 Kubernetes 服务。这是 Knative 服务。使用 Knative 服务定义工作负载后，你就会得到具有无服务器的特征的部署。你不需要有启动并运行实例。它可以在请求到达时从零开始。你得到的是无服务器的能力；它可以迅速扩容，也可以缩容到零。&lt;/p>
&lt;p>Knative Eventing 为我们提供了一个完全声明式的事件管理系统。假设我们有一些要与之集成的外部系统，以及一些外部的事件生产者。在底部，我们将应用程序放在具有 HTTP 端点的容器中。借助 Knative Eventing，我们可以启动代理，该代理可以触发 Kafka 映射的代理，也可以在内存或者某些云服务中。此外，我们可以启动连接到外部系统的导入器，并将事件导入到我们的代理中。这些导入器可以基于，例如，具有数百个连接器的 Apache Camel。&lt;/p>
&lt;p>一旦我们将事件发送给代理，然后用 YAML 文件声明，我们可以让容器订阅这些事件。在我们的容器中，我们不需要任何消息客户端&amp;ndash;比如 Kafka 客户端。我们的容器将使用云事件通过 HTTP POST 获取事件。这是一个完全平台管理的消息传递基础设施。作为开发人员，你必须在容器中编写业务代码，并且不处理任何消息传递逻辑。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/8image0121616431698919.jpg" alt="">&lt;/p>
&lt;p>从我们的需求的角度来看，Knative 可以满足其中的一些要求。从生命周期的角度来看，它为我们的工作负载提供了无服务器的功能，因此能够将其扩展到零，并从零开始激活。从网络的角度来看，如果服务网格之间存在某些重叠，则 Knative 也可以进行流量转移。从绑定的角度来看，它对使用 Knative 导入程序进行绑定提供了很好的支持。它可以使我们进行发布/订阅，或点对点交互，甚至可以进行一些排序。它可以满足几类需求。&lt;/p>
&lt;h2 id="什么是-dapr">什么是 Dapr？&lt;/h2>
&lt;p>另一个使用 sidecar 和 operator 的项目是 &lt;a href="https://dapr.io/">Dapr&lt;/a>，它是微软几个月前才开始并且正在迅速流行起来。此外，1.0 版本 &lt;a href="https://www.infoq.com/news/2021/02/dapr-production-ready/">被认为是生产可用的&lt;/a>。它是一个作为 sidecar 的分布式系统工具包&amp;ndash;Dapr 中的所有内容都是作为 sidecar 提供的，并且有一套他们所谓的构件或功能集的集合。&lt;/p>
&lt;p>这些功能是什么呢？第一组功能是围绕网络。Dapr 可以进行服务发现和服务之间的点对点集成。同样，它也可以进行服务网格的追踪、可靠通信、重试和恢复。第二套功能是围绕资源绑定：&lt;/p>
&lt;ul>
&lt;li>它有很多云 API、不同系统的连接器，以及&lt;/li>
&lt;li>也可以做消息发布/订阅和其他逻辑。&lt;/li>
&lt;/ul>
&lt;p>有趣的是，Dapr 还引入了状态管理的概念。除了 Knative 和服务网格提供的功能外，Dapr 在状态存储之上进行了抽象。此外，你通过存储机制支持与 Dapr 进行基于键值的交互。&lt;/p>
&lt;p>在较高的层次上，架构是你的应用程序位于顶部，可以使用任何语言。你可以使用 Dapr 提供的客户端库，但你不必这样做。你可以使用语言功能来执行称为 sidecar 的 HTTP 和 gRPC。与 服务网格的区别在于，这里的 Dapr sidecar 不是一个透明的代理。它是一个显式代理，你必须从你的应用中调用它，并通过 HTTP 或 gRPC 与之交互。根据你需要的功能，Dapr 可以与其他如云服务的系统对话。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/18image0131616431699532.jpg" alt="">&lt;/p>
&lt;p>在 Kubernetes 上，Dapr 是作为 sidecar 部署的，并且可以在 Kubernetes 之外工作（不仅仅是 Kubernetes）。此外，它还有一个 operator &amp;ndash; 而 sidecar 和 Operator 是主要的扩展机制。其他一些组件管理证书、处理基于 actor 的建模并注入 sidecar。你的工作负载与 sidecar 交互，并尽其所能与其他服务对话，让你与不同的云提供商进行互操作。它还为你提供了额外的分布式系统功能。&lt;/p>
&lt;p>综上所述，这些项目所提供的功能，我们可以说 ESB 是分布式系统的早期化身，其中我们有集中式的控制平面和数据平面&amp;ndash;但是扩展性不好。在云原生中，集中式控制平面仍然存在，但是数据平面是分散的&amp;ndash;并且具有隔音功能和高度的可扩展性。&lt;/p>
&lt;p>我们始终需要 Kubernetes 来做良好的生命周期管理，除此之外，你可能还需要一个或多个附加组件。你可能需要 Istio 来进行高级联网。你可能会使用 Knative 来进行无服务器工作负载，或者使用 Dapr 来做集成。这些框架可与 Istio 和 Envoy 很好的配合使用。从 Dapr 和 Knative 的角度来看，你可能必须选择一个。它们共同以云原生的方式提供了我们过去在 ESB 上拥有的东西。&lt;/p>
&lt;h2 id="未来云原生趋势--生命周期趋势">未来云原生趋势&amp;ndash;生命周期趋势&lt;/h2>
&lt;p>在接下来的部分，我列出了一些我认为在这些领域正在发生令人振奋的发展的项目。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/8image0141616431695762.jpg" alt="">&lt;/p>
&lt;p>我想从生命周期开始。通过 Kubernetes，我们可以为应用程序提供一个有用的生命周期，这可能不足以进行更复杂的生命周期管理。比如，如果你有一个更复杂的有状态应用，则可能会有这样的场景，其中 Kubernetes 中的部署原语不足以为应用提供支持。&lt;/p>
&lt;p>在这些场景下，你可以使用 operator 模式。你可以使用一个 operator 来进行部署和升级，还可以将 S3 作为服务备份的存储介质。此外，你可能还会发现 Kubernetes 的实际健康检查机制不够好。假设存活检查和就绪检查不够好。在这种情况下，你可以使用 operator 对你的应用进行更智能的存活和就绪检查，然后在此基础上进行恢复。&lt;/p>
&lt;p>第三个领域就是自动伸缩和调整。你可以让 operator 更好的了解你的应用，并在平台上进行自动调整。目前，编写 operator 的框架主要有两个，一个是 Kubernetes 特别兴趣小组的 Kubebuilder，另一个是红帽创建的 operator 框架的一部分&amp;ndash;operator SDK。它有以下几个方面的内容：&lt;/p>
&lt;p>Operator SDK 让你可以编写 operator &amp;ndash; operator 生命周期管理器来管理 operator 的生命周期，以及可以发布你的 operator 到 OperatorHub。如今在 OperatorHub，你会看到 100 多个 operator 用于管理数据库、消息队列和监控工具。从生命周期空间来看，operator 可能是 Kubernetes 生态系统中发展最活跃的领域。&lt;/p>
&lt;h2 id="网络趋势---envoy">网络趋势 - Envoy&lt;/h2>
&lt;p>我选的另一个项目是 &lt;a href="https://www.envoyproxy.io/">Envoy&lt;/a>。服务网格接口规范的引入将使你更轻松地切换不同的服务网格实现。在部署上 Istio 对架构进行了一些整合。你不再需要为控制平面部署 7 个 Pod；现在，你只需要部署一次就可以了。更有趣的是在 Envoy 项目的数据平面上所正在发生的：越来越多的第 7 层协议被添加到 Envoy 中。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/11image0151616431697613.jpg" alt="">&lt;/p>
&lt;p>服务网格增加了对更多协议的支持，比如 MongoDB、ZooKeeper、MySQL、Redis，而最新的协议是 Kafka。我看到 Kafka 社区现在正在进一步改进他们的协议，使其对服务网格更加友好。我们可以预料将会有更紧密的集成、更多的功能。最有可能的是，会有一些桥接的能力。你可以从服务中在你的应用本地做一个 HTTP 调用，而代理将在后台使用 Kafka。你可以在应用外部，在 sidecar 中针对 Kafka 协议进行转换和加密。&lt;/p>
&lt;p>另一个令人兴奋的发展是引入了 HTTP 缓存。现在 Envoy 可以进行 HTTP 缓存。你不必在你的应用中使用缓存客户端。所有这些都是在 sidecar 中透明地完成的。有了 tap 过滤器，你可以 tap 流量并获得流量的副本。最近，WebAssembly 的引入，意味着如果你要为 Envoy 编写一些自定义的过滤器，你不必用 C++ 编写，也不必编译整个 Envoy 运行时。你可以用 WebAssembly 写你的过滤器，然后在运行时进行部署。这些大多数还在进行中。它们不存在，说明数据平面和服务网格无意停止，仅支持 HTTP 和 gRPC。他们有兴趣支持更多的应用层协议，为你提供更多的功能，以实现更多的用例。最主要的是，随着 WebAssembly 的引入，你现在可以在 sidecar 中编写自定义逻辑。只要你没有在其中添加一些业务逻辑就可以了。&lt;/p>
&lt;h2 id="绑定趋势---apache-camel">绑定趋势 - Apache Camel&lt;/h2>
&lt;p>&lt;a href="https://camel.apache.org/">Apache Camel&lt;/a> 是一个用于集成的项目，它具有很多使用企业集成模式连接到不同系统的连接器。 比如 &lt;a href="https://camel.apache.org/releases/release-3.0.0/">Camel version 3&lt;/a> 就深度集成到了 Kubernetes 中，并且使用了我们到目前为止所讲的那些原语，比如 operator。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/7image0161616431694981.jpg" alt="">&lt;/p>
&lt;p>你可以在 Camel 中用 Java、JavaScript 或 YAML 等语言编写你的集成逻辑。最新的版本引入了一个 Camel operator，它在 Kubernetes 中运行并理解你的集成。当你写好 Camel 应用，将其部署到自定义资源中，operator 就知道如何构建容器或查找依赖项。根据平台的能力，不管是只用 Kubernetes，还是带有 Knative 的 Kubernetes，它都可以决定要使用的服务以及如何实现集成。在运行时之外有相当多的智能 &amp;ndash; 包括 operator &amp;ndash; 所有这些都非常快地发生。为什么我会说这是一个绑定的趋势？主要是因为 Apache Camel 提供的连接器的功能。这里有趣的一点是它如何与 Kubernetes 深度集成。&lt;/p>
&lt;h2 id="状态趋势---cloudstate">状态趋势 - Cloudstate&lt;/h2>
&lt;p>另一个我想讨论的项目是 &lt;a href="https://cloudstate.io/">Cloudstate&lt;/a> 和与状态相关的趋势。Cloudstate 是 Lightbend 的一个项目，主要致力于无服务器和功能驱动的开发。最新发布的版本，正在使用 sidecar 和 operator 与 Kubernetes 进行深度集成。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/8image0171616431996943.jpg" alt="">&lt;/p>
&lt;p>这个创意是，当你编写你的功能时，你在功能中要做的就是使用 gRPC 来获取状态并与之进行交互。整个状态管理在与其他 sidecar 群集的 sidear 中进行。它使你能够进行事件溯源、CQRS、键值查询、消息传递。&lt;/p>
&lt;p>从应用程序角度来看，你并不了解所有这些复杂性。你所做的只是调用一个本地的 sidecar，而 sidecar 会处理这些复杂的事情。它可以在后台使用两个不同的数据源。而且它拥有开发人员所需的所有有状态抽象。&lt;/p>
&lt;p>到目前为止，我们已经看到了云原生生态系统中的最新技术以及一些仍在进行中的开发。我们如何理解这一切？&lt;/p>
&lt;h2 id="多运行时微服务已经到来">多运行时微服务已经到来&lt;/h2>
&lt;p>如果你看微服务在 Kubernetes 上的样子，则将需要使用某些平台功能。此外，你将需要首先使用 Kubernetes 的功能进行生命周期管理。然后，很有可能透明地，你的服务会使用某些服务网格（例如 Envoy）来获得增强的网络功能，无论是流量路由、弹性、增强的安全性，甚至出于监控的目的。除此之外，根据你的场景和使用的工作负载可能需要 Dapr 或者 Knative。所有这些都代表了进程外附加的功能。剩下的就是编写业务逻辑，不是放在最上面而是作为一个单独的运行时来编写。未来的微服务很有可能将是由多个容器组成的这种多运行时。有些是透明的，有些则是非常明确的。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/6image0181616431996411.jpg" alt="">&lt;/p>
&lt;h2 id="智能的-sidecar-和愚蠢的管道">智能的 sidecar 和愚蠢的管道&lt;/h2>
&lt;p>如果更深入地看，那可能是什么样的，你可以使用一些高级语言编写业务逻辑。是什么并不重要，不必仅是 Java，因为你可以使用任何其他语言并在内部开发自定义逻辑。&lt;/p>
&lt;p>你的业务逻辑与外部世界的所有交互都是通过 sidecar 发生的，并与平台集成进行生命周期管理。它为外部系统执行网络抽象，为你提供高级的绑定功能和状态抽象。sidecar 是你不需要开发的东西。你可以从货架上拿到它。你用一点 YAML 或 JSON 配置它，然后就可以使用它。这意味着你可以轻松地更新 sidecar，因为它不再被嵌入到你的运行时。这使得打补丁、更新变得更加更容易。它为我们的业务逻辑启用了多语言运行时。&lt;/p>
&lt;h2 id="微服务之后是什么">微服务之后是什么？&lt;/h2>
&lt;p>这让我想到了最初的问题，微服务之后是什么？&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/6image0201616431995910.jpg" alt="">&lt;/p>
&lt;p>如果我们看下架构的发展历程，应用架构在很高的层面上是从单体应用开始的。然而微服务给我们提供了如何把一个单体应用拆分成独立的业务域的指导原则。之后又出现了无服务器和功能即服务（FaaS），我们说过可以按操作将其进一步拆分，从而实现极高的可扩展性-因为我们可以分别扩展每个操作。&lt;/p>
&lt;p>我想说的是 FaaS 并不是最好的模式 &amp;ndash; 因为功能并不是实现合理的复杂服务的最佳模式，在这种情况下，当多个操作必须与同一个数据集进行交互时，你希望它们驻留在一起。可能是多运行时（我把它称为 &lt;a href="https://www.infoq.com/articles/multi-runtime-microservice-architecture/">Mecha 架构&lt;/a>），在该架构中你将业务逻辑放在一个容器中，而所有与基础设施相关的关注点作为一个单独的容器存在。它们共同代表多运行时微服务。也许这是一个更合适的模型，因为它有更好的属性。&lt;/p>
&lt;p>你可以获得微服务的所有好处。仍然将所有域和所有限界上下文放在一处。你将所有的基础设施和分布式应用需求放在一个单独的容器中，并在运行时将它们组合在一起。大概，现在最接近这种模型的是 Dapr。他们正在遵循这种模型。如果你仅对网络方面感兴趣，那么可能使用 Envoy 也会接近这种模型。&lt;/p>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/03/30/21bilgin-ibryam15886810412341616480845087.jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>Bilgin Ibryam&lt;/strong> 是红帽公司的产品经理和前架构师、提交人，并且是 Apache 软件基金会的成员。他是开源布道者，经常写博客、发表演讲，是 &lt;a href="https://k8spatterns.io/">Kubernetes Patterns&lt;/a> 和 Camel Design Patterns 书籍的作者。Bilgin 目前的工作主要集中在分布式系统、事件驱动架构以及可重复的云原生应用开发模式和实践上。请关注他 @bibryam 了解未来类似主题的更新。&lt;/p></description></item><item><title>Kubernetes 源码解析 - Informer</title><link>https://atbug.com/kubernetes-source-code-how-informer-work/</link><pubDate>Sun, 16 Aug 2020 23:32:38 +0800</pubDate><guid>https://atbug.com/kubernetes-source-code-how-informer-work/</guid><description>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/wY8ZevIHIH7CD-fWGZecPQ">上篇&lt;/a>扒了 HPA 的源码，但是没深入细节，今天往细节深入。&lt;/p>
&lt;p>开局先祭出一张图：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/08/16/15975802542217.png" alt="">&lt;/p>
&lt;h2 id="为什么要有-informer">为什么要有 Informer？&lt;/h2>
&lt;p>Kubernetes 中的持久化数据保存在 etcd中，各个组件并不会直接访问 etcd，而是通过 api-server暴露的 RESTful 接口对集群进行访问和控制。&lt;/p>
&lt;p>资源的控制器（图中右侧灰色的部分）读取数据也并不会直接从 api-server 中获取资源信息（这样会增加 api-server 的压力），而是从其“本地缓存”中读取。这个“本地缓存”只是表象的存在，加上缓存的同步逻辑就是今天要是说的&lt;code>Informer&lt;/code>（灰色区域中的第一个蓝色块）所提供的功能。&lt;/p>
&lt;p>从图中可以看到 Informer 的几个组件：&lt;/p>
&lt;ul>
&lt;li>Reflector：与 &lt;code>api-server&lt;/code>交互，监听资源的变更。&lt;/li>
&lt;li>Delta FIFO Queue：增量的 FIFO 队列，保存 Reflector 监听到的资源变更（简单的封装）。&lt;/li>
&lt;li>Indexer：Informer 的本地缓存，FIFO 队列中的数据根据不同的变更类型，在该缓存中进行操作。
&lt;ul>
&lt;li>Local Store：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/wY8ZevIHIH7CD-fWGZecPQ">上篇&lt;/a> 提到了水平自动伸缩的控制器&lt;code>HorizontalController&lt;/code>，其构造方法就需要提供 &lt;code>Informer&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//pkg/controller/podautoscaler/horizontal.go
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">HorizontalController&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">scaleNamespacer&lt;/span> &lt;span class="nx">scaleclient&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ScalesGetter&lt;/span>
&lt;span class="nx">hpaNamespacer&lt;/span> &lt;span class="nx">autoscalingclient&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscalersGetter&lt;/span>
&lt;span class="nx">mapper&lt;/span> &lt;span class="nx">apimeta&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RESTMapper&lt;/span>
&lt;span class="nx">replicaCalc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ReplicaCalculator&lt;/span>
&lt;span class="nx">eventRecorder&lt;/span> &lt;span class="nx">record&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EventRecorder&lt;/span>
&lt;span class="nx">downscaleStabilisationWindow&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>
&lt;span class="nx">hpaLister&lt;/span> &lt;span class="nx">autoscalinglisters&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscalerLister&lt;/span>
&lt;span class="nx">hpaListerSynced&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">InformerSynced&lt;/span>
&lt;span class="nx">podLister&lt;/span> &lt;span class="nx">corelisters&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodLister&lt;/span>
&lt;span class="nx">podListerSynced&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">InformerSynced&lt;/span>
&lt;span class="nx">queue&lt;/span> &lt;span class="nx">workqueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RateLimitingInterface&lt;/span>
&lt;span class="nx">recommendations&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">][]&lt;/span>&lt;span class="nx">timestampedRecommendation&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewHorizontalController&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="nx">evtNamespacer&lt;/span> &lt;span class="nx">v1core&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EventsGetter&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">scaleNamespacer&lt;/span> &lt;span class="nx">scaleclient&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ScalesGetter&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">hpaNamespacer&lt;/span> &lt;span class="nx">autoscalingclient&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscalersGetter&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">mapper&lt;/span> &lt;span class="nx">apimeta&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RESTMapper&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">metricsClient&lt;/span> &lt;span class="nx">metricsclient&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MetricsClient&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="c1">//从HorizontalPodAutoscalerInformer 获取hpa 实例信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">hpaInformer&lt;/span> &lt;span class="nx">autoscalinginformers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscalerInformer&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="c1">//从PodInformer 中获取 pod 信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">podInformer&lt;/span> &lt;span class="nx">coreinformers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodInformer&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">resyncPeriod&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">downscaleStabilisationWindow&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">tolerance&lt;/span> &lt;span class="kt">float64&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">cpuInitializationPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">delayOfInitialReadinessStatus&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">HorizontalController&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">......&lt;/span>
&lt;span class="nx">hpaInformer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Informer&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">AddEventHandlerWithResyncPeriod&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="c1">//添加事件处理器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResourceEventHandlerFuncs&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">AddFunc&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">hpaController&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">enqueueHPA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">UpdateFunc&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">hpaController&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">updateHPA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">DeleteFunc&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">hpaController&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">deleteHPA&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">resyncPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="o">......&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">HorizontalPodAutoscalerInformer&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">Informer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SharedIndexInformer&lt;/span>
&lt;span class="nf">Lister&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscalerLister&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>HorizontalPodAutoscalerInformer&lt;/code>的实例化方法中就出现了今天的正主&lt;code>cache.NewSharedIndexInformer()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/informers/autoscaling/v1/horizontalpodautoscaler.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewFilteredHorizontalPodAutoscalerInformer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">client&lt;/span> &lt;span class="nx">kubernetes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Interface&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">namespace&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">resyncPeriod&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">indexers&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Indexers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">tweakListOptions&lt;/span> &lt;span class="nx">internalinterfaces&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TweakListOptionsFunc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SharedIndexInformer&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewSharedIndexInformer&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="c1">//用于 list 和 watch api-server 中的资源。比如用来创建 Reflector
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ListWatch&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">ListFunc&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ListOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">tweakListOptions&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">tweakListOptions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//使用 HPA API 获取 HPA资源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AutoscalingV1&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">HorizontalPodAutoscalers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">namespace&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">List&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">WatchFunc&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ListOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">watch&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Interface&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">tweakListOptions&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">tweakListOptions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//使用 HPA API 监控 HPA资源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AutoscalingV1&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">HorizontalPodAutoscalers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">namespace&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">Watch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">autoscalingv1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscaler&lt;/span>&lt;span class="p">{},&lt;/span>
&lt;span class="nx">resyncPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">indexers&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="初始化">初始化&lt;/h2>
&lt;h3 id="informer">Informer&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/index.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">Indexers&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">IndexFunc&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">IndexFunc&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">obj&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">([]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>实例化 Indexers &lt;code>cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/shared_informer.go
&lt;/span>&lt;span class="c1">// ListerWatcher 用于 list 和watch api-server 上的资源
&lt;/span>&lt;span class="c1">//runtime.Object要监控的资源的运行时对象
&lt;/span>&lt;span class="c1">//time.Duration同步的间隔时间
&lt;/span>&lt;span class="c1">//Indexers 提供不同资源的索引数据的信息查询方法，如 namespace =&amp;gt; MetaNamespaceIndexFunc
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewSharedIndexInformer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">lw&lt;/span> &lt;span class="nx">ListerWatcher&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">objType&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">defaultEventHandlerResyncPeriod&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">indexers&lt;/span> &lt;span class="nx">Indexers&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">SharedIndexInformer&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">realClock&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">clock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RealClock&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="nx">sharedIndexInformer&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sharedIndexInformer&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">processor&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sharedProcessor&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">clock&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">realClock&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="nx">indexer&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nf">NewIndexer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">DeletionHandlingMetaNamespaceKeyFunc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">indexers&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="c1">//初始化 Indexer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">listerWatcher&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">lw&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">objectType&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">objType&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">resyncCheckPeriod&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">defaultEventHandlerResyncPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">defaultEventHandlerResyncPeriod&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">defaultEventHandlerResyncPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">cacheMutationDetector&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nf">NewCacheMutationDetector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%T&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">objType&lt;/span>&lt;span class="p">)),&lt;/span>
&lt;span class="nx">clock&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">realClock&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">sharedIndexInformer&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="indexer">Indexer&lt;/h3>
&lt;p>&lt;code>Indexer&lt;/code>提供了本地缓存的实现：计算 key 和对数据进行控制（通过调用&lt;code>ThreadSafeStore&lt;/code>的接口）&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Indexer&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Store&lt;/span>
&lt;span class="nf">Index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">indexName&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">obj&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">([]&lt;/span>&lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">IndexKeys&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">indexName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">indexedValue&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">([]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">ListIndexFuncValues&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">indexName&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>
&lt;span class="nf">ByIndex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">indexName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">indexedValue&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">([]&lt;/span>&lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">GetIndexers&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">Indexers&lt;/span>
&lt;span class="nf">AddIndexers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">newIndexers&lt;/span> &lt;span class="nx">Indexers&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Indexer&lt;/code> 的创建&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/store.go
&lt;/span>&lt;span class="c1">//keyFunc：key 的生成规则
&lt;/span>&lt;span class="c1">//indexers：提供了索引资源的不同信息的访问方法，如用于查询命名空间的 namespace =&amp;gt; MetaNamespaceIndexFunc
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewIndexer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">keyFunc&lt;/span> &lt;span class="nx">KeyFunc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">indexers&lt;/span> &lt;span class="nx">Indexers&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">Indexer&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">cacheStorage&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nf">NewThreadSafeStore&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">indexers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Indices&lt;/span>&lt;span class="p">{}),&lt;/span>
&lt;span class="nx">keyFunc&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">keyFunc&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="threadsafestore">&lt;code>ThreadSafeStore&lt;/code>&lt;/h4>
&lt;p>ThreadSafeStore提供了对存储的并发访问接口&lt;/p>
&lt;p>注意事项：不能修改Get或List返回的任何内容，因为它不仅会破坏线程安全，还会破坏索引功能。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/thread_safe_store.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewThreadSafeStore&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">indexers&lt;/span> &lt;span class="nx">Indexers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">indices&lt;/span> &lt;span class="nx">Indices&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">ThreadSafeStore&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">threadSafeMap&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">items&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">interface&lt;/span>&lt;span class="p">{}{},&lt;/span>
&lt;span class="nx">indexers&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">indexers&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">indices&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">indices&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">threadSafeMap&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">lock&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RWMutex&lt;/span>
&lt;span class="nx">items&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">interface&lt;/span>&lt;span class="p">{}&lt;/span> &lt;span class="c1">//key =&amp;gt; value
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">indexers&lt;/span> &lt;span class="nx">Indexers&lt;/span> &lt;span class="c1">//value 的信息的访问方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">indices&lt;/span> &lt;span class="nx">Indices&lt;/span> &lt;span class="c1">//索引
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="reflector">Reflector&lt;/h3>
&lt;p>&lt;code>Reflector&lt;/code>通过&lt;code> ListerWatcher&lt;/code>（API）与&lt;code>api-server&lt;/code>交互，对资源进行监控。将资源实例的创建、更新、删除等时间封装后保存在&lt;code>Informer&lt;/code>的FIFO 队列中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/reflector.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewReflector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">lw&lt;/span> &lt;span class="nx">ListerWatcher&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expectedType&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">store&lt;/span> &lt;span class="nx">Store&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">resyncPeriod&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Reflector&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">NewNamedReflector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">naming&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetNameFromCallsite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">internalPackages&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">lw&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expectedType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">store&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">resyncPeriod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// NewNamedReflector same as NewReflector, but with a specified name for logging
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewNamedReflector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lw&lt;/span> &lt;span class="nx">ListerWatcher&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expectedType&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">store&lt;/span> &lt;span class="nx">Store&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">resyncPeriod&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Reflector&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">r&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">Reflector&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">listerWatcher&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">lw&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">store&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">store&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">//FIFO队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">period&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">resyncPeriod&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">resyncPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">clock&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">clock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RealClock&lt;/span>&lt;span class="p">{},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">setExpectedType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expectedType&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">r&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加同步事件监听器">添加同步事件监听器&lt;/h3>
&lt;p>通过&lt;code>sharedIndexInformer#AddEventHandlerWithResyncPeriod()&lt;/code>注册事件监听器。&lt;/p>
&lt;p>以前面的 HorizontalController为例，创建 informer 的时候添加了三个处理方法：&lt;code>AddFunc&lt;/code>、&lt;code>UpdateFunc&lt;/code>、&lt;code>DeleteFunc&lt;/code>。这三个方法的实现是将对应的元素的 key（固定格式 &lt;code>namespace/name&lt;/code>）从&lt;code> workequeue&lt;/code>中进行入队、出队的操作。（资源控制器监听了该 &lt;code>workqueue&lt;/code>）&lt;/p>
&lt;h2 id="运行">运行&lt;/h2>
&lt;h3 id="controller-manager">&lt;code>controller-manager&lt;/code>&lt;/h3>
&lt;p>在通过&lt;code>InformerFactory&lt;/code>创建&lt;code>Informer&lt;/code>完成后，都会将新建的&lt;code> Informer&lt;/code>加入到&lt;code>InformerFactory&lt;/code>的一个&lt;code>map&lt;/code>中。&lt;/p>
&lt;p>在&lt;code>controller-manager&lt;/code>在完成所有的控制器（各种&lt;code>Controller&lt;/code>，包括 CRD）后，会调用&lt;code>InformerFactory#Start()&lt;/code>来启动&lt;code>InformerFactory&lt;/code>的&lt;code>map&lt;/code>中的所有&lt;code> Informer&lt;/code>（调用&lt;code>Informer#Run()&lt;/code>方法）&lt;/p>
&lt;h3 id="sharedindexinformerrun">&lt;code>sharedIndexInformer#Run()&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/shared_informer.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sharedIndexInformer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stopCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">utilruntime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleCrash&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">//创建一个增量的 FIFO队列：DeltaFIFO
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fifo&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">NewDeltaFIFO&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">MetaNamespaceKeyFunc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">indexer&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">cfg&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">Config&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Queue&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">fifo&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">ListerWatcher&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">listerWatcher&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">ObjectType&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">objectType&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">FullResyncPeriod&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">resyncCheckPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">RetryOnError&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">ShouldResync&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">processor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">shouldResync&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Process&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HandleDeltas&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//启动前的初始化，创建 Controller
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">startedLock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">startedLock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">controller&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">cfg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">controller&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">controller&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">clock&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clock&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">started&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}()&lt;/span>
&lt;span class="nx">processorStopCh&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">wait&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Group&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// Wait for Processor to stop
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">defer&lt;/span> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">processorStopCh&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Tell Processor to stop
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StartWithChannel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">processorStopCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cacheMutationDetector&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Run&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StartWithChannel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">processorStopCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">processor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">run&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">//退出时的状态清理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">defer&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">startedLock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">startedLock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stopped&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span> &lt;span class="c1">// Don&amp;#39;t want any new listeners
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}()&lt;/span>
&lt;span class="c1">//实行控制逻辑
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">controller&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stopCh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="controllerrun">&lt;code>controller#Run()&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/controller.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">controller&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stopCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">utilruntime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleCrash&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">stopCh&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}()&lt;/span>
&lt;span class="c1">//创建一个 Reflector，用于从 api-server list 和 watch 资源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">NewReflector&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ListerWatcher&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectType&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Queue&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FullResyncPeriod&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ShouldResync&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ShouldResync&lt;/span>
&lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clock&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clock&lt;/span>
&lt;span class="c1">//为 controller 指定 Reflector
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reflectorMutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reflector&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">r&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reflectorMutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="nx">wait&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Group&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">//执行Reflector#Run()：会启动一个goroutine开始监控资源，将 watch 到的数据写入到queue（FIFO 队列）中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StartWithChannel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stopCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Run&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">//持续从 queue（FIFO 队列） 获取数据并进行处理，处理的逻辑在sharedIndexInformer#HandleDeltas()
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">wait&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Until&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">processLoop&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stopCh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="sharedindexinformerhandledeltas">&lt;code>sharedIndexInformer#HandleDeltas()&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/client-go/tools/cache/shared_informer.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sharedIndexInformer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">HandleDeltas&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">obj&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">blockDeltas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">blockDeltas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">// from oldest to newest
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">d&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="nx">Deltas&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//循环处理 FIFO 队列中取出的资源实例
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">switch&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Type&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">Sync&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Added&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Updated&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1">//同步（后面详细解读）、新增、更新事件
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">isSync&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Type&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">Sync&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cacheMutationDetector&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddObject&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">exists&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">indexer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">exists&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">indexer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//如果 indexer 中已经存在，更掉用 update 方法进行更新
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//更新成功后发送“更新”通知：包含了新、旧资源实例
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">processor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">distribute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">updateNotification&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">oldObj&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">old&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">newObj&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="nx">isSync&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//如果 indexer 中没有该资源实例，则放入 indexer 中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">indexer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//添加成功后，发送“新增”通知：包含了新加的资源实例
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">processor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">distribute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">addNotification&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">newObj&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="nx">isSync&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">Deleted&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1">//删除事件
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">indexer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Delete&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="c1">//从 indexer 中删除
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//删除成功后，发送“删除通知”：包含了删除的资源实例
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">processor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">distribute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">deleteNotification&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">oldObj&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Informer 的实现不算复杂，却在 Kubernetes 中很常见，每种资源的控制也都通过 Informer 来获取&lt;code>api-server&lt;/code>的资源实例的变更。&lt;/p></description></item><item><title>Kubernetes 源码解析 - HPA 水平自动伸缩如何工作</title><link>https://atbug.com/kubernetes-source-code-how-hpa-work/</link><pubDate>Sat, 15 Aug 2020 02:09:37 +0800</pubDate><guid>https://atbug.com/kubernetes-source-code-how-hpa-work/</guid><description>
&lt;p>HPA - Horizontal Pod Autoscaler 的缩写，Pod 水平自动伸缩。通过对 Pod 负载的监控，来自动增加或者减少 Pod 的副本数量。&lt;/p>
&lt;p>从字面意思来看，其主要包含了两部分：&lt;/p>
&lt;ul>
&lt;li>监控 Pod 的负载&lt;/li>
&lt;li>控制 Pod 的副本数量&lt;/li>
&lt;/ul>
&lt;p>那具体是如何实现的呢？以下基于1.17 源码，来分析下 HPA 如何工作。&lt;/p>
&lt;p>&lt;strong>注意：文章中的代码在源码的基础上进行了精简：删掉了注释、序列化等信息，或保留了部分核心代码，加上新的注释。&lt;/strong>&lt;/p>
&lt;h2 id="资源">资源&lt;/h2>
&lt;p>HPA 的资源是&lt;code>HorizontalPodAutoscaler&lt;/code>，在&lt;code>v1&lt;/code>版本中，只支持基于 CPU 指标的计算；在&lt;code>v2beta2&lt;/code>版本中加入了基于内存和自定义指标的计算。&lt;/p>
&lt;h3 id="v1">v1&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/api/autoscaling/v1/types.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">HorizontalPodAutoscaler&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TypeMeta&lt;/span>
&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>
&lt;span class="nx">Spec&lt;/span> &lt;span class="nx">HorizontalPodAutoscalerSpec&lt;/span>
&lt;span class="nx">Status&lt;/span> &lt;span class="nx">HorizontalPodAutoscalerStatus&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">HorizontalPodAutoscalerSpec&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ScaleTargetRef&lt;/span> &lt;span class="nx">CrossVersionObjectReference&lt;/span> &lt;span class="c1">//监控的目标资源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">MinReplicas&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span> &lt;span class="c1">//最小副本数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">MaxReplicas&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">//最大副本数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">TargetCPUUtilizationPercentage&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span> &lt;span class="c1">//触发调整的CPU 使用率
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="v2">v2&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//staging/src/k8s.io/api/autoscaling/v2beta2/types.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">HorizontalPodAutoscaler&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TypeMeta&lt;/span>
&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>
&lt;span class="nx">Spec&lt;/span> &lt;span class="nx">HorizontalPodAutoscalerSpec&lt;/span>
&lt;span class="nx">Status&lt;/span> &lt;span class="nx">HorizontalPodAutoscalerStatus&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">HorizontalPodAutoscalerSpec&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ScaleTargetRef&lt;/span> &lt;span class="nx">CrossVersionObjectReference&lt;/span> &lt;span class="c1">//监控的目标资源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">MinReplicas&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>
&lt;span class="nx">MaxReplicas&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;span class="nx">Metrics&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">MetricSpec&lt;/span> &lt;span class="c1">//新加入的自定义指标
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">MetricSpec&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Type&lt;/span> &lt;span class="nx">MetricSourceType&lt;/span> &lt;span class="c1">//指标源的类型：Object（基于某个对象）、Pods（基于pod 数）、Resource（基于资源使用计算，比如v1 版本中cpu）、External（基于外部的指标）。对应 MetricsClient 接口的四个方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Object&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ObjectMetricSource&lt;/span> &lt;span class="c1">//对应 Object 类型的指标源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Pods&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PodsMetricSource&lt;/span> &lt;span class="c1">//对应 Pod 类型的指标源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Resource&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ResourceMetricSource&lt;/span> &lt;span class="c1">//对应 Resource 类型的指标源
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">External&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ExternalMetricSource&lt;/span> &lt;span class="c1">//对应 External 类型的指标源
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">ObjectMetricSource&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">DescribedObject&lt;/span> &lt;span class="nx">CrossVersionObjectReference&lt;/span> &lt;span class="c1">//目标对象
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Target&lt;/span> &lt;span class="nx">MetricTarget&lt;/span> &lt;span class="c1">//指定指标的目标值、平均值或者平均使用率
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Metric&lt;/span> &lt;span class="nx">MetricIdentifier&lt;/span> &lt;span class="c1">//指标标识：名字、label选择器
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">PodsMetricSource&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Metric&lt;/span> &lt;span class="nx">MetricIdentifier&lt;/span>
&lt;span class="nx">Target&lt;/span> &lt;span class="nx">MetricTarget&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">ResourceMetricSource&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ResourceName&lt;/span>
&lt;span class="nx">Target&lt;/span> &lt;span class="nx">MetricTarget&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">ExternalMetricSource&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Metric&lt;/span> &lt;span class="nx">MetricIdentifier&lt;/span>
&lt;span class="nx">Target&lt;/span> &lt;span class="nx">MetricTarget&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">MetricTarget&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Type&lt;/span> &lt;span class="nx">MetricTargetType&lt;/span> &lt;span class="c1">//类型：Utilization、Value、AverageValue
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Value&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">resource&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Quantity&lt;/span>
&lt;span class="nx">AverageValue&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">resource&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Quantity&lt;/span>
&lt;span class="nx">AverageUtilization&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="控制器-horizontalcontroller">控制器 &lt;code>HorizontalController&lt;/code>&lt;/h2>
&lt;p>&lt;code>HorizontalController&lt;/code>被通过 key &lt;code>horizontalpodautoscaling&lt;/code> 加入到 controller manager 中。用来控制&lt;code>HorizontalPodAutoscaler&lt;/code>实例。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">///cmd/kube-controller-manager/app/controllermanager.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewControllerInitializers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">loopMode&lt;/span> &lt;span class="nx">ControllerLoopMode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">InitFunc&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="nx">controllers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;horizontalpodautoscaling&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">startHPAController&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="获取负载指标">获取负载指标&lt;/h3>
&lt;p>既然 Pod 副本数量的计算是基于 Pod 的负载情况，那边需要途径获取负载数据，这个途径就是&lt;code>MetricsClient&lt;/code>。&lt;/p>
&lt;p>&lt;code>MetricsClient&lt;/code>有两种实现：REST 方式和传统（Legacy）方式，分别是&lt;code>restMetricsClient&lt;/code>和&lt;code>HeapsterMetricsClient&lt;/code>。一个是REST 实现以支持自定义的指标；一个是传统的 Heapster 指标（heapster 已经从 1.13 版本开始被废弃了）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//cmd/kube-controller-manager/app/autoscaling.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">startHPAController&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">ControllerContext&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Handler&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AvailableResources&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">GroupVersionResource&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Group&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;autoscaling&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Version&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;v1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Resource&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;horizontalpodautoscalers&amp;#34;&lt;/span>&lt;span class="p">}]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ComponentConfig&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HPAController&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscalerUseRESTClients&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// use the new-style clients if support for custom metrics is enabled
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nf">startHPAControllerWithRESTClient&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">startHPAControllerWithLegacyClient&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="控制器逻辑horizontalcontrollerrun">控制器逻辑&lt;code>HorizontalController#Run()&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//pkg/controller/podautoscaler/horizontal.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">HorizontalController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stopCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">utilruntime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleCrash&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ShutDown&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Infof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Starting HPA controller&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Infof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Shutting down HPA controller&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 等待 informer 完成HorizontalPodAutoscaler相关事件的同步
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WaitForNamedCacheSync&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;HPA&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stopCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">hpaListerSynced&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podListerSynced&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// start a single worker (we may wish to start more in the future)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//执行 worker 逻辑，直到收到退出指令
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">go&lt;/span> &lt;span class="nx">wait&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Until&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">worker&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stopCh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">stopCh&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>worker&lt;/code>的核心是从工作队列中获取一个 key（格式为：namespace/name），然后对 key 进行 reconcile（这个词是Kubernetes 的核心，翻译为“调和”、“和解”。个人更喜欢“调整”，即&lt;strong>将实例的状态调整为期望的状态&lt;/strong>。此处，对于 hpa 的实例的每个事件，都会按照特定的逻辑调整目标实例的 Pod 的副本数量。）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//pkg/controller/podautoscaler/horizontal.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">HorizontalController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">worker&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">processNextWorkItem&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Infof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;horizontal pod autoscaler controller worker shutting down&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">HorizontalController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">processNextWorkItem&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">quit&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Get&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">quit&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">deleted&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">reconcileKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">utilruntime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandleError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">deleted&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddRateLimited&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对 key 进行 reconcile 的调用栈：&lt;code>HorizontalController#reconcileKey -&amp;gt; HorizontalController#reconcileAutoscaler -&amp;gt; HorizontalController#computeReplicasForMetrics -&amp;gt; ScaleInterface#Update&lt;/code>&lt;/p>
&lt;p>简单来说就是先从&lt;code>Informer&lt;/code>中拿到 key 对应的&lt;code>HorizontalPodAutoscaler&lt;/code>资源实例；然后通过&lt;code>HorizontalPodAutoscaler&lt;/code>实例中的信息，检查目标资源的Pod 负载以及当前的副本数，得到期望的 Pod 副本数；最终通过 Scale API 来调整 Pod 的副本数。最后会将调整的原因、计算的结果等信息写入&lt;code>HorizontalPodAutoscaler&lt;/code>实例的 condition 中。&lt;/p>
&lt;h3 id="计算期望的副本数">计算期望的副本数&lt;/h3>
&lt;p>对每个指标进行计算，都会得到建议的副本数，然后最大的那个就是最终的期望副本数。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//pkg/controller/podautoscaler/horizontal.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">HorizontalController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">computeReplicasForMetrics&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">hpa&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">autoscalingv2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HorizontalPodAutoscaler&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">scale&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">autoscalingv1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Scale&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">metricSpecs&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">autoscalingv2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MetricSpec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">replicas&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">metric&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">statuses&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">autoscalingv2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MetricStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timestamp&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Time&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">......&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">metricSpec&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">metricSpecs&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">replicaCountProposal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">metricNameProposal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timestampProposal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">condition&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">computeReplicasForMetric&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">hpa&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">metricSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">specReplicas&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">statusReplicas&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">selector&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">statuses&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">invalidMetricsCount&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">invalidMetricCondition&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">condition&lt;/span>
&lt;span class="nx">invalidMetricError&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">invalidMetricsCount&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">replicas&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">replicaCountProposal&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">replicas&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">timestamp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">timestampProposal&lt;/span>
&lt;span class="nx">replicas&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">replicaCountProposal&lt;/span>
&lt;span class="nx">metric&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">metricNameProposal&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="o">......&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>#computeStatusForObjectMetric&lt;/code>（注意这个方法名少了个 &amp;ldquo;s&amp;rdquo;）使用&lt;code>MetricsClient&lt;/code>得到指定指标的值。&lt;/p>
&lt;p>这个流程的细节还可以继续深挖，但到此已够我们理解 HPA​ 的实现方式了。​&lt;/p></description></item><item><title>Tekton 的工作原理</title><link>https://atbug.com/how-tekton-works/</link><pubDate>Sat, 23 May 2020 22:47:14 +0800</pubDate><guid>https://atbug.com/how-tekton-works/</guid><description>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/24/tekton.jpeg" alt="tekton">&lt;/p>
&lt;p>&lt;em>这篇文章是基于 Tekton Pipeline 的最新版本&lt;code>v0.12.1&lt;/code>版本。&lt;/em>&lt;/p>
&lt;p>快速入门请参考：&lt;a href="https://atbug.com/tekton-trigger-practice/">云原生 CICD: Tekton Pipeline 实战&lt;/a> ，&lt;em>实战是基于版本 v0.10.x&lt;/em>。&lt;/p>
&lt;h2 id="pipeline-crd-与核心资源的关系">Pipeline CRD 与核心资源的关系&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ k api-resources --api-group&lt;span class="o">=&lt;/span>tekton.dev
NAME SHORTNAMES APIGROUP NAMESPACED KIND
clustertasks tekton.dev &lt;span class="nb">false&lt;/span> ClusterTask
conditions tekton.dev &lt;span class="nb">true&lt;/span> Condition
pipelineresources tekton.dev &lt;span class="nb">true&lt;/span> PipelineResource
pipelineruns pr,prs tekton.dev &lt;span class="nb">true&lt;/span> PipelineRun
pipelines tekton.dev &lt;span class="nb">true&lt;/span> Pipeline
taskruns tr,trs tekton.dev &lt;span class="nb">true&lt;/span> TaskRun
tasks tekton.dev &lt;span class="nb">true&lt;/span> Task
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tekton Pipelines提供了上面的CRD，其中部分CRD与k8s core中资源相对应&lt;/p>
&lt;ul>
&lt;li>Task =&amp;gt; Pod&lt;/li>
&lt;li>Task.Step =&amp;gt; Container&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/23/15902164552270.jpg" alt="">&lt;/p>
&lt;h2 id="工作原理">工作原理&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/23/15902280074872.jpg" alt="">
(图片来自)&lt;/p>
&lt;p>Tekton Pipeline 是基于 Knative 的实现，pod &lt;code>tekton-pipelines-controller&lt;/code> 中有两个 &lt;a href="https://knative.dev/docs/eventing/samples/writing-receive-adapter-source/03-controller/">Knative Controller&lt;/a>的实现：PipelineRun 和 TaskRun。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/23/15902270934199.jpg" alt="">&lt;/p>
&lt;h3 id="task的执行顺序">Task的执行顺序&lt;/h3>
&lt;p>PipelineRun Controller 的 &lt;code>#reconcile()&lt;/code>方法，监控到有&lt;code>PipelineRun&lt;/code>被创建。然后从&lt;code>PipelineSpec&lt;/code>的 tasks 列表，构建出一个图（&lt;code>graph&lt;/code>），用于描述&lt;code>Pipeline&lt;/code>中 Task 间的依赖关系。依赖关系是通过&lt;code>runAfter&lt;/code>和&lt;code>from&lt;/code>，进而控制&lt;a href="#Task%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">Task的执行顺序&lt;/a>。与此同时，准备&lt;code>PipelineRun&lt;/code>中定义的&lt;code>PipelineResources&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// Node represents a Task in a pipeline.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">Node&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Task represent the PipelineTask in Pipeline
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Task&lt;/span> &lt;span class="nx">Task&lt;/span>
&lt;span class="c1">// Prev represent all the Previous task Nodes for the current Task
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Prev&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Node&lt;/span>
&lt;span class="c1">// Next represent all the Next task Nodes for the current Task
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Next&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Node&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Graph represents the Pipeline Graph
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">Graph&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//Nodes represent map of PipelineTask name to Node in Pipeline Graph
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Nodes&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Node&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">Build&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">tasks&lt;/span> &lt;span class="nx">Tasks&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Graph&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>PipelineRun&lt;/code>中定义的参数（parameters）也会注入到&lt;code>PipelineSpec&lt;/code>中：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">pipelineSpec&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">resources&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ApplyParameters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pipelineSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来就是调用&lt;code>dag#GetSchedulable()&lt;/code>方法，获取未完成（通过Task状态判断）的 Task 列表；&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">GetSchedulable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Graph&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">doneTasks&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为 Task A 创建&lt;code>TaskRun&lt;/code>，假如&lt;code>Task&lt;/code>配置了&lt;code>Condition&lt;/code>。会先为 condition创建一个&lt;code>TaskRun&lt;/code>，只有在 condition 的&lt;code>TaskRun&lt;/code>运行成功，才会运行 A 的&lt;code>TaskRun&lt;/code>；否则就跳过。&lt;/p>
&lt;h3 id="step的执行顺序">Step的执行顺序&lt;/h3>
&lt;p>这一部分篇幅较长，之前的文章 &lt;a href="https://atbug.com/control-process-order-of-pod-containers/">控制 Pod 内容器的启动顺序&lt;/a> 中提到过。&lt;/p>
&lt;p>这里补充一下&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api">Kubernetes Downward API&lt;/a>的使用，Kubernetes Downward API的引入，控制着 &lt;code>Task&lt;/code> 的第一个 &lt;code>Step&lt;/code> 在何时执行。&lt;/p>
&lt;p>&lt;code>TaskRun&lt;/code> Controller 在 reconciling 的过程中，在相应的 &lt;code>Pod&lt;/code> 状态变为&lt;code>Running&lt;/code>时，会将&lt;code>tekton.dev/ready=READY&lt;/code>写入到 Pod 的 annotation 中，来通知第一个&lt;code>Step&lt;/code>的执行。&lt;/p>
&lt;p>Pod的部分内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">wait_file&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/downward/ready&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">wait_file_content&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">post_file&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/tools/0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">termination_path&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/termination&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">entrypoint&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/ko-app/git-init&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- --&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">url&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ssh://git@gitlab.nip.io:8022/addozhang/logan-pulse.git&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">revision&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">develop&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">path&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/workspace/git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/tools/entrypoint&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/tekton/downward&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-internal-downward&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">downwardAPI&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">defaultMode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">420&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">items&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">fieldRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">fieldPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">metadata.annotations[&amp;#39;tekton.dev/ready&amp;#39;]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ready&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-internal-downward&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对原生的排序step container进一步处理：启动命令使用&lt;code>entrypoint&lt;/code>提供，并设置执行参数：&lt;/p>
&lt;p>&lt;code>entrypoint.go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">orderContainers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">entrypointImage&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">steps&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">results&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">v1alpha1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TaskResult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">initContainer&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;place-tools&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Image&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">entrypointImage&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Command&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;cp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;/ko-app/entrypoint&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">entrypointBinary&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="nx">VolumeMounts&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeMount&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">toolsMount&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">steps&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;No steps specified&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">steps&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">argsForEntrypoint&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">argsForEntrypoint&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="c1">// First step waits for the Downward volume file.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="s">&amp;#34;-wait_file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">downwardMountPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">downwardMountReadyFile&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="s">&amp;#34;-wait_file_content&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// Wait for file contents, not just an empty file.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// Start next step.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="s">&amp;#34;-post_file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mountPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)),&lt;/span>
&lt;span class="s">&amp;#34;-termination_path&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">terminationPath&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="c1">// All other steps wait for previous file, write next file.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">argsForEntrypoint&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="s">&amp;#34;-wait_file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mountPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)),&lt;/span>
&lt;span class="s">&amp;#34;-post_file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mountPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)),&lt;/span>
&lt;span class="s">&amp;#34;-termination_path&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">terminationPath&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="自动运行的容器">自动运行的容器&lt;/h3>
&lt;p>这些自动运行的容器作为 pod 的&lt;code>initContainer&lt;/code>会在 step 容器运行之前运行&lt;/p>
&lt;h4 id="credential-initializer">&lt;code>credential-initializer&lt;/code>&lt;/h4>
&lt;p>用于将 &lt;code>ServiceAccount&lt;/code> 的相关secrets持久化到容器的文件系统中。比如 ssh 相关秘钥、config文件以及know_hosts文件；docker registry 相关的凭证则会被写入到 docker 的配置文件中。&lt;/p>
&lt;h4 id="working-dir-initializer">&lt;code>working-dir-initializer&lt;/code>&lt;/h4>
&lt;p>收集&lt;code>Task&lt;/code>内的各个&lt;code>Step&lt;/code>的&lt;code>workingDir&lt;/code>配置，初始化目录结构&lt;/p>
&lt;h4 id="place-scripts">&lt;code>place-scripts&lt;/code>&lt;/h4>
&lt;p>假如&lt;code>Step&lt;/code>使用的是&lt;code>script&lt;/code>配置（与command+args相对），这个容器会将脚本代码（&lt;code>script&lt;/code>字段的内容）持久化到&lt;code>/tekton/scripts&lt;/code>目录中。&lt;/p>
&lt;p>注：所有的脚本会自动加上&lt;code>#!/bin/sh\nset -xe\n&lt;/code>，所以&lt;code>script&lt;/code>字段里就不必写了。&lt;/p>
&lt;h4 id="place-tools">&lt;code>place-tools&lt;/code>&lt;/h4>
&lt;p>将&lt;code>entrypoint&lt;/code>的二进制文件，复制到&lt;code>/tekton/tools/entrypoint&lt;/code>.&lt;/p>
&lt;h3 id="taskstep间的数据传递">Task/Step间的数据传递&lt;/h3>
&lt;p>针对不同的数据，有多种不同的选择。比如&lt;code>Workspace&lt;/code>、&lt;code>Result&lt;/code>、&lt;code>PipelineResource&lt;/code>。对于由于&lt;code>Task&lt;/code>的执行是通过&lt;code>Pod&lt;/code>来完成的，而&lt;code>Pod&lt;/code>会调度到不同的节点上。因此&lt;code>Task&lt;/code>间的数据传递，需要用到持久化的卷。&lt;/p>
&lt;p>而&lt;code>Step&lt;/code>作为&lt;code>Pod&lt;/code>中的容器来运行，&lt;/p>
&lt;h4 id="workspace">Workspace&lt;/h4>
&lt;p>工作区，可以理解为一个挂在到容器上的卷，用于文件的传递。&lt;/p>
&lt;h5 id="persistentvolumeclaim">&lt;code>persistentVolumeClaim&lt;/code>&lt;/h5>
&lt;p>引用已存在&lt;code>persistentVolumeClaim&lt;/code>卷（volume）。这种工作空间，可多次使用，需要先进行创建。比如 Java 项目的 &lt;code>maven&lt;/code>，编译需要本地依赖库，这样可以节省每次编译都要下载依赖包的成本。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">m2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeClaim&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">claimName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">m2-pv-claim&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">m2-pv&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">local&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storageClassName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manual&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capacity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">10Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteMany&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/data/.m2&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolumeClaim&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">m2-pv-claim&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storageClassName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manual&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># volumeName: m2-pv&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteMany&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">10Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="volumeclaimtemplate">&lt;code>volumeClaimTemplate&lt;/code>&lt;/h5>
&lt;p>为每个&lt;code>PipelineRun&lt;/code>或者&lt;code>TaskRun&lt;/code>创建&lt;code>PersistentVolumeClaim&lt;/code>卷（volume）的模板。比如一次构建需要从 git 仓库克隆代码，而针对不同的流水线代码仓库是不同的。这里就会用到&lt;code>volumeClaimTemplate&lt;/code>，为每次构建创建一个&lt;code>PersistentVolumeClaim&lt;/code>卷。（从0.12.0开始）&lt;/p>
&lt;p>生命周期同&lt;code>PipelineRun&lt;/code>或者&lt;code>TaskRun&lt;/code>，运行之后释放。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeClaimTemplate&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteMany&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">1Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相较于&lt;code>persistantVolumeClain&lt;/code>类型的workspace，&lt;code>volumeClaimTemplate&lt;/code>不需要在每次在&lt;code>PipelineRun&lt;/code>完成后清理工作区；并发情况下可能会出现问题。&lt;/p>
&lt;h5 id="emptydir">&lt;code>emptyDir&lt;/code>&lt;/h5>
&lt;p>引用&lt;code>emptyDir&lt;/code>卷，跟随&lt;code>Task&lt;/code>生命周期的临时目录。适合在&lt;code>Task&lt;/code>的&lt;code>Step&lt;/code>间共享数据，无法在多个&lt;code>Task&lt;/code>间共享。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">temp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="configmap">&lt;code>configMap&lt;/code>&lt;/h5>
&lt;p>引用一个&lt;code>configMap&lt;/code>卷，将&lt;code>configMap&lt;/code>卷作为工作区，有如下限制：&lt;/p>
&lt;ul>
&lt;li>挂载的卷是&lt;code>只读&lt;/code>的&lt;/li>
&lt;li>需要提前创建&lt;code>configMap&lt;/code>&lt;/li>
&lt;li>&lt;code>configMap&lt;/code>的&lt;a href="https://github.com/kubernetes/kubernetes/blob/f16bfb069a22241a5501f6fe530f5d4e2a82cf0e/pkg/apis/core/validation/validation.go#L5042">大小限制为1MB（K8s的限制）&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>使用场景，比如使用&lt;code>maven&lt;/code>编译Java项目，配置文件&lt;code>settings.xml&lt;/code>可以使用&lt;code>configMap&lt;/code>作为工作区&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">workspaces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maven-settings&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">configmap&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maven-settings&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="secret">&lt;code>secret&lt;/code>&lt;/h5>
&lt;p>用于引用&lt;code>secret&lt;/code>卷，同&lt;code>configMap&lt;/code>工作区一样，也有限制：&lt;/p>
&lt;ul>
&lt;li>挂载的卷是&lt;code>只读&lt;/code>的&lt;/li>
&lt;li>需要提前创建&lt;code>secret&lt;/code>&lt;/li>
&lt;li>&lt;code>secret&lt;/code>的&lt;a href="https://github.com/kubernetes/kubernetes/blob/f16bfb069a22241a5501f6fe530f5d4e2a82cf0e/pkg/apis/core/validation/validation.go#L5042">大小限制为1MB（K8s的限制）&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="result">Result&lt;/h4>
&lt;p>&lt;code>results&lt;/code>字段可以用来配置多个文件用来存储&lt;code>Tasks&lt;/code>的执行结果，这些文件保存在&lt;code>/tekton/results&lt;/code>目录中。&lt;/p>
&lt;p>在&lt;code>Pipeline&lt;/code>中，可以通过&lt;code>tasks.[task-nanme].results.[result-name]&lt;/code>注入到其他&lt;code>Task&lt;/code>的参数中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton.dev/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Task&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">print-date&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">A simple task that prints the date&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">results&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">current-date-unix-timestamp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">The current date in unix timestamp format&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">current-date-human-readable&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">The current date in human readable format&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">print-date-unix-timestamp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bash:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> #!/usr/bin/env bash
&lt;/span>&lt;span class="sd"> date +%s | tee $(results.current-date-unix-timestamp.path)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">print-date-humman-readable&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bash:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> #!/usr/bin/env bash
&lt;/span>&lt;span class="sd"> date | tee $(results.current-date-human-readable.path)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton.dev/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PipelineRun&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pass-date&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pipelineSpec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tasks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">print-date&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">taskRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">print-date&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">read-date&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runAfter&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#配置执行顺序&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">print-date&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">taskSpec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">current-date-unix-timestamp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">string&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">current-date-human-readable&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">string&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">read&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> echo $(params.current-date-unix-timestamp)
&lt;/span>&lt;span class="sd"> echo $(params.current-date-human-readable)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">current-date-unix-timestamp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">$(tasks.print-date.results.current-date-unix-timestamp)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 注入参数&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">current-date-human-readable&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">$(tasks.print-date.results.current-date-human-readable)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 注入参数 &lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">┌──────Logs(tekton-pipelines/pass-date-read-date-rhlf2-pod-9b2sk)[all] ────────── │
│ place-scripts stream closed ││ step-read 1590242170 │
│ step-read Sat May 23 13:56:10 UTC 2020 ││ step-read + echo 1590242170 │
│ step-read + echo Sat May 23 13:56:10 UTC 2020 │
│ place-tools stream closed │
│ step-read stream closed │
│
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="pipelineresource">PipelineResource&lt;/h4>
&lt;p>&lt;code>PipelineResource&lt;/code>在最后提，因为目前只是&lt;code>alpha&lt;/code>版本，何时会进入&lt;code>beta&lt;/code>或者弃用目前还是未知数。有兴趣的可以看下这里：&lt;a href="https://tekton.dev/docs/pipelines/resources/#why-aren-t-pipelineresources-in-beta">Why Aren’t PipelineResources in Beta?&lt;/a>&lt;/p>
&lt;p>简单来说，&lt;code>PipelineResource&lt;/code>可以通过其他的方式实现，而其本身也存在弊端：比如实现不透明，debug有难度；功能不够强；降低了Task的重用性等。&lt;/p>
&lt;p>比如&lt;code>git&lt;/code>类型的&lt;code>PipelineResource&lt;/code>，可以通过&lt;code>workspace&lt;/code>和&lt;code>git-clone&lt;/code> Task来实现；存储类型的，也可以通过&lt;code>workspace&lt;/code>来实现。&lt;/p>
&lt;p>这也就是为什么&lt;a href="#Workspace">上面介绍workspace的篇幅&lt;/a>比较大。个人也偏向于使用&lt;code>workspace&lt;/code>，灵活度高；使用workspace的Task重用性强。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://atbug.com/tekton-trigger-practice">云原生 CICD: Tekton Pipeline 实战&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://atbug.com/control-process-order-of-pod-containers">控制 Pod 内容器的启动顺序&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://knative.dev/docs/eventing/samples/writing-receive-adapter-source/03-controller">Knative Controller&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tekton.dev/docs/pipelines/resources/#why-aren-t-pipelineresources-in-beta">Why Aren’t PipelineResources in Beta?&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>控制 Pod 内容器的启动顺序</title><link>https://atbug.com/control-process-order-of-pod-containers/</link><pubDate>Thu, 12 Mar 2020 22:05:16 +0800</pubDate><guid>https://atbug.com/control-process-order-of-pod-containers/</guid><description>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/30/screenshot-20210430-at-092623.png" alt="">&lt;/p>
&lt;p>2021.4.30 更新：&lt;/p>
&lt;p>最新的方案，请跳转新篇 &lt;a href="https://mp.weixin.qq.com/s/8DqF_N_fjiM9AOouvddvgA">Kubernetes 上如何控制容器的启动顺序&lt;/a>。&lt;/p>
&lt;hr>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>众所周知, Kubernetes Pod 内有两种容器: 初始化容器(init container)和应用容器(app container). 其中初始化容器的执行先于应用容器, 并且初始化容器和应用容器的个数分别为 &lt;code>0~n&lt;/code> 和 &lt;code>1~n&lt;/code>.&lt;/p>
&lt;p>初始化容器会按照顺序执行, 顺序执行的前提是初始化容器始终会运行到完成(completed)状态. 而应用容器恰好相反: 启动顺序随机, 并始终保持运行(running)状态.&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;p>工作中有个架构的方案使用到了 sidecar 容器: 将基础组件功能从容器转移到 sidecar 容器中, 其中有个功能是从远程配置中心获取配置并保持实时更新. 保证实时更新没有问题, 但是配置文件需要在 app 启动之前完成初始化.&lt;/p>
&lt;p>对于同为&amp;quot;应用容器&amp;quot;类型的 sidecar 容器来说, 由于容器启动顺序随机而无法做到这一点.&lt;/p>
&lt;p>当时我们给定的方案是增加一个初始化容器进行配置的初始化, 不可避免的我们需要增加一个额外的容器, 即使是这个容器的生命周期非常短.&lt;/p>
&lt;p>追求极致的我们总是对这个额外增加的容器耿耿于怀: 假如能控制应用容器的启动顺序&amp;hellip;&lt;/p>
&lt;h3 id="新发现">新发现&lt;/h3>
&lt;p>近期在研究 CDF (Continuous Delivery Foundation)下的 &lt;a href="https://github.com/tektoncd">Tekton&lt;/a>, 其中有个概念是其将流水线(pipeline)中的各个步骤(step)作为应用容器在同一个 Pod 中运行.&lt;/p>
&lt;p>我们都知道流水线中的步骤是按照定义的顺序执行的, 那么 Tekton 是如何保证应用容器的执行顺序的?&lt;/p>
&lt;p>查看 pod 的 manifest 之后发现了下面的容器配置 (这个容器的作用从 git 仓库克隆代码)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">wait_file&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/downward/ready&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">wait_file_content&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">post_file&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/tools/0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">termination_path&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/termination&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">entrypoint&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/ko-app/git-init&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- --&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">url&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">http://gitlab.nip.io:8088/addozhang/tekton-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">revision&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">develop&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- -&lt;span class="l">path&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/workspace/git-source&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">/tekton/tools/entrypoint&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>克隆代码的命令是:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">git-init -url http://gitlab.nip.io:8088/addozhang/tekton-test -revision develop -path /workspace/git-source
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是容器的启动命令是&lt;code>/tekton/tools/entrypoint&lt;/code>并带上了一坨的参数(此处略过, 后面分析).&lt;/p>
&lt;p>翻看了下&lt;a href="https://github.com/tektoncd/pipeline/tree/master/cmd/entrypoint">文档&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>This binary is used to override the entrypoint of a container by wrapping it. In tektoncd/pipeline this is used to make sure Task&amp;rsquo;s steps are executed in order, or for sidecars.&lt;/p>
&lt;p>这个二进制文件被用于通过包装的方式来覆盖容器的入口点. 在 tektoncd/pipeline 中确保任务中的步骤或者 sidecar 被顺序地执行.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>-entrypoint&lt;/code>: 原始的容器启动命令, 作为 &lt;code>entrypoint&lt;/code> 的子进程运行. 即上面的 &lt;code>git-init XXXX&lt;/code>&lt;/li>
&lt;li>&lt;code>-post_file&lt;/code>: 子进程运行结束后写的文件路径(即上面的&lt;code>/tekton/tools/0&lt;/code>). 如果子进程执行失败, 则写一个&lt;code>{{post_file}}.err&lt;/code>文件, 而不是&lt;code>{{post_file}}&lt;/code>&lt;/li>
&lt;li>&lt;code>-wait_file&lt;/code>: 启动子进程&lt;strong>前&lt;/strong>监控的文件路径(即上面的&lt;code>/tekton/downward/ready&lt;/code>). 通过监控到的&lt;code>{{watch_file}}&lt;/code>或者&lt;code>{{watch_file}}.err&lt;/code>文件来决定执行子进程, 还是跳过执行然后写入&lt;code>{{post_file}}.err&lt;/code>文件并返回错误码(&lt;code>exitCode&lt;/code> &amp;gt;= 0)&lt;/li>
&lt;li>&lt;code>-wait_file_content&lt;/code>: 等待&lt;code>wait_file&lt;/code>有实际内容写入, 持续监控&lt;code>wait_file&lt;/code>直到有内容写入.&lt;/li>
&lt;/ul>
&lt;p>回头看上面容器配置:&lt;/p>
&lt;ol>
&lt;li>容器的&lt;code>entrypoint&lt;/code>启动进程&lt;/li>
&lt;li>监控到&lt;code>/tekton/downward/ready&lt;/code>文件的创建, 并等待文件内容的写入&lt;/li>
&lt;li>执行&lt;code>git-init&lt;/code>子进程, 从 git 仓库克隆源码&lt;/li>
&lt;li>创建&lt;code>/tekton/tools/0&lt;/code>文件&lt;/li>
&lt;/ol>
&lt;h3 id="实际应用">实际应用&lt;/h3>
&lt;p>这个方案是否能解决我们的问题, 还是有一定的局限性的.&lt;/p>
&lt;p>首先需要应用容器的启动命令进行重新的编排, 这个存在一定的挑战. 需要统一应用的启动命令才能做到规模化+自动化.&lt;/p>
&lt;p>其次引入可用于监控的文件, 需要额外增加&lt;code>Volume&lt;/code>用于跨容器的文件访问. 当然通过增加&lt;code>emptyDir&lt;/code>的&lt;code>Volume&lt;/code>即可.&lt;/p>
&lt;p>同时 sidecar 容器需要在完成启动后创建&lt;code>post_file&lt;/code>, 应用容器可以使用这个&lt;code>entrypoint&lt;/code>进行包装.&lt;/p>
&lt;p>如果要突破这个局限, CRD 无非是个优秀的方案. 下一篇, 我们通过一个简单的 CRD 来实现.&lt;/p></description></item><item><title>Tekton Trigger 介绍</title><link>https://atbug.com/tekton-trigger-glance/</link><pubDate>Wed, 05 Feb 2020 18:03:15 +0800</pubDate><guid>https://atbug.com/tekton-trigger-glance/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>Tekton 的介绍请参考&lt;a href="https://atbug.com/tekton-pipeline-practice/">Tekton Pipeline 实战&lt;/a>.&lt;/p>
&lt;p>通常, CI/CD 事件应该包含如下信息:&lt;/p>
&lt;ul>
&lt;li>确定事件的类型(比如 GitHub Push, GitLab Issue, Docker Hub Webhook 等)&lt;/li>
&lt;li>可从特定管道访问并映射到特定管道 (从事件负载中获取 SHA 信息, 然后在管道中使用)&lt;/li>
&lt;li>准确地触发管道 (基于有效负载值触发管道)&lt;/li>
&lt;/ul>
&lt;p>Tekton API 的设计分离了配置(比如 PipelineRun VS Pipeline), 保证了 step 可以被重用. 但是没有提供动态封装配置的机制来生成资源(尤其是 PipelineRun 和 PipelineResource). &lt;a href="https://github.com/tektoncd/triggers">Triggers&lt;/a> 通过下面的 CRDs 在架构上对 Tekton 进行了扩展:&lt;/p>
&lt;ul>
&lt;li>&lt;code>TriggerTemplate&lt;/code>: 创建资源的模板(比如用来创建 PipelineResource 和 PipelineRun)&lt;/li>
&lt;li>&lt;code>TriggerBinding&lt;/code>: 校验事件并提取负载字段&lt;/li>
&lt;li>&lt;code>EventListener&lt;/code>: 连接&lt;code>TriggerBinding&lt;/code>和&lt;code>TriggerTemplate&lt;/code>到可寻址的端点(事件接收器). 使用从各个&lt;code> TriggerBinding&lt;/code>中提取的参数来创建&lt;code>TriggerTemplate&lt;/code>中指定的 resources. 同样通过&lt;code> interceptor&lt;/code>字段来指定外部服务来对事件负载进行预处理.&lt;/li>
&lt;li>&lt;code>ClusterTriggerBinding&lt;/code>: cluster级别的&lt;code>TriggerBinding&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/rymZ0w.jpg" alt="">&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">kubectl apply --filename https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查新增的 CRD: &lt;code>kubectl api-resources | grep tekton&lt;/code>. Triggers 引入了 3 个 CRD: &lt;code>TriggerTemplate&lt;/code>, &lt;code>TriggerBinding&lt;/code>,&lt;code>EventListener&lt;/code>.&lt;/p>
&lt;p>检查新增的 deployment: &lt;code>tekton-triggers-webhook&lt;/code>, &lt;code>tekton-triggers-controller&lt;/code>.&lt;/p></description></item><item><title>Tekton Dashboard 安装</title><link>https://atbug.com/tekton-dashboard-installation/</link><pubDate>Sat, 01 Feb 2020 12:39:28 +0800</pubDate><guid>https://atbug.com/tekton-dashboard-installation/</guid><description>
&lt;p>Tekton 提供了&lt;a href="https://github.com/tektoncd/dashboard">dashboard&lt;/a>方便用户管理和查看 Tekton PipelineRun 和 TaskRun 以及创建, 执行和完成过程中涉及的资源. 它还允许按标签过滤 PipelineRun 和 TaskRun.&lt;/p>
&lt;h3 id="安装方法">安装方法&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply --filename https://github.com/tektoncd/dashboard/releases/download/v0.4.1/dashboard_latest_release.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查dashboard的运行情况, &lt;code>STATUS&lt;/code>为&lt;code>Running&lt;/code>的话则说明运行成功.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get pods --namespace tekton-pipelines
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="访问">访问&lt;/h3>
&lt;p>访问Tekton的Dashboard有两种方式, 一种是通过&lt;code>port-forward&lt;/code>, 另一种是通过&lt;code>ingress&lt;/code>来访问.&lt;/p>
&lt;h4 id="port-forward">port-forward&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl port-forward svc/tekton-dashboard &lt;span class="m">9097&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="ingress">ingress&lt;/h4>
&lt;p>先检查ingress是否开启.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube addon list
...
- ingress: enabled
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是disabled的话, 通过命令&lt;code>minikube addons enable ingress&lt;/code>.&lt;/p>
&lt;p>&lt;em>注意: 这里拉取&lt;code>quay.io/kubernetes-ingress-controller/nginx-ingress-controller&lt;/code>镜像可能比较慢, 建议使用国内的镜像, 比如&lt;code>quay.mirrors.ustc.edu.cn/kubernetes-ingress-controller/nginx-ingress-controller&lt;/code>&lt;/em>&lt;/p>
&lt;p>修改&lt;code>basic-dashboard-ingress.yaml&lt;/code>中的&lt;code>host&lt;/code>地址:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">extensions/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-dashboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-pipelines&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-dashboard.nip.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton-dashboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">servicePort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">9097&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行&lt;code>kubectl apply -f basic-dashboard-ingress.yaml&lt;/code>.&lt;/p>
&lt;p>还有最后一步, 在&lt;code>/etc/hosts&lt;/code>中添加一条解析&lt;code>x.x.x.x tekton-dashboard.nip.io&lt;/code>, ip地址通过&lt;code>minikube ip&lt;/code>来获取&lt;/p>
&lt;p>浏览器中打开&lt;code> tekton-dashboard.nip.io&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/uPic/6weoXL.jpg" alt="">&lt;/p></description></item><item><title>Tekton安装及Hello world</title><link>https://atbug.com/tekton-installation-and-sample/</link><pubDate>Fri, 17 Jan 2020 19:17:14 +0800</pubDate><guid>https://atbug.com/tekton-installation-and-sample/</guid><description>
&lt;h2 id="安装">安装&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查安装的tekton相关的CRD:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl api-resources &lt;span class="p">|&lt;/span> grep tekton
clustertasks tekton.dev &lt;span class="nb">false&lt;/span> ClusterTask
conditions tekton.dev &lt;span class="nb">true&lt;/span> Condition
pipelineresources tekton.dev &lt;span class="nb">true&lt;/span> PipelineResource
pipelineruns pr,prs tekton.dev &lt;span class="nb">true&lt;/span> PipelineRun
pipelines tekton.dev &lt;span class="nb">true&lt;/span> Pipeline
taskruns tr,trs tekton.dev &lt;span class="nb">true&lt;/span> TaskRun
tasks tekton.dev &lt;span class="nb">true&lt;/span> Task
&lt;/code>&lt;/pre>&lt;/div>&lt;p>tekton的两个pod:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get pods --namespace tekton-pipelines
NAME READY STATUS RESTARTS AGE
tekton-pipelines-controller-556d8f4494-2qthv 1/1 Running &lt;span class="m">0&lt;/span> 11m
tekton-pipelines-webhook-849cff5cf-8m5qq 1/1 Running &lt;span class="m">0&lt;/span> 11m
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装cli">安装CLI&lt;/h3>
&lt;p>cli: &lt;a href="https://github.com/tektoncd/cli#installing-tkn">https://github.com/tektoncd/cli#installing-tkn&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">brew install tektoncd-cli
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tekton-hello-world">Tekton: hello world&lt;/h2>
&lt;p>创建一个简单的&lt;code>Task&lt;/code>, 只有一个&lt;code>step&lt;/code>就是打印出&amp;quot;hello world&amp;quot;&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton.dev/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Task&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-hello-world&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">echo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个&lt;code>TaskRun&lt;/code>执行上面的&lt;code>Task&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tekton.dev/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TaskRun&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-hello-world-task-run&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">taskRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-hello-world&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行task:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl apply -f &amp;lt;name-of-file.yaml&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查&lt;code>TaskRun&lt;/code>的输出, 执行命令:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">tkn taskrun describe echo-hello-world-task-run
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">Name: echo-hello-world-task-run
Namespace: tekton-pipelines
Task Ref: echo-hello-world
Status
STARTED DURATION STATUS
21 minutes ago 1 minute Succeeded
Input Resources
No resources
Output Resources
No resources
Params
No params
Steps
NAME STATUS
echo Completed
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Succeeded&lt;/code>状态表示task执行成功.&lt;/p>
&lt;p>查看实际的输出, 执行命令:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">tkn taskrun logs echo-hello-world-task-run
&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">[echo] hello world
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Minikube安装istio</title><link>https://atbug.com/install-istio-on-minikube/</link><pubDate>Fri, 17 Jan 2020 08:02:42 +0800</pubDate><guid>https://atbug.com/install-istio-on-minikube/</guid><description>
&lt;h2 id="准备">准备&lt;/h2>
&lt;p>&lt;strong>注意: istioctl的安装要使用安装里的, 不要是用homebrew里的. &lt;a href="https://github.com/istio/istio/issues/19029">github issue&lt;/a>&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -L https://istio.io/downloadIstio &lt;span class="p">|&lt;/span> sh -
&lt;span class="nb">cd&lt;/span> istio-1.4.2
cp bin/istioctl /usr/local/bin/istioctl
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装前检查">安装前检查&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">istioctl verify-install
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果检查没问题, 会看到&lt;code>Install Pre-Check passed! The cluster is ready for Istio installation.&lt;/code>&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>istio有5种内建的安装配置&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>: remote, sds, default, demo, minimal&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">istioctl profile list
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>minimal: 使用istio的流量管理所需组件的最小化安装&lt;/li>
&lt;li>default: 根据IstioControlPlane API的默认设置(建议用于生产部署)启用组件. 您可以通过运行命令istioctl profile dump显示默认设置.&lt;/li>
&lt;li>demo: 几乎安装所有的特性, 包括logging和tracing的比例为100%. 不适合生产环境, 负载太重&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>default&lt;/th>
&lt;th>demo&lt;/th>
&lt;th>minimal&lt;/th>
&lt;th>sds&lt;/th>
&lt;th>remote&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Core components&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-citadel&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-egressgateway&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-galley&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-ingressgateway&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-nodeagent&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-pilot&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-policy&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-sidecar-injector&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-telemetry&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Addons&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istio-tracing&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus&lt;/code>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>demo&lt;/code> profile安装&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">istioctl manifest apply --set &lt;span class="nv">profile&lt;/span>&lt;span class="o">=&lt;/span>demo
&lt;/code>&lt;/pre>&lt;/div>&lt;p>验证安装结果&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">istioctl manifest generate --set &lt;span class="nv">profile&lt;/span>&lt;span class="o">=&lt;/span>demo &amp;gt; /tmp/generated-manifest.yaml
istioctl verify-install -f /tmp/generated-manifest.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&amp;hellip;&amp;hellip;
Checked 23 crds
Checked 9 Istio Deployments
Istio is installed successfully&lt;/p>
&lt;/blockquote>
&lt;h2 id="卸载">卸载&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">helm template install/kubernetes/helm/istio --namespace istio-system &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --values install/kubernetes/helm/istio/values-istio-demo.yaml &lt;span class="p">|&lt;/span> kubectl delete -f -
kubectl delete namespace istio-system
&lt;span class="c1">#delete all CRDs&lt;/span>
kubectl delete -f install/kubernetes/helm/istio-init/files
&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://istio.io/docs/setup/additional-setup/config-profiles/">这里&lt;/a>可以查看各个配置的详细说明 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>加速云原生的 Java 开发</title><link>https://atbug.com/speed-up-java-development-on-kubernetes/</link><pubDate>Sat, 21 Dec 2019 20:45:22 +0800</pubDate><guid>https://atbug.com/speed-up-java-development-on-kubernetes/</guid><description>
&lt;p>今天来说说日常在Kubernetes开发Java项目遇到的问题.&lt;/p>
&lt;p>当我们新建一个项目的时候, 总是面临需要新建manifest, 平时都是&lt;code>copy+paste+modify&lt;/code>. 能否以变成的方式来生成?&lt;/p>
&lt;p>开发时的步骤也比较繁琐: &lt;code>docker build&lt;/code>, &lt;code>docker push&lt;/code>, &lt;code>kubectl apple&lt;/code>, &lt;code>kubectl delete pod&lt;/code>. 对于一个Java应用来说还多了一步编译. 操作一次还ok, 但是一天十几次总会有想吐的感觉. 这些步骤能否简化成一个命令, 甚至修改了代码自动就完成上面一系列的操作?&lt;/p>
&lt;p>实现这些我们需要几个工具: &lt;a href="https://github.com/dekorateio/dekorate">dekorate&lt;/a>, &lt;a href="https://github.com/GoogleContainerTools/jib">Jib&lt;/a>, &lt;a href="https://github.com/GoogleContainerTools/skaffold">Skaffold&lt;/a>. 其中Jib也在上一篇文章&lt;a href="https://atbug.com/build-docker-or-oci-image-with-jib-for-java/">使用Jib为Java应用构建镜像&lt;/a>中介绍过.&lt;/p>
&lt;h2 id="dekorate">dekorate&lt;/h2>
&lt;blockquote>
&lt;p>Dekorate is a collection of Java compile-time generators and decorators for Kubernetes/OpenShift manifests.
Dekorate是Java编译时生成和装饰Kubernetes/OpenShift的manifests的工具&lt;/p>
&lt;/blockquote>
&lt;h3 id="快速开始">快速开始&lt;/h3>
&lt;h4 id="1-通过使用spring-initializerhttpsstartspringio生成一个项目spring-boot-222-并加入依赖">1. 通过使用&lt;a href="https://start.spring.io">Spring Initializer&lt;/a>生成一个项目(Spring Boot 2.2.2), 并加入依赖:&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.dekorate&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>kubernetes-spring-starter&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>0.10.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-加入一个简单的controller">2. 加入一个简单的&lt;code>Controller&lt;/code>:&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * @author Addo.Zhang
&lt;/span>&lt;span class="cm"> * @date 2019/12/22
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="nd">@RestController&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DekorateExampleController&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@GetMapping&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">hi&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Hello World&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-执行命令mvn-clean-install-然后在targetclassesmeta-infdekorate目录下可以找到kubernetesjson和kubernetesyml两个文件">3. 执行命令&lt;code>mvn clean install&lt;/code>, 然后在&lt;code>target/classes/META-INF/dekorate&lt;/code>目录下可以找到&lt;code>kubernetes.json&lt;/code>和&lt;code>kubernetes.yml&lt;/code>两个文件.&lt;/h4>
&lt;p>&lt;code>kubernetes.yml&lt;/code>的内容:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;v1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Service&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;0.0.1-SNAPSHOT&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">group&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;addo&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;http&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8081&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8081&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;0.0.1-SNAPSHOT&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">group&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;addo&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;ClusterIP&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;apps/v1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Deployment&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;0.0.1-SNAPSHOT&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">group&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;addo&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;0.0.1-SNAPSHOT&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">group&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;addo&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;0.0.1-SNAPSHOT&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">group&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;addo&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;KUBERNETES_NAMESPACE&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">valueFrom&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">fieldRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">fieldPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;metadata.namespace&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;addo/dekorate-example:0.0.1-SNAPSHOT&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;IfNotPresent&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">livenessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">failureThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">httpGet&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/actuator/info&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8081&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scheme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;HTTP&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">initialDelaySeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">periodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">successThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">timeoutSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;dekorate-example&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8081&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;http&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;TCP&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">readinessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">failureThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">httpGet&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/actuator/health&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8081&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scheme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;HTTP&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">initialDelaySeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">periodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">successThreshold&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">timeoutSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>yml中包含了&lt;code>Service&lt;/code>和&lt;code>Deployment&lt;/code>两部分, dekorate完美兼容的Spring:&lt;/p>
&lt;ul>
&lt;li>&lt;code>app: dekorate-example&lt;/code>: 项目名&lt;/li>
&lt;li>&lt;code>version: 0.0.1-SNAPSHOT&lt;/code>: 项目当前版本&lt;/li>
&lt;li>&lt;code>group: addo&lt;/code>: 是我系统当前用户名&lt;/li>
&lt;li>&lt;code>/actuator/health&lt;/code>: Spring Boot 2.2后actuator的health endpoint, 作为&lt;code>readinessProbe&lt;/code>&lt;/li>
&lt;li>&lt;code>/actuator/info&lt;/code>: Spring Boot 2.2后actuator的endpoint, 作为&lt;code>livenessProbe&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="进阶">进阶&lt;/h3>
&lt;p>&lt;strong>前面yml的内容都是自动生成的, 假如有些特殊的需求. 比如修改镜像的&lt;code>repository&lt;/code>即这里的&lt;code>group&lt;/code>, 如何操作?&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">dekorate.kubernetes.group = addozhang
&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果:&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/blog/upload/5zgkfl.jpg" alt="Change Image Repository">&lt;/p>
&lt;p>&lt;strong>或者修改Service的类型为NodePort&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">dekorate.kubernetes.service-type = NodePort
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/blog/upload/vIen3M.jpg" alt="NodePort Service">&lt;/p>
&lt;h4 id="配置">配置&lt;/h4>
&lt;p>dekoration提供了&lt;a href="https://github.com/dekorateio/dekorate/blob/master/assets/config.md">丰富的配置&lt;/a>来个性化manifest.&lt;/p>
&lt;p>除了上面使用的配置文件(properties/yaml)的方式, 还提供了&lt;code>Annotation&lt;/code>注解配置方式.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">io.dekorate.kubernetes.annotation.Env&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">io.dekorate.kubernetes.annotation.KubernetesApplication&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@KubernetesApplication&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">envVars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nd">@Env&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;key1&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;var1&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Main&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//Your code goes here
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/blog/upload/exQoxy.jpg" alt="@KubernetesApplication Annotation">&lt;/p>
&lt;h2 id="jib">Jib&lt;/h2>
&lt;p>Jib的说明请看上一篇文章:&lt;a href="https://atbug.com/build-docker-or-oci-image-with-jib-for-java/">使用Jib为Java应用构建镜像&lt;/a>&lt;/p>
&lt;h3 id="插件配置">插件配置&lt;/h3>
&lt;p>下面是针对该项目添加的配置:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>com.google.cloud.tools&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>jib-maven-plugin&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.8.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;configuration&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;container&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;jvmFlags&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;jvmFlag&amp;gt;&lt;/span>-Xmx128m&lt;span class="nt">&amp;lt;/jvmFlag&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;jvmFlag&amp;gt;&lt;/span>-Xms64m&lt;span class="nt">&amp;lt;/jvmFlag&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/jvmFlags&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;labels&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;Author&amp;gt;&lt;/span>Addo.Zhang&lt;span class="nt">&amp;lt;/Author&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/labels&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;creationTime&amp;gt;&lt;/span>USE_CURRENT_TIMESTAMP&lt;span class="nt">&amp;lt;/creationTime&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/container&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;from&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;image&amp;gt;&lt;/span>openjdk:8-jdk-alpine&lt;span class="nt">&amp;lt;/image&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/from&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;to&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;image&amp;gt;&lt;/span>addo/dekorate-example&lt;span class="nt">&amp;lt;/image&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;tags&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;tag&amp;gt;&lt;/span>latest&lt;span class="nt">&amp;lt;/tag&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/tags&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/to&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;allowInsecureRegistries&amp;gt;&lt;/span>true&lt;span class="nt">&amp;lt;/allowInsecureRegistries&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/configuration&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行命令&lt;code>mvn compile jib:dockerBuild&lt;/code>便可以编译代码, 构建镜像并推送到镜像仓库.&lt;/p>
&lt;h2 id="skaffold">Skaffold&lt;/h2>
&lt;p>&lt;a href="https://github.com/GoogleContainerTools/skaffold">Skaffold&lt;/a>也是GoogleContainerTools中的一个工具.&lt;/p>
&lt;blockquote>
&lt;p>Skaffold is a command line tool that facilitates continuous development for Kubernetes applications. You can iterate on your application source code locally then deploy to local or remote Kubernetes clusters. Skaffold handles the workflow for building, pushing and deploying your application. It also provides building blocks and describe customizations for a CI/CD pipeline.
Skaffold是一个命令行工具, 可促进Kubernetes应用程序的持续开发. 可以在本地迭代应用程序源代码, 然后部署到本地或远程Kubernetes集群. Skaffold处理构建, 推送和部署应用程序的工作流程. 它还提供了构建块并描述了CI/CD管道的自定义.&lt;/p>
&lt;/blockquote>
&lt;p>在我们这个例子中, 通过与Jib的联动, 完成编译代码, 构建镜像, 推送镜像, 部署一系列操作.&lt;/p>
&lt;p>![Run](&lt;a href="https://raw.githubusercontent.com/addozhang/oss/master/blog/upload/2019-12-23">https://raw.githubusercontent.com/addozhang/oss/master/blog/upload/2019-12-23&lt;/a> 15.12.24.gif)&lt;/p>
&lt;p>截屏中的操作, 因为没有代码改动而不续构建镜像, Skaffold直接从cache中获取镜像并部署到Kubernetes中.&lt;/p>
&lt;h3 id="skaffold操作">Skaffold操作&lt;/h3>
&lt;h4 id="1-执行命令skaffold-init---xxenablejibinit并在提示出输入y">1. 执行命令&lt;code>skaffold init --XXenableJibInit&lt;/code>并在提示出输入&lt;code>y&lt;/code>&lt;/h4>
&lt;h4 id="2-该命令会生成一个名为skaffoldyaml的文件">2. 该命令会生成一个名为&lt;code>skaffold.yaml&lt;/code>的文件&lt;/h4>
&lt;p>由于&lt;code>dekorate&lt;/code>同时生成了&lt;code>json&lt;/code>和&lt;code>yaml&lt;/code>格式的manifest, 被&lt;code>skaffold&lt;/code>检测到. 实际操作中只需要其中一个即可.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">skaffold/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dekorate-example&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">artifacts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">addo/dekorate-example&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">jib&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kubectl&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">manifests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">target/classes/META-INF/dekorate/kubernetes.json&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">target/classes/META-INF/dekorate/kubernetes.yml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-执行skaffold-run">3. 执行&lt;code>skaffold run&lt;/code>&lt;/h4>
&lt;h4 id="4-pod启动完成后-通过kubectl-port-forward-podname-here-8081">4. pod启动完成后, 通过&lt;code>kubectl port-forward PODNAME-HERE 8081&lt;/code>&lt;/h4>
&lt;h4 id="5-请求http-httplocalhost8081">5. 请求&lt;code>http http://localhost:8081&lt;/code>&lt;/h4>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/blog/upload/wt2BVU.jpg" alt="">&lt;/p>
&lt;h3 id="进阶-1">进阶&lt;/h3>
&lt;p>Skaffold的功能强大, 目前个人使用的有限, 有时间新开一篇来学习一下.&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/addozhang/oss/master/blog/upload/FXu4Hy.jpg" alt="">&lt;/p>
&lt;h4 id="cli">CLI&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">➜ ~ skaffold &lt;span class="nb">help&lt;/span>
A tool that facilitates continuous development &lt;span class="k">for&lt;/span> Kubernetes applications.
Find more information at: https://skaffold.dev/docs/getting-started/
End-to-end pipelines:
run Run a pipeline
dev Run a pipeline in development mode
debug &lt;span class="o">[&lt;/span>beta&lt;span class="o">]&lt;/span> Run a pipeline in debug mode
Pipeline building blocks &lt;span class="k">for&lt;/span> CI/CD:
build Build the artifacts
deploy Deploy pre-built artifacts
delete Delete the deployed application
render &lt;span class="o">[&lt;/span>alpha&lt;span class="o">]&lt;/span> Perform all image builds, and output rendered Kubernetes manifests
Getting started with a new project:
init &lt;span class="o">[&lt;/span>alpha&lt;span class="o">]&lt;/span> Generate configuration &lt;span class="k">for&lt;/span> deploying an application
fix Update old configuration to newest schema version
Other Commands:
completion Output shell completion &lt;span class="k">for&lt;/span> the given shell &lt;span class="o">(&lt;/span>bash or zsh&lt;span class="o">)&lt;/span>
config Interact with the Skaffold configuration
credits Export third party notices to given path &lt;span class="o">(&lt;/span>./skaffold-credits by default&lt;span class="o">)&lt;/span>
diagnose Run a diagnostic on Skaffold
version Print the version information
Usage:
skaffold &lt;span class="o">[&lt;/span>flags&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>options&lt;span class="o">]&lt;/span>
Use &lt;span class="s2">&amp;#34;skaffold &amp;lt;command&amp;gt; --help&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information about a given command.
Use &lt;span class="s2">&amp;#34;skaffold options&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> a list of global command-line options &lt;span class="o">(&lt;/span>applies to all commands&lt;span class="o">)&lt;/span>.
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="yaml配置">Yaml配置&lt;/h4>
&lt;p>参考&lt;a href="https://skaffold.dev/docs/references/yaml/">skaffold.yaml&lt;/a>&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>文章的开头我们提到如何做到修改代码后自动完成一些列的操作, 通过&lt;code>skaffold dev&lt;/code>就可以实现.&lt;/p>
&lt;p>文章中使用的&lt;code>dekoration-example&lt;/code>可在&lt;a href="https://github.com/addozhang/dekorate-example">GitHub&lt;/a>上找到.&lt;/p></description></item><item><title>Kubernetes中的Nginx动态解析</title><link>https://atbug.com/nginx-dynamic-domain-parse-in-kubernetes/</link><pubDate>Wed, 30 May 2018 12:10:32 +0000</pubDate><guid>https://atbug.com/nginx-dynamic-domain-parse-in-kubernetes/</guid><description>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>Nginx运行在kubernets中, 反向代理service提供服务.&lt;/p>
&lt;p>kubernetes版本v1.9.1+a0ce1bc657.&lt;/p>
&lt;h3 id="问题">问题:&lt;/h3>
&lt;p>配置如下:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">location ^~/info {
proxy_pass: http://serviceName:port;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除并重建Service的时候, nginx会出现下面的问题:&lt;/p>
&lt;blockquote>
&lt;p>connect() failed (113: No route to host) &amp;hellip; upstream: &amp;ldquo;xxxxx&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;h3 id="分析">分析&lt;/h3>
&lt;p>通过google发现, 是nginx的dns解析方案的问题.&lt;/p>
&lt;p>nginx官方的说明:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>If the domain name can’t be resolved, NGINX fails to start or reload its configuration.&lt;/li>
&lt;li>NGINX caches the DNS records until the next restart or configuration reload, ignoring the records’ TTL values.&lt;/li>
&lt;li>We can’t specify another load‑balancing algorithm, nor can we configure passive health checks or other features defined by parameters to the server directive, which we’ll describe in the next section.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>意思是说, nginx在启动的时候就会解析&lt;code>proxy_pass&lt;/code>后的域名, 并把&lt;code>ip&lt;/code>缓存下来, 而且没有TTL. 只有在restart或者reload的时候才会再次解析.&lt;/p>
&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>使用nginx pod的解析服务器作为resolver:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">#nginx conf
resolver NAME_SERVER valid=30s ipv6=off;
set $service &amp;#34;http://serviceName:port&amp;#34;;
location ^~/info {
proxy_pass: $service;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用shell获取pod中使用的解析服务器&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nv">NAME_SERVER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>cat /etc/resolv.conf &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;nameserver&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{print $2}&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> tr &lt;span class="s1">&amp;#39;\n&amp;#39;&lt;/span> &lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="sb">`&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考:
&lt;a href="https://stackoverflow.com/questions/17685674/nginx-proxy-pass-with-remote-addr">Nginx proxy_pass with $remote_addr&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://tenzer.dk/nginx-with-dynamic-upstreams/">Nginx with dynamic upstreams&lt;/a>&lt;/p>
&lt;h3 id="另一个问题">另一个问题&lt;/h3>
&lt;blockquote>
&lt;p>serviceName could not be resolved (3: Host not found)&lt;/p>
&lt;/blockquote>
&lt;p>service的短名称是解析不了的, 需要使用serviceName.namespace.svc.clusterName.&lt;/p></description></item><item><title>Kubernetes — 持久卷</title><link>https://atbug.com/kubernetes-persistent-volumes/</link><pubDate>Sun, 20 Aug 2017 22:25:40 +0000</pubDate><guid>https://atbug.com/kubernetes-persistent-volumes/</guid><description>
&lt;h1 id="persistent-volume">Persistent Volume&lt;/h1>
&lt;p>译自&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volumes&lt;/a>&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>管理存储是管理计算的独特问题。 PersistentVolume子系统为用户和管理员提供了一个API，其中提供了如何从如何使用存储提供存储的详细信息。为此，我们介绍两种新的API资源：PersistentVolume和PersistentVolumeClaim。&lt;/p>
&lt;p>PersistentVolume（PV）是由管理员配置的集群中的一段存储。它是集群中的一种资源就像一个节点是一个集群的资源。 PV是类似Volumes的卷插件，但是具有独立于使用PV的任何单个pod的生命周期。该API对象捕获存储的实现细节，即NFS，iSCSI或云提供商特定的存储系统。&lt;/p>
&lt;p>PersistentVolumeClaim（PVC）是用户存储的请求。它类似于pod。 Pod消耗节点资源，PVC消耗PV资源。Pods可以请求特定级别的资源（CPU和内存）。声明可以请求特定的大小和访问模式（例如，一次读写或者多次只读）。&lt;/p>
&lt;p>虽然PersistentVolumeClaims允许用户使用抽象存储资源，但是常见的是，用户需要具有不同属性（如性能）的PersistentVolumes，用于不同的问题。 集群管理员需要能够提供多种彼此不同的PersistentVolumes，而不仅仅是大小和访问模式，而不会使用户了解这些卷的实现细节。 对于这些需求，有一个StorageClass资源。&lt;/p>
&lt;p>StorageClass为管理员提供了一种描述他们提供的存储的“类”的方法。 不同的类可能映射到服务质量级别，或备份策略，或者由群集管理员确定的任意策略。 Kubernetes本身对于什么类别代表是不言而喻的。 这个概念有时在其他存储系统中称为“配置文件”。&lt;/p>
&lt;p>请参阅&lt;a href="https://kubernetes.io/docs/user-guide/persistent-volumes/walkthrough/">详细演练与工作示例&lt;/a>。&lt;/p>
&lt;h2 id="存储和声明的生命周期">存储和声明的生命周期&lt;/h2>
&lt;p>PVs是集群中的资源；PVCs是对这种资源的声明，同时也扮演者对资源声明的检查。PVs和PVCs之前的交互遵循生命周期：供应、绑定、使用中、重新申请。&lt;/p>
&lt;p>集群管理员创建多个PV。它们携带可供集群用户使用的真实存储的详细信息。它们存在于Kubernetes API中，可用于消费。&lt;/p>
&lt;h3 id="供应provisioning">供应(Provisioning)&lt;/h3>
&lt;p>PVs会以两种方式供应：静态和动态。&lt;/p>
&lt;h4 id="静态">静态&lt;/h4>
&lt;p>集群管理员创建多个PV。 它们携带可供集群用户使用的真实存储的详细信息。 它们存在于Kubernetes API中，可被使用。&lt;/p>
&lt;h4 id="动态">动态&lt;/h4>
&lt;p>当管理员创建的静态PV都不匹配用户的PersistentVolumeClaim时，集群可能会尝试为PVC指定动态配置卷。 此配置基于StorageClasses：PVC必须指定一个类，并且管理员必须已创建并配置该类才能进行动态配置。 要求该类的声明有效地为自己禁用动态配置。&lt;/p>
&lt;h3 id="绑定binding">绑定(Binding)&lt;/h3>
&lt;p>当用户创建、或已经创建了一个PersistenVolumenClaim并指定大小和访问类型。Master中的控制循环会检测新的PVC，找到一个匹配的PV（如果可能的话），并将它们绑定在一起。如果一个PV被动态地供应某个PVC，循环将总是把这个PV和该PVC绑定。否则，用户总是至少得到他们要求的内容，但是卷可能超出了要求。一旦绑定，PersistentVolumeClaim绑定是排他的，不管用于绑定它们的模式。&lt;/p>
&lt;p>如果匹配的卷不存在，请求将无限期地保持。 随着匹配卷变得可用，请求将被绑定。 例如，提供许多50Gi PV的集群将不匹配要求100Gi的PVC。 当集群中添加100Gi PV时，可以绑定PVC。&lt;/p>
&lt;h3 id="使用使用">使用(使用)&lt;/h3>
&lt;p>PODs把PVC当做volume使用。集群检查声明以找到绑定的卷并为POD挂载该卷。 对于支持多种访问模式的卷，用户在将其声明用作pod中的卷时指定所需的模式。&lt;/p>
&lt;p>一旦用户有声明并且该声明被绑定，绑定的PV属于用户，只要他们需要它。 用户通过在其Pod的卷块中包含persistentVolumeClaim来安排Pods并访问其声明的PV。 请参阅下面的语法详细信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mypod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myfrontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dockerfile/nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/var/www/html&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mypd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mypd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeClaim&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">claimName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myclaim&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="回收reclaiming">回收(Reclaiming)&lt;/h3>
&lt;p>当用户使用完volume，可以通过请求允许回收资源的API来删除该PVC对象。PersistentVolume的回收策略告诉集群如何处理当声明释放PV后。目前，卷可以被保留，回收或删除。&lt;/p>
&lt;h4 id="保留retaining">保留(Retaining)&lt;/h4>
&lt;p>保留回收策略允许手动回收资源。 当PersistentVolumeClaim被删除时，PersistentVolume仍然存在，并且该卷被认为是“释放的”。 但是，由于上一个声明者的数据仍保留在卷上，因此尚不可用于其他声明。 管理员可以通过以下步骤手动回收卷。&lt;/p>
&lt;ul>
&lt;li>删除PersistentVolume。 删除PV后，外部基础设施（如AWS EBS，GCE PD，Azure Disk或Cinder卷）中的关联存储资产仍然存在。&lt;/li>
&lt;li>相应地手动清理相关存储资产上的数据。&lt;/li>
&lt;li>手动删除关联的存储资产，或者如果要重用相同的存储资产，请使用存储资产定义创建一个新的PersistentVolume。&lt;/li>
&lt;/ul>
&lt;h4 id="回收recycling">回收(Recycling)&lt;/h4>
&lt;p>如果受相应的卷插件支持，回收将对卷执行基本的擦除（rm -rf / thevolume / *），并使其再次可用于新的声明。
但是，管理员可以使用Kubernetes控制器管理器命令行参数来配置自定义的回收器pod模板，如&lt;a href="https://kubernetes.io/docs/admin/kube-controller-manager/">这里&lt;/a>所述。 定制回收站模板必须包含卷规范，如下例所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pv-recycler-&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Never&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">vol&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/any/path/it/will/be/replaced&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pv-recycler&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;gcr.io/google_containers/busybox&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;test -e /scrub &amp;amp;&amp;amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/* &amp;amp;&amp;amp; test -z \&amp;#34;$(ls -A /scrub)\&amp;#34; || exit 1&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">vol&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/scrub&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，卷部分中的自定义回收器pod模板中指定的特定路径将替换为正在回收的卷的特定路径。&lt;/p>
&lt;h4 id="删除deleting">删除(Deleting)&lt;/h4>
&lt;p>对于支持“删除回收”策略的卷插件，删除将从Kubernetes中删除PersistentVolume对象，并删除外部基础架构（如AWS EBS，GCE PD，Azure Disk或Cinder卷）中关联的存储资产。 动态配置的卷始终被删除。 如果不希望这样做，目前唯一的选择是在创建PV之后编辑或修补PV。 请参阅&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/change-pv-reclaim-policy/">更改PersistentVolume的回收策略&lt;/a>。&lt;/p>
&lt;h3 id="persistent-volume的类型">Persistent Volume的类型&lt;/h3>
&lt;ul>
&lt;li>GCEPersistentDisk&lt;/li>
&lt;li>AWSElasticBlockStore&lt;/li>
&lt;li>AzureFile&lt;/li>
&lt;li>AzureDisk&lt;/li>
&lt;li>FC (Fibre Channel)&lt;/li>
&lt;li>FlexVolume&lt;/li>
&lt;li>Flocker&lt;/li>
&lt;li>NFS&lt;/li>
&lt;li>iSCSI&lt;/li>
&lt;li>RBD (Ceph Block Device)&lt;/li>
&lt;li>CephFS&lt;/li>
&lt;li>Cinder (OpenStack block storage)&lt;/li>
&lt;li>Glusterfs&lt;/li>
&lt;li>VsphereVolume&lt;/li>
&lt;li>Quobyte Volumes&lt;/li>
&lt;li>HostPath (single node testing only – local storage is not supported in any way and WILL NOT WORK in a multi-node cluster)&lt;/li>
&lt;li>VMware Photon&lt;/li>
&lt;li>Portworx Volumes&lt;/li>
&lt;li>ScaleIO Volumes&lt;/li>
&lt;li>StorageOS&lt;/li>
&lt;/ul>
&lt;h2 id="persistent-volumes">Persistent Volumes&lt;/h2>
&lt;p>每个PV都包含规格和状态，这是规格和状态。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pv0003&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capacity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">5Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteOnce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeReclaimPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Recycle&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storageClassName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">slow&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">nfs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/tmp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">172.17.0.2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="容量">容量&lt;/h3>
&lt;p>通常，PV将具有特定的存储容量。这是使用PV的&lt;code>capacity&lt;/code>属性设置的。看到Kubernetes的&lt;a href="https://git.k8s.io/community/contributors/design-proposals/resources.md">资源模型&lt;/a>，以了解容量使用的单位。&lt;/p>
&lt;p>目前，存储大小是唯一可以设置或请求的资源。未来的属性可能包括IOPS，吞吐量等。&lt;/p>
&lt;h3 id="访问模式">访问模式&lt;/h3>
&lt;p>PersistentVolume可以以资源提供者支持的任何方式安装在主机上。 如下表所示，提供者将具有不同的特性，每个PV的访问模式都被设置为该特定卷支持的特定模式。 例如，NFS可以支持多个读/写客户端，但是特定的NFS PV可能会以只读方式在服务器上导出。 每个PV都有自己的一组访问模式来描述具体的PV功能。&lt;/p>
&lt;p>访问模式：&lt;/p>
&lt;ul>
&lt;li>ReadWriteOnce - 卷可以由单个节点作为读写装载&lt;/li>
&lt;li>ReadOnlyMany - 许多节点可以只读容量&lt;/li>
&lt;li>ReadWriteMany - 卷可以通过许多节点的读写装载&lt;/li>
&lt;/ul>
&lt;p>在CLI中，访问模式缩写为：&lt;/p>
&lt;ul>
&lt;li>RWO - ReadWriteOnce&lt;/li>
&lt;li>ROX - ReadOnlyMany&lt;/li>
&lt;li>RWX - ReadWriteMany&lt;/li>
&lt;/ul>
&lt;p>重要！一个卷只能一次使用一种访问模式进行挂载，即使它支持很多。例如，GCEPersistentDisk可以由单个节点挂载为ReadWriteOnce或多个节点挂载为ReadOnlyMany，但不能同时使用两种。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Volume插件&lt;/th>
&lt;th>单节点读写&lt;/th>
&lt;th>多个节点只读&lt;/th>
&lt;th>多个节点读写&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>AWSElasticBlockStore&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AzureFile&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AzureDisk&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CephFS&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cinder&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FC&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FlexVolume&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Flocker&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GCEPersistentDisk&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Glusterfs&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HostPath&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iSCSI&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PhotonPersistentDisk&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Quobyte&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NFS&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RBD&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VsphereVolume&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PortworxVolume&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>✓&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ScaleIO&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>StorageOS&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="类型">类型&lt;/h3>
&lt;p>PV可以有一个类型，通过将storageClassName属性设置为StorageClass的名称来指定。 特定类型的PV只能绑定到请求该类型的PVC。 没有storageClassName的PV没有类型，只能绑定到不需要特定类型的PVC。
在过去，使用了注释volume.beta.kubernetes.io/storage-class而不是storageClassName属性。 该注释仍然可以工作，但将来Kubernetes版本将不再适用。&lt;/p>
&lt;h3 id="回收策略">回收策略&lt;/h3>
&lt;p>目前的回收策略是：&lt;/p>
&lt;ul>
&lt;li>Retain - 手动回收&lt;/li>
&lt;li>Recycle - 基本擦洗（“rm -rf / thevolume / *”）&lt;/li>
&lt;li>Delete - 相关联的存储资产，如AWS EBS，GCE PD，Azure Disk或OpenStack Cinder卷被删除&lt;/li>
&lt;/ul>
&lt;p>目前，只有NFS和HostPath支持回收。 AWS EBS，GCE PD，Azure Disk和Cinder卷支持删除。&lt;/p>
&lt;h3 id="阶段">阶段&lt;/h3>
&lt;p>卷将处于以下阶段之一：&lt;/p>
&lt;ul>
&lt;li>Available 可用 - 一个尚未绑定到索赔的免费资源&lt;/li>
&lt;li>Bound 绑定 - 音量必须是声明&lt;/li>
&lt;li>Released 释放 - 声明已被删除，但资源尚未被集群回收&lt;/li>
&lt;li>Failed 失败 - 卷自动回收失败&lt;/li>
&lt;/ul>
&lt;p>CLI将显示绑定到PV的PVC的名称。&lt;/p>
&lt;h3 id="挂载选项">挂载选项&lt;/h3>
&lt;p>Kubernetes管理员可以指定在一个节点上挂载一个持久卷时的其他挂载选项。&lt;/p>
&lt;p>您可以通过使用持久卷上的注释volume.beta.kubernetes.io/mount-options来指定安装选项。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;v1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;PersistentVolume&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">gce-disk-1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volume.beta.kubernetes.io/mount-options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;discard&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capacity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;10Gi&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;ReadWriteOnce&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">gcePersistentDisk&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">fsType&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;ext4&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pdName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;gce-disk-1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装选项是一个字符串，在将卷安装到磁盘时将被累积地连接和使用。&lt;/p>
&lt;p>请注意，并非所有Persistent卷类型都支持挂载选项。 在Kubernetes 1.6版中，以下卷类型支持挂载选项。&lt;/p>
&lt;ul>
&lt;li>GCEPersistentDisk&lt;/li>
&lt;li>AWSElasticBlockStore&lt;/li>
&lt;li>AzureFile&lt;/li>
&lt;li>AzureDisk&lt;/li>
&lt;li>NFS&lt;/li>
&lt;li>iSCSI&lt;/li>
&lt;li>RBD (Ceph Block Device)&lt;/li>
&lt;li>CephFS&lt;/li>
&lt;li>Cinder (OpenStack block storage)&lt;/li>
&lt;li>Glusterfs&lt;/li>
&lt;li>VsphereVolume&lt;/li>
&lt;li>Quobyte Volumes&lt;/li>
&lt;li>VMware Photon&lt;/li>
&lt;/ul>
&lt;h2 id="persistentvolumeclaims">PersistentVolumeClaims&lt;/h2>
&lt;p>每个PVC包含规格和状态，这是声明的规范和状态。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolumeClaim&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myclaim&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ReadWriteOnce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">8Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storageClassName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">slow&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">release&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;stable&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchExpressions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- {&lt;span class="nt">key: environment, operator: In, values&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">dev]}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="访问模式-1">访问模式&lt;/h3>
&lt;p>当请求具有特定访问模式的存储时，声明使用与卷相同的约定。&lt;/p>
&lt;h3 id="资源">资源&lt;/h3>
&lt;p>声明（就像pods）可以请求特定数量的资源。 在这种情况下，请求用于存储。 相同的资源模型适用于卷和声明。&lt;/p>
&lt;h3 id="选择器">选择器&lt;/h3>
&lt;p>声明可以指定标签选择器以进一步过滤Volumes集。 只有标签与选择器匹配的卷才能绑定到声明。 选择器可以由两个字段组成：&lt;/p>
&lt;ul>
&lt;li>matchLabels - 卷必须具有带此值的标签&lt;/li>
&lt;li>matchExpressions - 通过指定关键字和值的关键字，值列表和运算符所做的要求列表。 有效运算符包括In，NotIn，Exists和DoesNotExist。&lt;/li>
&lt;/ul>
&lt;p>所有来自matchLabels和matchExpressions的要求是组合在一起的，所有这些要求都必须满足才能匹配。&lt;/p>
&lt;h3 id="类型-1">类型&lt;/h3>
&lt;p>声明可以通过使用属性storageClassName指定StorageClass的名称来请求特定的类型。只有所请求的类型的PV，与PVC相同的storageClassName的PV可以绑定到PVC。&lt;/p>
&lt;p>PVC不一定要求一个类型。 它的storageClassName设置为等于“”的PVC总是被解释为请求没有类型的PV，因此它只能绑定到没有类型的PV（没有注释或一个等于“”）。 没有storageClassName的PVC不完全相同，并且根据是否启用了DefaultStorageClass admission插件，集群的处理方式不同。&lt;/p>
&lt;ul>
&lt;li>如果admission插件已打开，则管理员可以指定默认的StorageClass。 没有storageClassName的所有PVC只能绑定到该默认的PV。 通过将StorageClass对象中的注解storageclass.kubernetes.io/is-default-class设置为“true”来指定默认的StorageClass。 如果管理员没有指定默认值，则集群会对PVC创建做出响应，就像admission插件被关闭一样。 如果指定了多个默认值，则admission插件禁止创建所有PVC。&lt;/li>
&lt;li>如果admission插件已关闭，则不存在默认StorageClass的概念。 没有&lt;code>storageClassName&lt;/code>的所有PVC只能绑定到没有类的PV。 在这种情况下，没有&lt;code>storageClassName&lt;/code>的PVC的处理方式与将其&lt;code>storageClassName&lt;/code>设置为“”的PVC相同。&lt;/li>
&lt;/ul>
&lt;p>根据挂载方法，挂载过程中可以通过addon manager在Kubernetes群集中部署默认的&lt;code>StorageClass&lt;/code>。&lt;/p>
&lt;p>当PVC指定一个选择器，除了请求一个&lt;code>StorageClass&lt;/code>之外，这些要求被AND组合在一起：只有所请求的类和所请求的标签的PV可能被绑定到PVC。 请注意，当前，具有非空选择器的PVC不能为其动态配置PV。&lt;/p>
&lt;p>在过去，使用了注解&lt;code>volume.beta.kubernetes.io/storage-class&lt;/code>，而不是&lt;code>storageClassName&lt;/code>属性。 该注解仍然可以工作，但在未来的Kubernetes版本中它将不被支持。&lt;/p>
&lt;h2 id="claims-vs-volumes">Claims VS Volumes&lt;/h2>
&lt;p>Pods通过将声明用作卷来访问存储。 声明必须存在于与使用声明的pod相同的命名空间中。 集群在pod的命名空间中查找声明，并使用它来获取支持声明的&lt;code>PersistentVolume&lt;/code>。 然后将卷挂载到主机并进入pod。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mypod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myfrontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dockerfile/nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/var/www/html&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mypd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mypd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeClaim&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">claimName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myclaim&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="关于命名空间的注意">关于命名空间的注意&lt;/h3>
&lt;p>&lt;code>PersistentVolumes&lt;/code>绑定是独占的，并且由于&lt;code>PersistentVolumeClaims&lt;/code>是命名空间对象，因此只能在一个命名空间内挂载“many”模式（ROX，RWX）的声明。&lt;/p>
&lt;h2 id="storageclasses">StorageClasses&lt;/h2>
&lt;p>每个&lt;code>StorageClass&lt;/code>包含字段&lt;code>provisioninger&lt;/code>和&lt;code>parameter&lt;/code>，当属于类型的&lt;code>PersistentVolume&lt;/code>需要动态配置时使用。&lt;/p>
&lt;p>&lt;code>StorageClass&lt;/code>对象的名称很重要，用户可以如何请求特定的类。 管理员在首次创建&lt;code>StorageClass&lt;/code>对象时设置类的名称和其他参数，并且在创建对象后无法更新对象。&lt;/p>
&lt;p>管理员可以仅为不要求任何特定类绑定的PVC指定默认的StorageClass：有关详细信息，请参阅&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaim&lt;/a>部分。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">StorageClass&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">storage.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">standard&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">provisioner&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kubernetes.io/aws-ebs&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">parameters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">gp2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="供应者provisioner">供应者(Provisioner)&lt;/h3>
&lt;p>存储类有一个供应者，它确定用于配置PV的卷插件。必须指定此字段。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Volume Plugin&lt;/th>
&lt;th>Internal Provisioner&lt;/th>
&lt;th>Config Example&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>AWSElasticBlockStore&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#aws">AWS&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AzureFile&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#azure-file">Azure File&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AzureDisk&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#azure-disk">Azure Disk&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CephFS&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cinder&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#openstack-cinder">OpenStack Cinder&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FC&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FlexVolume&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Flocker&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GCEPersistentDisk&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#gce">GCE&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Glusterfs&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#glusterfs">Glusterfs&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iSCSI&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PhotonPersistentDisk&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Quobyte&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#quobyte">Quobyte&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NFS&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RBD&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#ceph-rbd">Ceph RBD&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VsphereVolume&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#vsphere">vSphere&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PortworxVolume&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#portworx-volume">Portworx Volume&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ScaleIO&lt;/td>
&lt;td>✓&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#scaleio">ScaleIO&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>你不限于指定此处列出的“internal”供应者（其名称前缀为“kubernetes.io”并与Kubernetes一起发送）。 你还可以运行和指定外部提供程序，它们是遵循Kubernetes定义的规范的独立程序。 外部提供者的作者对代码的生命周期，供应商的运输状况，运行状况以及使用的卷插件（包括Flex）等都有充分的自主权。存储库kubernetes-incubator /外部存储库包含一个库 用于编写实施大部分规范的外部提供者以及各种社区维护的外部提供者。&lt;/p>
&lt;p>例如，NFS不提供内部提供程序，但可以使用外部提供程序。 一些外部提供者列在存储库kubernetes-incubator/external-storage中。 还有第三方存储供应商提供自己的外部供应商的情况。&lt;/p>
&lt;h3 id="回收策略-1">回收策略&lt;/h3>
&lt;p>由存储类动态创建的持久卷将具有&lt;code>delete&lt;/code>的回收策略。 如果不希望这样做，唯一的当前选项是在创建PV之后编辑PV。&lt;/p>
&lt;p>通过存储类手动创建和管理的持久卷将具有在创建时分配的任何回收策略。&lt;/p>
&lt;h3 id="参数">参数&lt;/h3>
&lt;p>存储类型具有描述属于存储类型的卷的参数。 取决于供应者，可以接受不同的参数。 例如，参数类型的值io1和参数iopsPerGB特定于EBS。 当省略参数时，使用一些默认值。&lt;/p></description></item><item><title>Kubernetes学习 — Macos安装Kubernetes</title><link>https://atbug.com/install-kubernetes-on-macos/</link><pubDate>Thu, 17 Aug 2017 09:44:17 +0000</pubDate><guid>https://atbug.com/install-kubernetes-on-macos/</guid><description>
&lt;h1 id="kubernetes">Kubernetes&lt;/h1>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h2 id="macos">macos&lt;/h2>
&lt;h3 id="检查环境">检查环境&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">sysctl -a &lt;span class="p">|&lt;/span> grep machdep.cpu.features &lt;span class="p">|&lt;/span> grep VMX
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装virtualbox">安装VirtualBox&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">http://download.virtualbox.org/virtualbox/5.1.26/Oracle_VM_VirtualBox_Extension_Pack-5.1.26-117224.vbox-extpack
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装minikube">安装minikube&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.21.0/minikube-darwin-amd64 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod +x minikube &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo mv minikube /usr/local/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建集群">创建集群&lt;/h3>
&lt;p>默认使用virtualbox。&lt;/p>
&lt;p>主机的ip是&lt;code>192.168.31.186&lt;/code>， &lt;code>1087&lt;/code>是proxy的端口。需要将ss的http代理监听地址从&lt;code>127.0.0.1&lt;/code>改为主机的ip。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#启动&lt;/span>
minikube start
&lt;span class="c1">#使用私有库&lt;/span>
minikube start --insecure-registry&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.34&amp;#34;&lt;/span>
&lt;span class="c1">#使用proxy，用于获取镜像&lt;/span>
minikube start --docker-env &lt;span class="nv">HTTP_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.186:1087&amp;#34;&lt;/span> --docker-env &lt;span class="nv">HTTPS_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.186:1087&amp;#34;&lt;/span> --docker-env &lt;span class="nv">NO_PROXY&lt;/span>&lt;span class="o">=&lt;/span>192.168.99.0/24
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装kubectl">安装kubectl&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -Lo kubectl http://storage.googleapis.com/kubernetes-release/release/v1.7.3/bin/darwin/amd64/kubectl &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod +x kubectl &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo mv kubectl /usr/local/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="oh-my-zsh-tab-completion">oh-my-zsh tab completion&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">vi ~/.zshrc
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>添加到plugin部分&lt;br>
plugins=(git zsh-completions kubectl)&lt;/p>
&lt;/blockquote>
&lt;h2 id="使用">使用&lt;/h2>
&lt;h3 id="minikube">minikube&lt;/h3>
&lt;h4 id="检查版本">检查版本&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube version
&lt;span class="c1">#minikube version: v0.21.0&lt;/span>
kubectl version
&lt;span class="c1">#Client Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;3&amp;#34;, GitVersion:&amp;#34;v1.3.0&amp;#34;, GitCommit:&amp;#34;283137936a498aed572ee22af6774b6fb6e9fd94&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2016-07-01T19:26:38Z&amp;#34;, GoVersion:&amp;#34;go1.6.2&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;darwin/amd64&amp;#34;}&lt;/span>
&lt;span class="c1">#Server Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;7&amp;#34;, GitVersion:&amp;#34;v1.7.0&amp;#34;, GitCommit:&amp;#34;d3ada0119e776222f11ec7945e6d860061339aad&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2017-07-26T00:12:31Z&amp;#34;, GoVersion:&amp;#34;go1.8.3&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;linux/amd64&amp;#34;}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="获取集群地址">获取集群地址&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube ip
192.168.99.100
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取服务列表">获取服务列表&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube service list
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="打开dashboard">打开dashboard&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube dashboard
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kubectl">kubectl&lt;/h2>
&lt;h4 id="部署dashboard-ui">部署Dashboard UI&lt;/h4>
&lt;p>默认minikube会自动部署dashboard&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="启动proxy">启动proxy&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl proxy
&lt;span class="c1">#Starting to serve on 127.0.0.1:8001&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="获取pod信息">获取pod信息&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get pods --namespace kube-system
NAME READY STATUS RESTARTS AGE
kube-addon-manager-minikube 0/1 Running &lt;span class="m">0&lt;/span> 1h
kubernetes-dashboard-3313488171-90s64 0/1 Running &lt;span class="m">0&lt;/span> 20m
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果STATUS一直处于&lt;strong>ContainerCreating&lt;/strong>状态，应该是pull image失败。默认是去gcr.io拉镜像，被墙了。需要在启动minikube的时候设置docker使用的代理。&lt;/p>
&lt;h4 id="获取pod详细信息">获取pod详细信息&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">kubectl describe pod kubernetes-dashboard-3313488171-90s64 --namespace kube-system
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="查看log">查看log&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl logs -f kubernetes-dashboard-3313488171-90s64
&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>