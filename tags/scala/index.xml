<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>scala on 乱世浮生</title><link>https://atbug.com/tags/scala/</link><description>Recent content in scala on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 11 Apr 2017 10:15:15 +0000</lastBuildDate><atom:link href="https://atbug.com/tags/scala/index.xml" rel="self" type="application/rss+xml"/><item><title>Scala笔记：用函数字面量块调用高阶函数</title><link>https://atbug.com/call-high-order-function-in-function-literal/</link><pubDate>Tue, 11 Apr 2017 10:15:15 +0000</pubDate><guid>https://atbug.com/call-high-order-function-in-function-literal/</guid><description>
这里会用到几个概念高阶函数、函数字面量、参数组 高阶函数 high-order function 函数的一种，简单来说它包含了一个函数类型的参数或者返回值。 所谓的高阶是跟一阶函数相比，深入一下： 一个或多个参数是函数，并返回一个值。 返回一个函数，但没有参数是函数。 上述两者叠加：一个或多个参数是函数，并返回一个函数。 示例： def stringSafeOp(s: String, f: String =&amp;gt; String) = { if ( s != null) f(s) else s } //stringSafeOp: (s: String, f: String =&amp;gt; String)String def reverse(s: String) = s.reverse //reverse: (s: String)String stringSafeOp(&amp;#34;Ready&amp;#34;, reverse) //res86: String = ydaeR 函数字面量 function literal，其他名字：匿名函数、Lambda表达式等。 函数字面量可以存储在函数值和变量中，或者也可以定义为高阶函数调用的一部分。在任何接受函数类型的地方都可以使用函数字面量。 reverse的函数字面量定义： val reverse = (s:String) =&amp;gt; s.reverse (s:String) =&amp;gt; s.</description></item><item><title>Scala笔记：def VS val</title><link>https://atbug.com/def-vs-val-in-scala/</link><pubDate>Sun, 09 Apr 2017 08:24:40 +0000</pubDate><guid>https://atbug.com/def-vs-val-in-scala/</guid><description>
先说原理： val修饰的在定义的时候执行 def修饰的在调用的时候执行 直观的例子： //注释的行为REPL输出 def test: () =&amp;gt; Int = { println(&amp;#34;def called&amp;#34;) val r = util.Random.nextInt () =&amp;gt; r } //test: () =&amp;gt; Int test() //def called //res82: Int = -950077410 test() //def called //res83: Int = 1027028032 val test: () =&amp;gt; Int = { println(&amp;#34;def called&amp;#34;) val r = util.Random.nextInt () =&amp;gt; r } //def called //test: () =&amp;gt; Int = $$Lambda$1382/338526071@42f2515d test() //res84: Int = 300588352 test() //res84: Int = 300588352 def在方法定义的时候除了新的方法没有任何输出；之后每次调用的时候都会执行一次，而且是每次调用都获得一个新的方法（random值不同） val在方法定义的时候除了新的方法，还会执行并获得一个方法；之后每次调用都只是执行了定义的时候获得的方法（() =&amp;gt; r，r值固定） 进阶 def timer[A](f: =&amp;gt; A) = { def now = System.currentTimeMillis val start = now; val a = f; val end = now println(s&amp;#34;Executed int ${end - start}ms&amp;#34;) a } val veryRandomAmount = timer { util.Random.setSeed(System.currentTimeMillis) for (i &amp;lt;- 1 to 100000) util.Random.nextDouble util.Random.nextDouble } 看过</description></item></channel></rss>