<!DOCTYPE html>
<html>
<head>
    <title>Go In Action 读书笔记 二 // 乱世浮生</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    <meta name="description" content="知我者谓我何忧 不知我者谓我何求.">
    <meta name="keywords" content="Java,Spring Cloud,Architecture,">

        <meta property="og:title" content="Go In Action 读书笔记 二" />
    <meta property="og:description" content="知我者谓我何忧 不知我者谓我何求." />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="zh-cn" />
    <meta property="og:url" content="https://atbug.com/go-in-action-two/" />
    

    <link rel="shortcut icon" href="../favicon.ico">

    <link href="https://atbug.com/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="https://atbug.com/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="https://atbug.com/css/style.css">
    

    <meta name="generator" content="Hugo 0.82.0" />
</head>


<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="https://atbug.com/">乱世浮生</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="../">Home</a>
                
                <a class="main-nav-link" href="../post/">Archives</a>
                
                <a class="main-nav-link" href="../tags/">Tags</a>
                
                <a class="main-nav-link" href="../categories/">Categories</a>
                
                <a class="main-nav-link" href="../about/">About</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        <article class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            <h1 class="article-title" itemprop="name">Go In Action 读书笔记 二</h1>
        </header>
        
        <div class="article-meta">
            <a href="../go-in-action-two/" class="article-date">
                <time datetime='2018-01-01T12:28:04.000&#43;00:00' itemprop="datePublished">2018-01-01</time>
            </a>
            
            
            <div class="post-categories">
                <div class="article-category">
                    
                    
                    <a class="article-category-link" href="https://atbug.com//categories/%E5%AD%A6%E4%B9%A0">学习</a>
                    
                </div>
            </div>
            
            
            <div class="article-comment-link-wrap">
                <a href="../go-in-action-two/#disqus_thread" class="article-comment-link">Comments</a>
            </div>
            
        </div>
        <div class="article-entry" itemprop="articleBody">
            <h2 id="go语言的类型系统">Go语言的类型系统</h2>
<p>Go语言是静态类型的变成语言. 编译的时候需要确定类型.</p>
<h3 id="用户定义的类型">用户定义的类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">user</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span>    <span class="kt">string</span>
    <span class="nx">email</span>   <span class="kt">string</span>
    <span class="nx">ext</span>     <span class="kt">int</span>
    <span class="nx">privileged</span>  <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><p><strong>使用</strong>
零值和<strong>结构字面量</strong>初始化</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//引用类型, 各个字段初始化为对应的零值
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">bill</span> <span class="nx">user</span> <span class="err">#</span><span class="p">{</span>  <span class="mi">0</span> <span class="kc">false</span><span class="p">}</span>
<span class="c1">//创建并初始化, 使用结构字面量
</span><span class="c1"></span><span class="nx">lisa</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">{</span> <span class="c1">//{Lisa lisa@email.com 123 true}
</span><span class="c1"></span>    <span class="nx">name</span><span class="p">:</span> <span class="s">&#34;Lisa&#34;</span><span class="p">,</span>
    <span class="nx">email</span><span class="p">:</span> <span class="s">&#34;lisa@email.com&#34;</span><span class="p">,</span>
    <span class="nx">ext</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
    <span class="nx">privileged</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p><strong>结构字面量的赋值方式:</strong></p>
<ul>
<li>不同行声明每一个字段和对应的值, 字段名和字段以<code>:</code>分隔, 末尾以<code>,</code>结尾</li>
<li>不适用字段名, 只声明对应的值. 写在一行里, 以<code>,</code>分隔, 结尾不需要<code>,</code>. <strong>要保证顺序</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">lisa</span> <span class="o">:=</span> <span class="p">{</span><span class="s">&#34;Lisa&#34;</span><span class="p">,</span> <span class="s">&#34;lisa@email.com&#34;</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="kc">true</span><span class="p">}</span>
</code></pre></div><p><strong>使用其他类型结构声明字段</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">admin</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">person</span>  <span class="nx">user</span>
    <span class="nx">level</span>   <span class="kt">string</span>
<span class="p">}</span>

<span class="nx">fred</span> <span class="o">:=</span> <span class="nx">admin</span><span class="p">{</span> <span class="c1">//{{Fred fred@email.com 123 true} super}
</span><span class="c1"></span>    <span class="nx">person</span><span class="p">:</span> <span class="nx">user</span><span class="p">{</span>
        <span class="nx">name</span><span class="p">:</span> <span class="s">&#34;Fred&#34;</span><span class="p">,</span>
        <span class="nx">email</span><span class="p">:</span> <span class="s">&#34;fred@email.com&#34;</span><span class="p">,</span>
        <span class="nx">ext</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
        <span class="nx">privileged</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">level</span><span class="p">:</span> <span class="s">&#34;super&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p><strong>另一种声明用户定义的类型的方法是, 基于一个已有的类型, 将其作为新类型的类型说明</strong>
新的类型是独立的类型, <em>值互相兼容, 但不能互相赋值</em>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Duration</span> <span class="kt">int64</span>

<span class="kd">var</span> <span class="nx">d</span> <span class="nx">Duration</span>
<span class="c1">//d = int64(1000) #编译错误cannot use int64(1000) (type int64) as type Duration in assignment
</span><span class="c1"></span><span class="nx">d</span> <span class="p">=</span> <span class="nf">Duration</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</code></pre></div><h3 id="方法">方法</h3>
<p>描述用户自定义类型的行为, 实际为函数. 只是在声明的时候在<code>func</code>和方法名之间增加了一个参数(接收者), 将函数和接收者的类型绑定到一起.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">user</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span>  <span class="kt">string</span>
	<span class="nx">email</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="nx">user</span><span class="p">)</span> <span class="nf">notify</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Sending User Email To %s&lt;%s&gt;\n&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">email</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">user</span><span class="p">)</span> <span class="nf">changeEmail</span><span class="p">(</span><span class="nx">email</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">u</span><span class="p">.</span><span class="nx">email</span> <span class="p">=</span> <span class="nx">email</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">bill</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">{</span><span class="s">&#34;Bill&#34;</span><span class="p">,</span> <span class="s">&#34;bill@email.com&#34;</span><span class="p">}</span>
	<span class="nx">bill</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span>

	<span class="nx">lisa</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">{</span><span class="s">&#34;Lisa&#34;</span><span class="p">,</span> <span class="s">&#34;lisa@email.com&#34;</span><span class="p">}</span>
	<span class="nx">lisa</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span> <span class="c1">//实际执行 (*lisa).notify()
</span><span class="c1"></span>
	<span class="nx">bill</span><span class="p">.</span><span class="nf">changeEmail</span><span class="p">(</span><span class="s">&#34;bill@newDomain.com&#34;</span><span class="p">)</span> <span class="c1">//实际执行 (&amp;bill).changeEmail(&#34;bill@newDomain.com&#34;)
</span><span class="c1"></span>	<span class="nx">bill</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span>

	<span class="nx">lisa</span><span class="p">.</span><span class="nf">changeEmail</span><span class="p">(</span><span class="s">&#34;lisa@newDomain.com&#34;</span><span class="p">)</span>
	<span class="nx">lisa</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span> <span class="c1">//实际执行 (*lisa).notify()
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//Sending User Email To Bill&lt;bill@email.com&gt;
</span><span class="c1">//Sending User Email To Lisa&lt;lisa@email.com&gt;
</span><span class="c1">//Sending User Email To Bill&lt;bill@newDomain.com&gt;
</span><span class="c1">//Sending User Email To Lisa&lt;lisa@newDomain.com&gt;
</span></code></pre></div><p>Go语言里有两种类型的接收者: 值接收者和指针接收者.</p>
<ul>
<li>如果使用值接收者, 调用的时候会使用<strong>值的副本</strong>来执行</li>
<li>如果使用指针接收者, 调用的时候这个方法会共享调用方法时接收者所指向的值</li>
</ul>
<h3 id="类型的本质">类型的本质</h3>
<p>声明类型的方法前要确定该方法是创建一个新值(使用值接收者), 还是修改当前值(使用指针接收者)</p>
<h4 id="内置类型">内置类型</h4>
<p>由语言提供: 数值类型, 布尔类型, 字符串类型. 本质上是原始类型.
对这些值增加或删除操作的死后, 都会创建新的值.</p>
<p>如 <code>golang.org/src/strings/strings.go</code>的<code>Trim</code>函数传入字符串值, 返回新的字符串.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Trim</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cutset</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="nx">cutset</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">s</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">TrimFunc</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nf">makeCutsetFunc</span><span class="p">(</span><span class="nx">cutset</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h4 id="引用类型">引用类型</h4>
<p>Go语言里有几种: 切片, 映射, 通道, 接口和函数类型.</p>
<p>声明上述类型的变量时, 创建的变量被称作标头(header)值. 每个引用类型创建的标头值是包含一个指向底层数据结构的指针.
标头值里包含一个指针, 通过复制来传递一个引用类型的值得副本, 本质是就是在共享底层数据结构.</p>
<p><code>golang.org/src/net/ip.go</code></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">IP</span> <span class="p">[]</span><span class="kt">byte</span>
</code></pre></div><h4 id="结构类型">结构类型</h4>
<p>描述一组数据值, 这组值可以是原始类型, 也可以是非原始的.
结构类型的本质是非原始的. 对这个类型的值做增加或者删除的操作应该更改值本身. 当需要修改值本身时, 在程序中其他地方, 需要使用指针来共享这个值.</p>
<p><code>golang.org/time/time.go</code></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Time</span> <span class="kd">struct</span><span class="p">{</span>
    <span class="nx">wall</span> <span class="kt">uint64</span>
    <span class="nx">ext</span>  <span class="kt">int64</span>
    <span class="nx">loc</span> <span class="o">*</span><span class="nx">Location</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Now</span><span class="p">()</span> <span class="nx">Time</span><span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
<span class="c1">//值接收者, 返回新的Time
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">time</span> <span class="nx">Time</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="nx">Time</span><span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">time</span> <span class="nx">Time</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span><span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
<span class="c1">//指针接收者
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Time</span><span class="p">)</span> <span class="nf">UnmarshalBinary</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

</code></pre></div><p>如果一个创建用的工厂函数返回了一个指针, 就表示这个被返回的值的本质是非原始的.
<code>golang.org/src/os/file.go</code>的<code>open</code>函数.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">file</span> <span class="c1">//内嵌类型: 嵌入的指针, 指向一个未公开的类型
</span><span class="c1"></span>          <span class="c1">//一种保护的方式
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">file</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pfd</span>      <span class="nx">poll</span><span class="p">.</span><span class="nx">FD</span>
	<span class="nx">name</span>     <span class="kt">string</span>
	<span class="nx">dirinfo</span>  <span class="o">*</span><span class="nx">dirInfo</span> <span class="c1">// nil unless directory being read
</span><span class="c1"></span>	<span class="nx">nonblock</span> <span class="kt">bool</span>     <span class="c1">// whether we set nonblocking mode
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">OpenFile</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">flag</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">perm</span> <span class="nx">FileMode</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="接口">接口</h3>
<p>多态是指代码可以根据类型的具体实现采取不同行为的能力.
如果一个类型实现了某个接口, 所有使用这个接口的地方, 都可以支持这种类型的值.</p>
<h4 id="标准库">标准库</h4>
<p><code>golang.org/src/io/io.go</code></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">WriterTo</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">WriteTo</span><span class="p">(</span><span class="nx">w</span> <span class="nx">Writer</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//bytes.Buffer实现了io.Reader, io.WriteTo接口
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">b</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span> <span class="s">&#34;World!&#34;</span><span class="p">)</span>
<span class="c1">//os.Stdout实现了io.Writer接口	
</span><span class="c1"></span>	<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="实现">实现</h4>
<p>接口是定义行为的类型, 具体的实现由用户定义的类型完成. 用户定义的类型通常称作实体类型.
如果用户定义的类型实现了某个接口类型声明的一组方法, 那么这个用户定义的类型的<strong>值</strong>就可以赋给这个接口类型的<strong>值</strong>. 这个赋值会把用户定义的类型的<strong>值</strong>存入接口类型的<strong>值</strong>.</p>
<p>接口的值是一个两个字长度的数据结构:</p>
<ul>
<li>第一个字包含一个指向内部表(iTable)的指针. 内部表包含了所存储的值的类型信息, 还包含了与这个值相关联的一组方法.</li>
<li>第二个字是一个指向所存储的值的指针.</li>
</ul>
<p>这部分可以参考<a href="https://blog.golang.org/laws-of-reflection">Laws of Reflecation</a></p>
<h4 id="方法集">方法集</h4>
<p>方法集定义了接口的接受规则.
方法集定义了一组关联到给定类型的值或者指针的方法. 定义方法的时使用的接收者的类型决定了这个方法是关联到值还是关联到指针, 还是两个都关联.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">notifier</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">notify</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">user</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span>  <span class="kt">string</span>
	<span class="nx">email</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="c1">//notify是使用指针接收者实现的方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">user</span><span class="p">)</span> <span class="nf">notify</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Send email to %s&lt;%s&gt;\n&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">email</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">u</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">{</span><span class="s">&#34;Bill&#34;</span><span class="p">,</span> <span class="s">&#34;bill@email.com&#34;</span><span class="p">}</span>
	<span class="c1">//sendNotificationTo(u) //用这一行会有编译错误. user没有实现notifier接口, 赋值给notifier会发生错误
</span><span class="c1"></span>	<span class="nf">sendNotificationTo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">u</span><span class="p">)</span> <span class="c1">//上面notify方法的实现的接收者为 user指针, 因此在赋值的时候只能接受user指针
</span><span class="c1"></span>	                       <span class="c1">//或者上面方法实现的接收者改为user
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//接受一个实现了notifier的值作为参数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sendNotificationTo</span><span class="p">(</span><span class="nx">n</span> <span class="nx">notifier</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><strong>Go语言规范里定义的方法集的规则:</strong></p>
<table>
<thead>
<tr>
<th>Values</th>
<th>Methods Receiver</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>(t T)</td>
</tr>
<tr>
<td>*T</td>
<td>(t T) and (t *T)</td>
</tr>
</tbody>
</table>
<p>T类型的值的方法集只包含值接收者声明的方法. 而指向T类型的指针的方法集既包括指针接收者声明的方法, 也包含值接收者声明的方法.</p>
<p>上面的代码稍微做下修改, 更加清晰一些.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">notifier</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">notify</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">user</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span>  <span class="kt">string</span>
	<span class="nx">email</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="c1">//notify是使用值接收者实现的方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="nx">user</span><span class="p">)</span> <span class="nf">notify</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Send email to %s&lt;%s&gt;\n&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">email</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">u</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">{</span><span class="s">&#34;Bill&#34;</span><span class="p">,</span> <span class="s">&#34;bill@email.com&#34;</span><span class="p">}</span>
	<span class="nf">sendNotificationTo</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span>
	<span class="nf">sendNotificationTo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">u</span><span class="p">)</span> <span class="c1">//&amp;u赋值给notifier的变量n时, n的方法集包含了值接收者实现的方法.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">sendNotificationTo</span><span class="p">(</span><span class="nx">n</span> <span class="nx">notifier</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>或者换个角度, 从接收者来看.</p>
<table>
<thead>
<tr>
<th>Method Receiver</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>(t T)</td>
<td>T and *T</td>
</tr>
<tr>
<td>(t *T)</td>
<td>*T</td>
</tr>
</tbody>
</table>
<p>使用指针接收者实现的接口, 那只有指向那个类型的指针才能实现对应的接口. 使用值接收者实现的接口, 那么那个类型的值和指针都能够实现对应的接口.</p>
<h4 id="多态">多态</h4>
<p>上面的函数<code>sendNotificationTo</code>其实就是一个多态函数.</p>
<h3 id="嵌入类型">嵌入类型</h3>
<p>type embedding, Go语言允许用户扩展或者修改已有类型的行为. 可用于代码复用, 或修改已有类型以符合新类型.
嵌入类型是将已有类型直接声明在新的结构类型里. 被嵌入的类型称为新的外部类型的内部类型.</p>
<p>通过嵌入类型, 与内部类型相关的标识符会提升到外部类型上, 也成为外部类型的一部分. 外部类型也可以通过声明相同名称的标识符来覆盖内部类型的标识符的字段或者方法, 这就是修改内部类型的属性或者行为实现. 也可以添加新的字段和方法.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">notifier</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">notify</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">user</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span>  <span class="kt">string</span>
	<span class="nx">email</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">admin</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">//外部类型
</span><span class="c1"></span>	<span class="nx">user</span> <span class="c1">//内部类型
</span><span class="c1"></span>	<span class="nx">level</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">user</span><span class="p">)</span> <span class="nf">notify</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Send email to %s&lt;%s&gt;\n&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">email</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ad</span> <span class="o">:=</span> <span class="nx">admin</span> <span class="p">{</span>
		<span class="nx">user</span><span class="p">:</span> <span class="nx">user</span><span class="p">{</span>
			<span class="nx">name</span><span class="p">:</span> <span class="s">&#34;John&#34;</span><span class="p">,</span>
			<span class="nx">email</span><span class="p">:</span> <span class="s">&#34;john@email.com&#34;</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="nx">level</span><span class="p">:</span> <span class="s">&#34;super&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	
	<span class="nx">ad</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span> <span class="c1">//可以直接访问内部类型的方法
</span><span class="c1"></span>	<span class="nx">ad</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span> <span class="c1">//内部类型的方法也被提升到外部类型
</span><span class="c1"></span>	<span class="nf">endNotificationTo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ad</span><span class="p">)</span> <span class="c1">//由于内部类型的提升, 内部类型实现的接口也被提升到外部类型. 外部类型也可以提供同名的方法实现, 以达到覆盖的效果.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">sendNotificationTo</span><span class="p">(</span><span class="nx">n</span> <span class="nx">notifier</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>如果外部类型做了方法覆盖, 对内部类型方法的访问也还是会继续执行内部类型的方法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ad</span> <span class="o">*</span><span class="nx">admin</span><span class="p">)</span> <span class="nf">notify</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
<span class="nx">ad</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span> <span class="c1">//执行内部类型的方法
</span><span class="c1"></span><span class="nx">ad</span><span class="p">.</span><span class="nf">notify</span><span class="p">()</span> <span class="c1">//执行外部类型的方法
</span></code></pre></div><h3 id="公开或未公开的标识符">公开或未公开的标识符</h3>
<p>使用规则来控制声明后的标识符的可见性. Go语言支持从包里公开或者隐藏表示. 这里的标识符包括类型, 变量, 方法.
当一个标识符的名字是小写开头的时候, 这个标识符就是未公开的. 如果是大写字母开头就是公开的, 包外的代码可见.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">user</span>
<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span><span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span> <span class="c1">//公开字段
</span><span class="c1"></span>    <span class="nx">email</span> <span class="kt">string</span> <span class="c1">//未公开字段
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//构造器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">email</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">user</span><span class="p">{</span><span class="nx">name</span><span class="p">,</span> <span class="nx">email</span><span class="p">}</span>
<span class="p">}</span>

<span class="o">---------------</span>
<span class="kn">package</span> <span class="nx">another</span>
<span class="c1">//在另一个包里使用User类型
</span><span class="c1"></span><span class="nx">u</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">{</span>
    <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Bill&#34;</span><span class="p">,</span>
    <span class="nx">email</span><span class="p">:</span> <span class="s">&#34;bill@email.com&#34;</span><span class="p">,</span> <span class="c1">//编译器报错, 找不到email字段. 因为email字段未公开
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//使用构造器
</span><span class="c1"></span><span class="nx">ur</span> <span class="p">:</span> <span class="nx">user</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Bill&#34;</span><span class="p">,</span> <span class="s">&#34;bill@email.com&#34;</span><span class="p">)</span>
</code></pre></div><ul>
<li>公开或者未公开的标识符, 不是一个值</li>
<li>短变量声明操作符(:=), 有能力捕获引用的类型, 并创建一个未公开的类型的变量.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">counter</span>
<span class="kd">type</span> <span class="nx">alertCounter</span> <span class="kt">int</span> <span class="c1">//未公开类型
</span><span class="c1"></span><span class="o">---------------</span>

<span class="kn">package</span> <span class="nx">another</span>
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//c = counter.alertCounter 编译会报错, 无法访问未公开标识符
</span><span class="c1"></span>    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">counter</span><span class="p">.</span><span class="nf">alertCounter</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span> <span class="c1">// 20
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
        </div>

        
        
        <div class="article-toc" >
            <h3></h3>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#go语言的类型系统">Go语言的类型系统</a>
      <ul>
        <li><a href="#用户定义的类型">用户定义的类型</a></li>
        <li><a href="#方法">方法</a></li>
        <li><a href="#类型的本质">类型的本质</a></li>
        <li><a href="#接口">接口</a></li>
        <li><a href="#嵌入类型">嵌入类型</a></li>
        <li><a href="#公开或未公开的标识符">公开或未公开的标识符</a></li>
      </ul>
    </li>
  </ul>
</nav>
            <div>扫码关注第一时间获取文章更新</div>
            <ul>
                <img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/23/qrcode.jpg" alt="qrcode">
            </ul>
        </div>
        
        

        


        
        <footer class="article-footer">
            <ul class="article-tag-list">
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="https://atbug.com//tags/go">Go
                    </a>
                </li>
                
            </ul>
        </footer>
        <div class="article-entry">
            <hr>
            <p>文章同步更新在公众号：云编码 (微信号：sevenfeet)，扫码关注第一时间获取文章更新。</p>
            <p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/23/qrcode.jpg" alt="qrcode"></p>
        </div>
        
    </div>
    
<nav id="article-nav">
    
    <a href="../go-in-action-three/" id="article-nav-newer" class="article-nav-link-wrap">
        <div class="article-nav-title"><span>&lt;</span>&nbsp;
            Go In Action 读书笔记 三
        </div>
    </a>
    
    
    <a href="../go-in-action-one/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">Go In Action 读书笔记 一&nbsp;<span>&gt;</span></div>
    </a>
    
</nav>


</article>

        
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "addozhang" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2021 Addo Zhang
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-47966140-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css" integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>
