<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>微服务 on 乱世浮生</title><link>https://atbug.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link><description>Recent content in 微服务 on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 26 May 2021 07:37:04 +0800</lastBuildDate><atom:link href="https://atbug.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Quarkus 和 MicroProfile 实现微服务特性</title><link>https://atbug.com/microservicilities-quarkus/</link><pubDate>Wed, 26 May 2021 07:37:04 +0800</pubDate><guid>https://atbug.com/microservicilities-quarkus/</guid><description>
&lt;p>Quarkus 的文章之前写过三篇了，讲过了 Quarkus 的小而快。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/YcEqFm3oxlsEvJ3ckRbQyA">Hello, Quarkus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/Dq3hQrXE4XWH-MyjBAGMEw">应&amp;quot;云&amp;quot;而生的 Java 框架 Quarkus：构建本机可执行文件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/1eqjYC36O3qm1XDw84aAPA">谁说 Java 不能用来跑 Serverless？&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一直在酝酿写一篇 Quarkus 生态相关的，因为最近一直在忙 Meetup 的事情而搁浅。正好看到了这篇文章，就拿来翻译一下，补全云原生中的“微服务”这一块。&lt;/p>
&lt;p>本文译自&lt;a href="https://www.infoq.com/articles/microservicilities-quarkus">《Implementing Microservicilities with Quarkus and MicroProfile》&lt;/a> 。&lt;/p>
&lt;hr>
&lt;h2 id="为什么要使用微服务特性">为什么要使用微服务特性？&lt;/h2>
&lt;p>在微服务架构中，一个应用程序是由几个相互连接的服务组成的，这些服务一起工作来实现所需的业务功能。&lt;/p>
&lt;p>因此，典型的企业微服务架构如下所示：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855266680.jpg" alt="">&lt;/p>
&lt;p>刚开始，使用微服务架构实现应用程序看起来很容易。&lt;/p>
&lt;p>但是，因为有了单体架构没有一些新的挑战，因此做起来并不容器&lt;/p>
&lt;p>举几个例子，比如容错、服务发现、扩展性、日志记录和跟踪。&lt;/p>
&lt;p>为了解决这些挑战，每个微服务都应实现我们在 Red Hat 所说的“微服务特性”。&lt;/p>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 该术语是指除业务逻辑以外，服务还必须实现来解决的跨领域关注点清单，如下图所示：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855419604.jpg" alt="">&lt;/p>
&lt;p>可以用任何语言（Java、Go、JavaScript）或任何框架（Spring Boot、Quarkus）实现业务逻辑，但是围绕业务逻辑，应实现以下关注点：&lt;/p>
&lt;p>&lt;strong>API&lt;/strong>：可通过一组定义的 API 操作来访问该服务。例如，对于 RESTful Web API，HTTP 用作协议。此外，可以使用诸如 Swagger 之类的工具来记录 API 。
&lt;strong>服务发现（Discovery）&lt;/strong>：服务需要发现其他服务。&lt;/p>
&lt;p>&lt;strong>调用服务（Invocation）&lt;/strong>：发现服务后，需要使用一组参数对其进行调用，并选择性地返回响应。&lt;/p>
&lt;p>&lt;strong>弹性（Elasticity）&lt;/strong>：微服务架构的重要特征之一是每个服务都是弹性的，这意味着可以根据系统的关键程度或当前的工作量等参数独立地进行缩放。（译者注：这里的弹性只是资源的弹性）&lt;/p>
&lt;p>&lt;strong>弹性（Resiliency）&lt;/strong>：在微服务架构中，我们在开发时应牢记失败，尤其是在与其他服务进行通信时。在单体应用中，整个应用程序处于启动或关闭状态。但是，当此应用程序分解为微服务体系结构时，该应用程序由多个服务组成，并且所有这些服务都通过网络互连，这意味着该应用程序的某些部分可能正在运行，而其他部分可能会失败。遏制故障对避免通过其他服务传播错误很重要。弹性（或应用程序弹性）是应用程序/服务对问题做出反应并仍然提供最佳结果的能力。（译者注：这里的弹性与容错相关，对失败处理的弹性）&lt;/p>
&lt;p>&lt;strong>管道（Pipeline）&lt;/strong>：服务应独立部署，而无需进行任何形式的编排。因此，每个服务应具有自己的部署管道。&lt;/p>
&lt;p>&lt;strong>身份验证（Authentication）&lt;/strong>：关于微服务体系结构中的安全性的关键方面之一是如何对内部服务之间的调用进行身份验证/授权。Web 令牌（通常是令牌）是在内部服务中安全地表示声明的首选方式。&lt;/p>
&lt;p>&lt;strong>日志记录（Logging）&lt;/strong>：在单体应用程序中，日志记录很简单，因为该应用程序的所有组件都在同一节点上运行。然后现在组件以服务的形式分布在多个节点上，因此，要拥有完整的日志记录视图，需要一个统一的日志记录系统/数据收集器。&lt;/p>
&lt;p>&lt;strong>监控（Monitoring）&lt;/strong>：衡量系统的性能、了解应用程序的整体运行状况，以及在出现问题时发出警报是保持基于微服务的应用程序正确运行的关键方面。监控是控制应用程序的关键方面。&lt;/p>
&lt;p>&lt;strong>跟踪（Tracing）&lt;/strong>：跟踪用于可视化程序的流程和数据进度。作为开发人员/运维人员，当我们需要检查用户在整个应用程序中的行程时，这特别有用。&lt;/p>
&lt;p>Kubernetes正在成为部署微服务的实际工具。这是一个用于自动化、编排、扩展和管理容器的开源系统。&lt;/p>
&lt;p>使用 Kubernetes 时，十个微服务特性中只有三个被涵盖。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855537970.jpg" alt="">&lt;/p>
&lt;p>**服务发现 **是通过 &lt;em>Kubernetes 服务&lt;/em>的概念实现的。它提供了一种使用稳定的虚拟 IP 和 DNS 名称将 Kubernetes Pod 分组（作为一个整体）的方法。发现服务只是使用 Kubernetes 的服务名作为 hostname 进行请求。&lt;/p>
&lt;p>使用 Kubernetes 可以很容易地&lt;strong>调用服务&lt;/strong>，因为平台本身提供了调用任何服务所需的网络。&lt;/p>
&lt;p>从一开始，Kubernetes 就一直在考虑&lt;strong>弹性&lt;/strong>（或可伸缩性），例如运行时&lt;code>kubectl scale deployment myservice --replicas=5 command&lt;/code>，myservice deployment 可伸缩至五个副本或实例。Kubernetes 平台负责寻找合适的节点，部署服务并始终保持所需数量的副本并正常运行。&lt;/p>
&lt;p>但是其余的微服务特性又如何呢？Kubernetes 仅涵盖其中的三个，那么我们如何实现剩下的呢？&lt;/p>
&lt;p>根据所使用的语言或框架，可以遵循的策略很多。但是在本文中，我们将了解如何使用 &lt;a href="https://quarkus.io/">Quarkus&lt;/a> 实现其中的一些&lt;a href="https://quarkus.io/">策略&lt;/a>。&lt;/p>
&lt;h2 id="什么是-quarkus">什么是 Quarkus？&lt;/h2>
&lt;p>&lt;a href="https://quarkus.io/">Quarkus&lt;/a> 是针对 Java 虚拟机（JVM）和本机编译的全栈 Kubernetes 本地 Java 框架，专门针对容器优化 Java，使其成为无服务器（Serverless）、云和 Kubernetes 环境的高效平台。&lt;/p>
&lt;p>Instead of reinventing the wheel, Quarkus uses well-known enterprise-grade frameworks backed by standards/specifications and makes them compilable to a binary using &lt;a href="https://www.graalvm.org/">GraalVM&lt;/a>.
Quarkus不用重新发明轮子，而是使用以标准/规范为后盾的知名企业级框架，并使用 &lt;a href="https://www.graalvm.org/">GraalVM&lt;/a> 将其编译为二进制&lt;a href="https://www.graalvm.org/">文件&lt;/a>。&lt;/p>
&lt;h2 id="什么是-microprofile">什么是 MicroProfile？&lt;/h2>
&lt;p>Quarkus 与 &lt;a href="https://microprofile.io/">MicroProfile&lt;/a> 规范集成，从而将企业 Java 生态系统迁移到微服务体系结构中。&lt;/p>
&lt;p>在下图中，我们看到了构成 MicroProfile 规范的所有 API。某些 API（例如 CDI、JSON-P 和 JAX-RS）基于 &lt;a href="https://jakarta.ee/">Jakarta EE&lt;/a>（以前的 Java EE）规范。其余的由 Java 社区开发。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855657899.jpg" alt="">&lt;/p>
&lt;p>Let’s implement API, invocation, resilience, authentication, logging, monitoring, and tracing microservicilities using Quarkus.
让我们使用Quarkus实现API、调用、弹性、身份验证、日志记录、监视和跟踪微服务特性。&lt;/p>
&lt;h2 id="如何使用-quarkus-实现微服务特性">如何使用 Quarkus 实现微服务特性&lt;/h2>
&lt;h3 id="入门">入门&lt;/h3>
&lt;p>开始使用 Quarkus 的最快方法是通过在&lt;a href="https://code.quarkus.io/">开始页面&lt;/a>中选择所需的依赖。对于当前示例，选择如下依赖关系以满足微服务需求：&lt;/p>
&lt;p>API：RESTEasy JAX-RS、RESTEasy JSON-B、OpenAPI
调用：REST Client JSON-B
弹性：Fault Tolerance
认证：JWT
记录：GELF
监控：Micrometer metrics
跟踪：OpenTracing&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855795760.jpg" alt="">&lt;/p>
&lt;p>我们可以手动选择各自的依赖关系，或浏览以下链接 &lt;a href="https://code.quarkus.io/?a=microservicilities-quarkus&amp;amp;e=resteasy&amp;amp;e=resteasy-jsonb&amp;amp;e=rest-client-jsonb&amp;amp;e=smallrye-jwt&amp;amp;e=smallrye-openapi&amp;amp;e=logging-gelf&amp;amp;e=smallrye-fault-tolerance&amp;amp;e=micrometer&amp;amp;e=smallrye-opentracing">Quarkus 微服务特性生成器&lt;/a>，所有这些都会被选中。然后按“生成应用程序”按钮以下载包含支架应用程序的zip文件。&lt;/p>
&lt;h3 id="服务">服务&lt;/h3>
&lt;p>对于当前示例，仅使用两个服务生成了一个非常简单的应用程序。一个名为“&lt;em>评级服务 rating service&lt;/em>”的服务返回给定书籍的评级，而另一个名为“&lt;em>书籍服务 book service&lt;/em>”的服务则返回一本书的信息及其评级。服务之间的所有调用都必须经过身份验证。&lt;/p>
&lt;p>在下图中，我们看到了整个系统的概述：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219855936882.jpg" alt="">&lt;/p>
&lt;p>&lt;em>评级服务&lt;/em>已经开发并作为 Linux 容器提供。通过运行以下命令，在端口 9090 上启动服务：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --rm -ti -p 9090:8080
quay.io/lordofthejars/rating-service:1.0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>要验证服务，请向 http://localhost:9090/rate/1 发出请求&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl localhost:8080/rate/1 -vv
&amp;gt; GET /rate/1 HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; User-Agent: curl/7.64.1
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 &lt;span class="m">401&lt;/span> Unauthorized
&amp;lt; www-authenticate: Bearer &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span>
&amp;lt; Content-Length: &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回的状态码是 &lt;code>401 Unauthorized&lt;/code> 因为没有在请求中携带令牌（JWT）提供授权信息。只有带有 &lt;em>group &lt;code>Echoer&lt;/code>&lt;/em> 有效令牌才能访问评级服务。&lt;/p>
&lt;h3 id="api">API&lt;/h3>
&lt;p>Quarkus 使用众所周知的 JAX-RS 规范来定义 RESTful Web API。在幕后，Quarkus 使用 RESTEasy 实现直接与 Vert.X 框架一起使用，而无需使用 Servlet 技术。&lt;/p>
&lt;p>让我们为实现最常见操作的图书服务定义一个 API：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Consumes&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.DELETE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.GET&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.POST&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Path&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.PathParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Produces&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.QueryParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.MediaType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.Response&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.UriBuilder&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/book&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">BookResource&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="nd">@POST&lt;/span>
&lt;span class="nd">@Consumes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">getBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Book&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">created&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">UriBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">fromResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">BookResource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">book&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">bookId&lt;/span>&lt;span class="o">))&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">())&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@DELETE&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">delete&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">noContent&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;search&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">searchBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@QueryParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;description&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">description&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// logic
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">ok&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">books&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先要注意的是，定义了四个不同的端点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GET /book/{bookId}&lt;/code> 使用 GET HTTP 方法返回带有其评级的图书信息。return 元素会自动解编为 JSON。&lt;/li>
&lt;li>&lt;code>POST /book&lt;/code> 使用 POST HTTP 方法插入一本书作为正文内容。正文内容会自动从 JSON 编组到 Java 对象。&lt;/li>
&lt;li>&lt;code>DELETE /book/{bookId}&lt;/code> 使用 DELETE HTTP 方法通过书的 ID 删除书。&lt;/li>
&lt;li>&lt;code>GET /book/search?description={description}&lt;/code> 按书名搜索书籍。&lt;/li>
&lt;/ul>
&lt;p>注意的第二件事是返回类型，有时是 Java 对象，有时是 Java 实例 &lt;code>javax.ws.rs.core.Response&lt;/code>。使用 Java 对象时，会将其从 Java 对象序列化为 &lt;code>@Produces&lt;/code> 注解中设置的媒体类型。在此特定服务中，输出为 JSON 文档。通过该 &lt;code>Response&lt;/code> 对象，我们可以对返回给调用方的内容进行细粒度的控制。可以设置 HTTP 状态代码、标头或返回给调用方的内容。取决于使用场景，是偏爱一种方法而不是另一种方法。&lt;/p>
&lt;h3 id="调用">调用&lt;/h3>
&lt;p>在定义了用于访问&lt;em>图书服务&lt;/em>的 API 之后，是时候开发一段代码来调用&lt;em>评级服务&lt;/em>以检索图书的评级了。&lt;/p>
&lt;p>Quarkus 使用 &lt;a href="https://github.com/eclipse/microprofile-rest-client">MicroProfile Rest Client&lt;/a> 规范来访问外部（HTTP）服务。它提供了一种类型安全的方法，以通过某些 JAX-RS 2.0 API 通过 HTTP 调用 RESTful 服务，以实现一致性和更易于重用。&lt;/p>
&lt;p>要创建的第一个元素是一个使用 JAX-RS 批注表示远程服务的接口。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.GET&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Path&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.PathParam&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.Produces&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.ws.rs.core.MediaType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.rest.client.inject.RegisterRestClient&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/rate&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RegisterRestClient&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">RatingService&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the getRate() method is called, a remote HTTP call is invoked at /rate/{bookId} replacing the bookId with the value set in the method parameter. It is important to annotate the interface with the @RegisterRestClient annotation.
Then the RatingService interface needs to be injected into BookResource to execute the remote calls.
当 &lt;code>getRate() &lt;/code>方法被调用时，远程 HTTP 请求在调用 &lt;code>/rate/{bookId}&lt;/code> 替换 &lt;code>bookId&lt;/code> 用在该方法中的参数值集合。用 &lt;code>@RegisterRestClient&lt;/code> 注解对接口进行注解很重要。&lt;/p>
&lt;p>然后 &lt;code>RatingService&lt;/code> 需要将接口注入 &lt;code>BookResource&lt;/code> 以执行远程调用。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.rest.client.inject.RestClient&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@RestClient&lt;/span>
&lt;span class="n">RatingService&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Book&lt;/span> &lt;span class="n">book&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findBook&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The @RestClient annotation injects a proxied instance of the interface, providing the implementation of the client.
The last thing is to configure the service location (the hostname part). In Quarkus, the configuration properties are set in src/main/resources/application.properties file. To configure the location of the service, we need to use the fully qualified name of the Rest Client interface with URL as key, and the location as a value:
该 &lt;code>@RestClient&lt;/code> 注解注入界面的代理实例，提供客户端的实现。&lt;/p>
&lt;p>最后一件事是配置服务位置（&lt;em>hostname&lt;/em> 部分）。在 Quarkus 中，配置属性在 &lt;code>src/main/resources/application.properties&lt;/code> 文件中设置。要配置服务的位置，我们需要使用 Rest Client 接口的标准名称，其中 URL 作为键，而 location 作为值：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.acme.RatingService/mp-rest/url=http://localhost:9090
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在正确访问&lt;em>评估服务&lt;/em>而没有 &lt;code>401 Unauthorized&lt;/code> 问题之前，必须解决相互认证问题。&lt;/p>
&lt;h3 id="身份验证">身份验证&lt;/h3>
&lt;p>基于令牌的身份验证机制允许系统基于安全令牌对身份进行身份验证、授权和验证。Quarkus 与 &lt;a href="https://github.com/eclipse/microprofile-jwt-auth">MicroProfile JWT RBAC 安全&lt;/a>规范集成在一起，以使用 JWT 令牌保护服务。&lt;/p>
&lt;p>要使用 MicroProfile JWT RBAC 安全性保护端点，我们只需要使用批注对方法进行 &lt;code>@RolesAllowed&lt;/code> 注解。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RolesAllowed&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Echoer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，我们配置令牌的发行方和公钥的位置，以验证令牌在 &lt;code>application.properties&lt;/code> 文件中的签名：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">mp.jwt.verify.publickey.location=https://raw.githubusercontent.com/redhat-developer-demos/quarkus-tutorial/master/jwt-token/quarkus.jwt.pub
mp.jwt.verify.issuer=https://quarkus.io/using-jwt-rbac
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此扩展名自动验证：令牌有效；发行方是正确的；令牌尚未修改；签名有效；没有过期。&lt;/p>
&lt;p>这两种&lt;em>图书服务&lt;/em>和&lt;em>评级服务&lt;/em>现在是由同一 JWT 发行方和密钥保护，因此服务之间的通信要求验证提供在令牌的有效承载用户 &lt;code>Authentication&lt;/code> 头部。&lt;/p>
&lt;p>&lt;em>评级服务&lt;/em>启动和运行，让我们开始用下面的命令&lt;em>图书服务&lt;/em>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">./mvnw compile quarkus:dev
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we can make a request to get book information providing a valid JSON Web Token as a bearer token.
The generation of the token is out of the scope of this article, and a token has been already generated:
最后，我们可以请求获取提供有效 JSON Web 令牌作为承载令牌的图书信息。&lt;/p>
&lt;p>令牌的生成不在本文的讨论范围之内，并且已经生成了令牌：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856429022.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">curl -H &amp;#34;Authorization: Bearer eyJraWQiOiJcL3ByaXZhdGVLZXkucGVtIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJqZG9lLXVzaW5nLWp3dC1yYmFjIiwiYXVkIjoidXNpbmctand0LXJiYWMiLCJ1cG4iOiJqZG9lQHF1YXJrdXMuaW8iLCJiaXJ0aGRhdGUiOiIyMDAxLTA3LTEzIiwiYXV0aF90aW1lIjoxNTcwMDk0MTcxLCJpc3MiOiJodHRwczpcL1wvcXVhcmt1cy5pb1wvdXNpbmctand0LXJiYWMiLCJyb2xlTWFwcGluZ3MiOnsiZ3JvdXAyIjoiR3JvdXAyTWFwcGVkUm9sZSIsImdyb3VwMSI6Ikdyb3VwMU1hcHBlZFJvbGUifSwiZ3JvdXBzIjpbIkVjaG9lciIsIlRlc3RlciIsIlN1YnNjcmliZXIiLCJncm91cDIiXSwicHJlZmVycmVkX3VzZXJuYW1lIjoiamRvZSIsImV4cCI6MjIwMDgxNDE3MSwiaWF0IjoxNTcwMDk0MTcxLCJqdGkiOiJhLTEyMyJ9.Hzr41h3_uewy-g2B-sonOiBObtcpkgzqmF4bT3cO58v45AIOiegl7HIx7QgEZHRO4PdUtR34x9W23VJY7NJ545ucpCuKnEV1uRlspJyQevfI-mSRg1bHlMmdDt661-V3KmQES8WX2B2uqirykO5fCeCp3womboilzCq4VtxbmM2qgf6ag8rUNnTCLuCgEoulGwTn0F5lCrom-7dJOTryW1KI0qUWHMMwl4TX5cLmqJLgBzJapzc5_yEfgQZ9qXzvsT8zeOWSKKPLm7LFVt2YihkXa80lWcjewwt61rfQkpmqSzAHL0QIs7CsM9GfnoYc0j9po83-P3GJiBMMFmn-vg&amp;#34; localhost:8080/book/1 -v
&lt;/code>&lt;/pre>&lt;/div>&lt;p>响应又是 forbidden 错误：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&amp;lt; HTTP/1.1 401 Unauthorized
&amp;lt; Content-Length: 0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可能想知道为什么在提供有效令牌后仍然出现此错误。如果我们检查图书服务的控制台，就会发现抛出了以下异常：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.jboss.resteasy.client.exception.ResteasyWebApplicationException: Unknown error, status code 401
at org.jboss.resteasy.client.exception.WebApplicationExceptionWrapper.wrap(WebApplicationExceptionWrapper.java:107)
at org.jboss.resteasy.microprofile.client.DefaultResponseExceptionMapper.toThrowable(DefaultResponseExceptionMapper.java:21)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发生此异常的原因是，我们已获得身份验证并有权访问&lt;em>图书服务&lt;/em>，但承载令牌尚未传播到&lt;em>评级服务&lt;/em>。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856618998.jpg" alt="">&lt;/p>
&lt;p>为了自动将 &lt;code>Authorization&lt;/code> 标头从传入请求传播到其余客户端请求，需要进行两次修改。&lt;/p>
&lt;p>第一个修改是修改 Rest Client 界面，并使用对其进行注解 &lt;code>org.eclipse.microprofile.rest.client.inject.RegisterClientHeaders&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/rate&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RegisterRestClient&lt;/span>
&lt;span class="nd">@RegisterClientHeaders&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">RatingService&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二个修改是配置在请求之间传播哪些标头。这是在 &lt;code>application.properties&lt;/code> 文件中设置的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"> org.eclipse.microprofile.rest.client.propagateHeaders=Authorization
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行与之前相同的 curl 命令，我们将获得正确的输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&amp;lt; HTTP/1.1 &lt;span class="m">200&lt;/span> OK
&amp;lt; Content-Length: &lt;span class="m">39&lt;/span>
&amp;lt; Content-Type: application/json
&amp;lt;
* Connection &lt;span class="c1">#0 to host localhost left intact&lt;/span>
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:2,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 2&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:1&lt;span class="o">}&lt;/span>* Closing connection &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="弹性">弹性&lt;/h3>
&lt;p>在微服务架构中，具有容错能力很重要，这样可以避免故障从一个服务传播到该服务的所有直接和间接调用方。Quarkus 将 &lt;a href="https://github.com/eclipse/microprofile-fault-tolerance">MicroProfile Fault Tolerance&lt;/a> 规范与以下用于处理故障的注释集成在一起：&lt;/p>
&lt;p>●    &lt;code>@Timeout&lt;/code>：定义抛出异常之前执行的最长时间。
●    &lt;code>@Retry&lt;/code>：如果调用失败，请再次重试执行。
●    &lt;code>@Bulkhead&lt;/code>：限制并发执行，以使该区域中的故障不会使整个系统过载。
●    &lt;code>@CircuitBreaker&lt;/code>：执行反复失败时，将自动进行快速故障切换。
●    &lt;code>@Fallback&lt;/code>：执行失败时，提供备用解决方案/默认值。&lt;/p>
&lt;p>让我们添加三次重试，其中重试之间的延迟计时器为一秒，以防访问&lt;em>评级服务&lt;/em>时发生错误。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Retry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxRetries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，停止&lt;em>评级服务&lt;/em>并执行请求。引发以下异常：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">org.jboss.resteasy.spi.UnhandledException: javax.ws.rs.ProcessingException: RESTEASY004655: Unable to invoke request:
org.apache.http.conn.HttpHostConnectException: Connect to localhost:9090 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused
&lt;/code>&lt;/pre>&lt;/div>&lt;p>显然，这里存在错误，但是请注意，由于执行了三次重试（延迟一秒），因此引发异常之前，经过了三秒钟。&lt;/p>
&lt;p>在这种情况下，&lt;em>评级服务&lt;/em>已关闭，因此无法进行恢复，但是在一个实际示例中，&lt;em>评级服务&lt;/em>可能仅在短时间内就恢复了，或者部署了该服务的多个副本，因此可以简单地重试操作可能足以恢复并提供有效的响应。&lt;/p>
&lt;p>但是，当引发异常时重试次数不够时，我们可以将错误传播给调用方，也可以为调用提供替代值。这种选择可以是对另一个系统的调用（即分布式缓存）或静态值。&lt;/p>
&lt;p>对于此用例，当与评级服务的连接失败时，将返回评级值 0。&lt;/p>
&lt;p>要实现回退逻辑，首先要做的是实现将 &lt;code>org.eclipse.microprofile.faulttolerance.FallbackHandler&lt;/code> 返回类型设置为与回退策略方法提供的替代类型相同的接口。对于这种情况，将 &lt;code>Rate&lt;/code> 返回默认对象。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.faulttolerance.ExecutionContext&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.eclipse.microprofile.faulttolerance.FallbackHandler&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">RatingServiceFallback&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">FallbackHandler&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rate&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="nf">handle&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ExecutionContext&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Rate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">rate&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rate&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后要做的是用注解对 &lt;code>getRating()&lt;/code> 方法进行 &lt;code>@org.eclipse.microprofile.faulttolerance.Fallback&lt;/code> 注解，以配置无法恢复时要执行的回退类。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Retry&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxRetries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Fallback&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RatingServiceFallback&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">Rate&lt;/span> &lt;span class="nf">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果重复与以前相同的请求，则不会引发任何异常，但是有效值的输出将 rating 字段设置为 0。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">* Connection #0 to host localhost left intact
{&amp;#34;bookId&amp;#34;:2,&amp;#34;name&amp;#34;:&amp;#34;Book 2&amp;#34;,&amp;#34;rating&amp;#34;:0}* Closing connection 0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>规范提供的任何其他策略都可以使用相同的方法。例如，对于断路器模式：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@CircuitBreaker&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">requestVolumeThreshold&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">4&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">failureRatio&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">75&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在四个连续调用的滚动窗口中发生了三个（&lt;em>4 x 0.75&lt;/em>）故障，则电路将断开 1000 ms，然后恢复到半断开状态。如果在半开时调用成功，则将其再次关闭。否则，它将保持打开状态&lt;/p>
&lt;h3 id="日志记录">日志记录&lt;/h3>
&lt;p>在微服务架构中，建议将所有服务的日志收集在一个统一的日志中，以更有效地使用和理解。&lt;/p>
&lt;p>一种解决方案是使用 &lt;a href="https://www.fluentd.org/">Fluentd&lt;/a>，它是 &lt;a href="https://www.fluentd.org/">Kubernetes&lt;/a> 中用于统一日志记录层的开源数据收集器。Quarkus 使用 Graylog 扩展日志格式（GELF）与 Fluentd 集成。&lt;/p>
&lt;p>集成真的很简单。首先，与其他任何 Quarkus 应用程序一样使用日志逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.jboss.logging.Logger&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Logger&lt;/span> &lt;span class="n">LOG&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getLogger&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">BookResource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="nd">@GET&lt;/span>
&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/{bookId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@RolesAllowed&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Echoer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Produces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MediaType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">APPLICATION_JSON&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="nf">book&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@PathParam&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;bookId&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">Long&lt;/span> &lt;span class="n">bookId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">LOG&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Get Book&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，启用 GELF 格式并设置 Fluentd 服务器位置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">quarkus.log.handler.gelf.enabled=true
quarkus.log.handler.gelf.host=localhost
quarkus.log.handler.gelf.port=12201
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，我们可以向记录的端点发出请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出方面没有任何变化，但是日志行已传输到 Fluentd。如果使用 &lt;a href="https://www.elastic.co/kibana">Kibana&lt;/a> 可视化数据，我们将看到存储的日志行：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219856876241.jpg" alt="">&lt;/p>
&lt;h3 id="监控">监控&lt;/h3>
&lt;p>Monitoring is another &amp;ldquo;microservicilitie&amp;rdquo; that needs to be implemented in our microservice architecture. Quarkus integrates with &lt;a href="https://micrometer.io/">Micrometer&lt;/a> for application monitoring. Micrometer provides a single entry point to the most popular monitoring systems, allowing you to instrument your JVM-based application code without vendor lock-in.&lt;/p>
&lt;p>For this example, &lt;a href="https://prometheus.io/">Prometheus&lt;/a> format is used as monitoring output but Micrometer (and Quarkus) also supports other formats like Azure Monitor, Stackdriver, SignalFx, StatsD, and DataDog.&lt;/p>
&lt;p>You can register the following Maven dependency to provide Prometheus output:
监控是另一个需要在我们的微服务架构中实现的 “微服务特性”。Quarkus 与 &lt;a href="https://micrometer.io/">Micrometer&lt;/a> 集成在一起以进行应用程序监控。Micrometer 提供了最流行的监控系统的单个入口点，使你无需供应商锁定即可检测基于 JVM 的应用程序代码。&lt;/p>
&lt;p>对于此示例，监控输出采用 &lt;a href="https://prometheus.io/">Prometheus&lt;/a> 格式，但 Micrometer（和 Quarkus）还支持其他格式，例如 Azure Monitor、Stackdriver、SignalFx、StatsD 和 DataDog。&lt;/p>
&lt;p>你可以注册以下 Maven 依赖项以提供 Prometheus 输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.quarkus&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>quarkus-micrometer-registry-prometheus&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，Micrometer 扩展注册了一些与系统，JVM 或 HTTP 相关的度量。收集的指标的一个子集在 &lt;code>/q/metrics&lt;/code> 端点处可用，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl localhost:8080/q/metrics
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;runnable&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 22.0
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;blocked&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 0.0
jvm_threads_states_threads&lt;span class="o">{&lt;/span>&lt;span class="nv">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;waiting&amp;#34;&lt;/span>,&lt;span class="o">}&lt;/span> 10.0
http_server_bytes_read_count 1.0
http_server_bytes_read_sum 0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，也可以使用 Micrometer API 来实现特定于应用程序的指标。
让我们实现一个自定义指标，该指标用于衡量评价最高的图书。&lt;/p>
&lt;p>使用 &lt;code>io.micrometer.core.instrument.MeterRegistry&lt;/code> 该类可以完成指标（在这种情况下为量规）的注册。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">MeterRegistry&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">LongAccumulator&lt;/span> &lt;span class="n">highestRating&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LongAccumulator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">BookResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MeterRegistry&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">registry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">registry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">gauge&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;book.rating.max&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">BookResource&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">highestRatingBook&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求一下，并验证量规是否正确更新。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1
&lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
curl localhost:8080/q/metrics
&lt;span class="c1"># HELP book_rating_max&lt;/span>
&lt;span class="c1"># TYPE book_rating_max gauge&lt;/span>
book_rating_max 3.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还可以设置一个计时器来记录从&lt;em>评级服务&lt;/em>获取评级信息所花费的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">Supplier&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rate&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">rateSupplier&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ratingService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bookId&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">};&lt;/span>
&lt;span class="kd">final&lt;/span> &lt;span class="n">Rate&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">registry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">timer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;book.rating.test&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">wrap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">rateSupplier&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请求一下，并验证收集评价​​所花费的时间。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"># HELP book_rating_test_seconds
# TYPE book_rating_test_seconds summary
book_rating_test_seconds_count 4.0
book_rating_test_seconds_sum 1.05489108
# HELP book_rating_test_seconds_max
# TYPE book_rating_test_seconds_max gauge
book_rating_test_seconds_max 1.018622001
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Micrometer 使用 &lt;code>MeterFilter&lt;/code> 实例来自定义 &lt;code>MeterRegistry&lt;/code> 实例发出的度量。Micrometer 扩展将检测 &lt;code>MeterFilter&lt;/code> CDI bean，并在初始化 &lt;code>MeterRegistry&lt;/code> 实例时使用它们。&lt;/p>
&lt;p>例如，我们可以定义一个通用标签来设置运行应用程序的环境（产品、测试、预发布等）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Singleton&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MicrometerCustomConfiguration&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Produces&lt;/span>
&lt;span class="nd">@Singleton&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">MeterFilter&lt;/span> &lt;span class="nf">configureAllRegistries&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">MeterFilter&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">commonTags&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Arrays&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">asList&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">Tag&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">of&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;env&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;prod&amp;#34;&lt;/span>&lt;span class="o">)));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发送新请求并验证指标是否已标记。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">http_client_requests_seconds_max{clientName=&amp;#34;localhost&amp;#34;,env=&amp;#34;prod&amp;#34;,method=&amp;#34;GET&amp;#34;,outcome=&amp;#34;SUCCESS&amp;#34;,status=&amp;#34;200&amp;#34;,uri=&amp;#34;/rate/2&amp;#34;,} 0.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意 &lt;code>env&lt;/code> 包含值为 &lt;code>prod&lt;/code> 的标签。&lt;/p>
&lt;h3 id="跟踪">跟踪&lt;/h3>
&lt;p>Quarkus 应用程序利用 &lt;a href="https://opentracing.io/">OpenTracing&lt;/a> 规范为交互式 Web 应用程序提供分布式跟踪。&lt;/p>
&lt;p>让我们配置 OpenTracing 以连接到 Jaeger 服务器，将 book-service 设置为服务名称以标识跟踪：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">quarkus.jaeger.enabled=true
quarkus.jaeger.endpoint=http://localhost:14268/api/traces
quarkus.jaeger.service-name=book-service
quarkus.jaeger.sampler-type=const
quarkus.jaeger.sampler-param=1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在发一个请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -H &lt;span class="s2">&amp;#34;Authorization: Bearer ...&amp;#34;&lt;/span> localhost:8080/book/1 &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;bookId&amp;#34;&lt;/span>:1,&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;Book 1&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;rating&amp;#34;&lt;/span>:3&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问Jaeger UI以验证是否跟踪了该调用：&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219857070960.jpg" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>与开发整体应用程序相比，开发和实现微服务体系结构更具挑战性。我们认为，微服务可以驱动你根据应用程序基础结构正确地开发服务。&lt;/p>
&lt;p>此处介绍的大多数微服务（API 和管道除外）是新的，或者在整体应用中实现方式有所不同。原因是现在应用程序被分解成几部分，所有部分都在网络中互连。&lt;/p>
&lt;p>如果你May 26, 2021打算开发微服务并将其部署到 Kubernetes，那么 Quarkus 是一个很好的解决方案，因为它可以与 Kubernetes 顺利集成。实施大多数微服务很简单，只需要几行代码。&lt;/p>
&lt;p>本文演示的源代码可以在 &lt;a href="https://github.com/lordofthejars/microservicilities-quarkus">github&lt;/a> 上找到。&lt;/p>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/05/26/16219857200384.jpg" alt="">&lt;/p>
&lt;p>Alex Soto 是 Red Hat 开发人员经验总监。他对 Java 世界，软件自动化充满热情，并且他相信开源软件模型。Soto 是 &lt;a href="https://www.manning.com/books/testing-java-microservices">Manning&lt;/a> 的合著者 | &lt;a href="https://www.manning.com/books/testing-java-microservices">测试 Java 微服务&lt;/a>和 &lt;a href="https://www.oreilly.com/library/view/quarkus-cookbook/9781492062646/">O&amp;rsquo;Reilly Quarkus Cookbook&lt;/a> 和几个开源项目的贡献者。自 2017 年以来一直是 Java 冠军，他还是 Salle URL University 的国际演讲者和老师。你可以在 Twitter （Alex Soto）上关注他，以随时了解 Kubernetes 和 Java 世界中正在发生的事情。&lt;/p></description></item></channel></rss>