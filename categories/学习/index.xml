<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on 乱世浮生</title>
    <link>http://localhost:1313/categories/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on 乱世浮生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 01 Jan 2018 12:30:55 +0000</lastBuildDate>
    
	<atom:link href="http://localhost:1313/categories/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go In Action 读书笔记 四</title>
      <link>http://localhost:1313/go-in-action-four/</link>
      <pubDate>Mon, 01 Jan 2018 12:30:55 +0000</pubDate>
      
      <guid>http://localhost:1313/go-in-action-four/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://talks.golang.org/2013/go4python/img/fib-go.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;并发模式&#34;&gt;并发模式&lt;/h2&gt;

&lt;h3 id=&#34;runner&#34;&gt;runner&lt;/h3&gt;

&lt;p&gt;runner展示了如何使用通道来监视程序的执行时间, 如果程序执行时间太长, 也可以用终止程序.
这个程序可用作corn作业执行&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go In Action 读书笔记 三</title>
      <link>http://localhost:1313/go-in-action-three/</link>
      <pubDate>Mon, 01 Jan 2018 12:30:31 +0000</pubDate>
      
      <guid>http://localhost:1313/go-in-action-three/</guid>
      <description>&lt;h2 id=&#34;并发&#34;&gt;并发&lt;/h2&gt;

&lt;p&gt;Go语言里的并发是指让某个函数可以独立于其他函数运行的能力. 当一个函数创建为goroutine时, Go会将其视为一个独立的工作单元. 这个工作单元会被调度到可用的&lt;strong&gt;逻辑处理器&lt;/strong&gt;上执行.&lt;/p&gt;

&lt;p&gt;Go的运行时调度器可以管理所有创建的goroutine, 并为其分配执行时间.
这个调度器在操作系统之上, 将操作系统的线程与逻辑处理器绑定, 并在逻辑处理器执行goroutine. &lt;strong&gt;调度器可以在任何给定的时间, 全面控制哪个goroutine在哪个逻辑处理器上运行&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Go的并发同步模型来自一个叫做通信顺序进程(Communicating Sequential Processes, &lt;a href=&#34;http://www.usingcsp.com&#34;&gt;CSP&lt;/a&gt;). CSP是一个消息传递模型, 通过在goroutine之前传递数据来传递消息, 不需要通过加锁实现同步访问. 用于在goroutine间传递消息的数据结构叫做通道(channel).&lt;/p&gt;

&lt;h3 id=&#34;并发与并行&#34;&gt;并发与并行&lt;/h3&gt;

&lt;p&gt;操作系统的线程(thread)和进程(process).&lt;/p&gt;

&lt;p&gt;进程类似应用程序在运行中需要用到和维护的各种资源的容器.
资源包括但不限于: 内存(来自文件系统的代码和数据), 句柄(文件, 设备, 操作系统), 线程.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go In Action 读书笔记 二</title>
      <link>http://localhost:1313/go-in-action-two/</link>
      <pubDate>Mon, 01 Jan 2018 12:28:04 +0000</pubDate>
      
      <guid>http://localhost:1313/go-in-action-two/</guid>
      <description>&lt;h2 id=&#34;go语言的类型系统&#34;&gt;Go语言的类型系统&lt;/h2&gt;

&lt;p&gt;Go语言是静态类型的变成语言. 编译的时候需要确定类型.&lt;/p&gt;

&lt;h3 id=&#34;用户定义的类型&#34;&gt;用户定义的类型&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;email&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ext&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;privileged&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;
零值和&lt;strong&gt;结构字面量&lt;/strong&gt;初始化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//引用类型, 各个字段初始化为对应的零值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bill&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//创建并初始化, 使用结构字面量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lisa&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//{Lisa lisa@email.com 123 true}
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Lisa&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;email&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;lisa@email.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;123&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;privileged&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结构字面量的赋值方式:&lt;/strong&gt;
- 不同行声明每一个字段和对应的值, 字段名和字段以&lt;code&gt;:&lt;/code&gt;分隔, 末尾以&lt;code&gt;,&lt;/code&gt;结尾
- 不适用字段名, 只声明对应的值. 写在一行里, 以&lt;code&gt;,&lt;/code&gt;分隔, 结尾不需要&lt;code&gt;,&lt;/code&gt;. &lt;strong&gt;要保证顺序&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;lisa&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Lisa&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;lisa@email.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;123&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Go In Action 读书笔记 一</title>
      <link>http://localhost:1313/go-in-action-one/</link>
      <pubDate>Mon, 01 Jan 2018 12:27:10 +0000</pubDate>
      
      <guid>http://localhost:1313/go-in-action-one/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://7xvxng.com1.z0.glb.clouddn.com/15142714785285.jpg&#34; alt=&#34;架构流程图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;关键字&#34;&gt;关键字&lt;/h2&gt;

&lt;h3 id=&#34;var&#34;&gt;var&lt;/h3&gt;

&lt;p&gt;变量使用&lt;code&gt;var&lt;/code&gt;声明, 如果变量不是定义在任何一个函数作用域内, 这个变量就是包级变量.
&amp;gt; Go语言中, 所有变量都被初始化为其&lt;strong&gt;零值&lt;/strong&gt;. 对于数值类型, 其零值是&lt;strong&gt;0&lt;/strong&gt;;  对于字符串类型, 其零值是&lt;strong&gt;空字符串&amp;rdquo;&amp;rdquo;&lt;/strong&gt;; 对于布尔类型, 其零值是&lt;strong&gt;false&lt;/strong&gt;. 对于引用类型来说, 底层数据结构会被初始化对应的零值. 但是被生命被起零值的引用类型的变量, 会返回&lt;strong&gt;nil&lt;/strong&gt;作为其值.&lt;/p&gt;

&lt;h3 id=&#34;const&#34;&gt;const&lt;/h3&gt;

&lt;p&gt;定义常量&lt;/p&gt;

&lt;h3 id=&#34;interface&#34;&gt;interface&lt;/h3&gt;

&lt;p&gt;声明接口&lt;/p&gt;

&lt;h3 id=&#34;func&#34;&gt;func&lt;/h3&gt;

&lt;p&gt;声明函数&lt;/p&gt;

&lt;h3 id=&#34;defer&#34;&gt;defer&lt;/h3&gt;

&lt;p&gt;安排后面的函数调用在当前函数返回时才执行.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;filePath&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;more&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;operation&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>SpringBoot源码 - 启动</title>
      <link>http://localhost:1313/glance-over-spring-boot-source/</link>
      <pubDate>Fri, 08 Dec 2017 17:48:43 +0000</pubDate>
      
      <guid>http://localhost:1313/glance-over-spring-boot-source/</guid>
      <description>SpringBoot Application启动部分的源码阅读. SpringApplication 常用的SpringApplication.run(Class, Args)启动Spring应用,</description>
    </item>
    
    <item>
      <title>Raft算法学习</title>
      <link>http://localhost:1313/learning-raft/</link>
      <pubDate>Sat, 14 Oct 2017 05:57:34 +0000</pubDate>
      
      <guid>http://localhost:1313/learning-raft/</guid>
      <description>Raft 强一致性算法 名词 复制状态机 复制状态机是通过复制日志来实现的, 按照日志中的命令的顺序来执行这些命令. 相同的状态机执行相同的日志命令, 获得相同</description>
    </item>
    
    <item>
      <title>Kafka发送不同确认方式的性能差异</title>
      <link>http://localhost:1313/kafka-producer-acknowledge-benchmark/</link>
      <pubDate>Tue, 10 Oct 2017 11:49:58 +0000</pubDate>
      
      <guid>http://localhost:1313/kafka-producer-acknowledge-benchmark/</guid>
      <description>背景 Kafka的性能众所周知，Producer支持acknowledge模式。即Kafka会想Producer返回消息发送的结果。但是在Ja</description>
    </item>
    
    <item>
      <title>Kafka消息消费一致性</title>
      <link>http://localhost:1313/kafka-consumer-consistency/</link>
      <pubDate>Tue, 26 Sep 2017 19:13:48 +0000</pubDate>
      
      <guid>http://localhost:1313/kafka-consumer-consistency/</guid>
      <description>Kafka消费端的offset主要由consumer来控制, Kafka降每个consumer所监听的tocpic的partition的off</description>
    </item>
    
    <item>
      <title>Kafka 恰好一次发送和事务消费示例</title>
      <link>http://localhost:1313/kafka-exactly-once-delivery-and-transactional-messaging-example/</link>
      <pubDate>Fri, 22 Sep 2017 18:03:43 +0000</pubDate>
      
      <guid>http://localhost:1313/kafka-exactly-once-delivery-and-transactional-messaging-example/</guid>
      <description>核心思想 生产端一致性: 开启幂等和事务, 包含重试, 发送确认, 同一个连接的最大未确认请求数. 消费端一致性: 通过设置读已提交的数据和同时处理完成每</description>
    </item>
    
    <item>
      <title>恰好一次发送和事务消息(译)</title>
      <link>http://localhost:1313/kafka-exactly-once-delivery-and-transactional-messaging/</link>
      <pubDate>Tue, 19 Sep 2017 19:13:26 +0000</pubDate>
      
      <guid>http://localhost:1313/kafka-exactly-once-delivery-and-transactional-messaging/</guid>
      <description>Kafka提供“至少一次”交付语义, 这意味着发送的消息可以传送一次或多次. 人们真正想要的是“一次”语义,因为重复的消息没有被传递。 普遍地发声</description>
    </item>
    
    <item>
      <title>Kafka Producer配置解读</title>
      <link>http://localhost:1313/kafka-producer-config/</link>
      <pubDate>Tue, 19 Sep 2017 15:38:03 +0000</pubDate>
      
      <guid>http://localhost:1313/kafka-producer-config/</guid>
      <description>按照重要性分类, 基于版本0.11.0.0 高 bootstrap.servers 一组host和port用于初始化连接. 不管这里配置了多少台server, 都只是用作发现整个集群全</description>
    </item>
    
    <item>
      <title>JSON Patch</title>
      <link>http://localhost:1313/json-patch/</link>
      <pubDate>Sun, 27 Aug 2017 14:41:44 +0000</pubDate>
      
      <guid>http://localhost:1313/json-patch/</guid>
      <description>JSON Path是在使用Kubernetes API的过程中首次使用的. 使用API做扩缩容的时候, 发送整个Deployment的全文不是个明智的做法</description>
    </item>
    
    <item>
      <title>如何在Openshift中使用hostPath</title>
      <link>http://localhost:1313/how-to-use-hostpath-in-openshift/</link>
      <pubDate>Wed, 23 Aug 2017 19:29:51 +0000</pubDate>
      
      <guid>http://localhost:1313/how-to-use-hostpath-in-openshift/</guid>
      <description>使用openshift搭建的k8s的api创建Deployment，在启动的时候报下面的错误： Invalid value: &amp;ldquo;hostPath&amp;rdquo;: hostPath volumes are not allowed to be used] 解决方案： 一个方案是将u</description>
    </item>
    
    <item>
      <title>Kubernetes — 持久卷</title>
      <link>http://localhost:1313/kubernetes-persistent-volumes/</link>
      <pubDate>Sun, 20 Aug 2017 22:25:40 +0000</pubDate>
      
      <guid>http://localhost:1313/kubernetes-persistent-volumes/</guid>
      <description>Persistent Volume 译自Persistent Volumes 介绍 管理存储是管理计算的独特问题。 PersistentVolume子系统为用户和管理员提供了一个API，其中提</description>
    </item>
    
    <item>
      <title>暴力停止ExecutorService的线程</title>
      <link>http://localhost:1313/stop-a-thread-of-executor-service/</link>
      <pubDate>Wed, 19 Jul 2017 22:25:19 +0000</pubDate>
      
      <guid>http://localhost:1313/stop-a-thread-of-executor-service/</guid>
      <description>停止，stop，这里说的是真的停止。如何优雅的结束，这里就不提了。 这里要用Thread.stop()。众所周知，stop()方法在JDK中是</description>
    </item>
    
    <item>
      <title>私有构造函数捕获模式</title>
      <link>http://localhost:1313/private-constructor-capture-idiom/</link>
      <pubDate>Wed, 24 May 2017 06:50:44 +0000</pubDate>
      
      <guid>http://localhost:1313/private-constructor-capture-idiom/</guid>
      <description>《Java并发编程实践》的注解中有提到这一概念。 The private constructor exists to avoid the race condition that would occur if the copy constructor were implemented as this (p.x, p.y); this is an example of the private constructor capture idiom (Bloch and Gafter, 2005). 结合原文代码： 1 2 3</description>
    </item>
    
    <item>
      <title>Docker快速构建Cassandra和Java操作</title>
      <link>http://localhost:1313/java-operate-cassandra-deployed-in-docker/</link>
      <pubDate>Thu, 18 May 2017 23:33:24 +0000</pubDate>
      
      <guid>http://localhost:1313/java-operate-cassandra-deployed-in-docker/</guid>
      <description>搭建Cassandra 使用docker创建Cassandra，方便快捷 1 2 3 docker pull cassandra:latest docker run -d --name cassandra -p 9042:9042 cassandra docker exec -it cassandra bash 创建keyspace、table</description>
    </item>
    
    <item>
      <title>从零开始用docker运行spring boot应用</title>
      <link>http://localhost:1313/run-spring-boot-app-in-docker/</link>
      <pubDate>Thu, 20 Apr 2017 21:58:42 +0000</pubDate>
      
      <guid>http://localhost:1313/run-spring-boot-app-in-docker/</guid>
      <description>假设已经安装好Docker Springboot应用 pom添加依赖和构建插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.5.3.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt;</description>
    </item>
    
    <item>
      <title>Jasig CAS Web and Proxy flow</title>
      <link>http://localhost:1313/jasig-cas-web-and-proxy-flow/</link>
      <pubDate>Tue, 18 Apr 2017 10:36:16 +0000</pubDate>
      
      <guid>http://localhost:1313/jasig-cas-web-and-proxy-flow/</guid>
      <description>最近因为需求在看CAS相关的只是，由于需要后端调用，用到proxy（代理）模式。整理了下web flow和proxy web flow的流程。 Web Flow Proxy Web</description>
    </item>
    
    <item>
      <title>一个Tomcat类加载问题</title>
      <link>http://localhost:1313/one-tomcat-class-load-issue/</link>
      <pubDate>Wed, 12 Apr 2017 10:40:01 +0000</pubDate>
      
      <guid>http://localhost:1313/one-tomcat-class-load-issue/</guid>
      <description>背景 一个Tomcat实例中运行了三个应用，其中一个对接了Apereo的CAS系统。现在要求另外两个系统也对接CAS系统，问题就出现了： 应用启</description>
    </item>
    
    <item>
      <title>GreenPlum JDBC和C3P0数据源</title>
      <link>http://localhost:1313/greenplum-jdbc-and-c3p0-datasource/</link>
      <pubDate>Mon, 10 Apr 2017 08:29:00 +0000</pubDate>
      
      <guid>http://localhost:1313/greenplum-jdbc-and-c3p0-datasource/</guid>
      <description>在网上搜索GreenPlum（GPDB）的数据源配置的时候，发现搜索结果都是用postgresql的配置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description>
    </item>
    
    <item>
      <title>Scala笔记：def VS val</title>
      <link>http://localhost:1313/def-vs-val-in-scala/</link>
      <pubDate>Sun, 09 Apr 2017 08:24:40 +0000</pubDate>
      
      <guid>http://localhost:1313/def-vs-val-in-scala/</guid>
      <description>先说原理： val修饰的在定义的时候执行 def修饰的在调用的时候执行 直观的例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //注释</description>
    </item>
    
    <item>
      <title>Centos编译安装Redis</title>
      <link>http://localhost:1313/install-redis-on-centos/</link>
      <pubDate>Fri, 07 Apr 2017 16:48:46 +0000</pubDate>
      
      <guid>http://localhost:1313/install-redis-on-centos/</guid>
      <description>版本 Centos7 Redis3.2.8 编译安装 1 2 3 4 5 wget http://download.redis.io/releases/redis-3.2.8.tar.gz tar -zxvf redis-3.2.8.tar.gz cd redis-3.2.8 sudo make test sudo make install 启动 1 redis-server 问题 /bin/sh: cc: command not found 原因：Centos安装时选择的类型是Infrastructure，</description>
    </item>
    
    <item>
      <title>Centos上安装Postgresql</title>
      <link>http://localhost:1313/install-postgresql-on-centos/</link>
      <pubDate>Thu, 06 Apr 2017 22:54:17 +0000</pubDate>
      
      <guid>http://localhost:1313/install-postgresql-on-centos/</guid>
      <description>版本 Centos7 Postgresql9.2 Enable ssh service sshd start Open firewall for 22 firewall-cmd —state firewall-cmd —list-all firewall-cmd —permanent —zone=public —add-port=22/tcp firewall-cmd</description>
    </item>
    
    <item>
      <title>Key长度对Redis性能影响</title>
      <link>http://localhost:1313/redis-performance-key-length/</link>
      <pubDate>Thu, 16 Mar 2017 10:37:03 +0000</pubDate>
      
      <guid>http://localhost:1313/redis-performance-key-length/</guid>
      <description>最近Redis的使用中用的到key可能比较长，但是Redis的官方文档没提到key长度对性能的影响，故简单做了个测试。 环境 Redis和测试程</description>
    </item>
    
    <item>
      <title>遍历Collection时删除元素</title>
      <link>http://localhost:1313/remove-element-while-looping-collection/</link>
      <pubDate>Sun, 05 Mar 2017 22:04:58 +0000</pubDate>
      
      <guid>http://localhost:1313/remove-element-while-looping-collection/</guid>
      <description>其实标题我想用《为什么foreach边循环边移除元素要用Iterator？》可是太长。 不用Iterator，用Collection.remo</description>
    </item>
    
    <item>
      <title>Java Volatile关键字</title>
      <link>http://localhost:1313/deep-in-java-volatile-keywork/</link>
      <pubDate>Thu, 02 Mar 2017 08:30:29 +0000</pubDate>
      
      <guid>http://localhost:1313/deep-in-java-volatile-keywork/</guid>
      <description>volatile通过保证对变量的读或写都是直接从内存中读取或直接写入内存中，保证了可见性；但是volatile并不足以保证线程安全，因为无法</description>
    </item>
    
    <item>
      <title>Haproxy虚拟主机SSL</title>
      <link>http://localhost:1313/haproxy-multi-host-with-ssl/</link>
      <pubDate>Mon, 27 Feb 2017 19:31:53 +0000</pubDate>
      
      <guid>http://localhost:1313/haproxy-multi-host-with-ssl/</guid>
      <description>Haproxy为多个域名配置SSL 生成自签名证书 1 2 3 4 5 6 sudo mkdir /etc/ssl/atbug.com sudo openssl genrsa -out /etc/ssl/atbug.com/atbug.com.key 1024 sudo openssl req -new -key /etc/ssl/atbug.com/atbug.com.key -out /etc/ssl/atbug.com/atbug.com.csr sudo openssl x509 -req -days 365 -in /etc/ssl/atbug.com/atbug.com.csr -singkey /etc/ssl/atbug.com/atbug.com.key -out /etc/ssl/atbug.com/atbug.com.crt sudo openssl x509 -req -days 365 -in /etc/ssl/atbug.com/atbug.com.csr -signkey /etc/ssl/atbug.com/atbug.com.key -out</description>
    </item>
    
    <item>
      <title>mybatis报错“Result Maps collection already contains value for ***”</title>
      <link>http://localhost:1313/duplicate-resultmap-in-mybatis-mapper/</link>
      <pubDate>Wed, 22 Feb 2017 14:12:18 +0000</pubDate>
      
      <guid>http://localhost:1313/duplicate-resultmap-in-mybatis-mapper/</guid>
      <description>这是工作中遇到的一个问题：测试环境部署出错，报了下面的问题。 1 2 3 4 5 6 7 8 9 10 Caused by: java.lang.IllegalArgumentException: Result Maps collection already contains value for xxx.xxx.xxxRepository.BaseResultMap at org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:802) at org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:774) at org.apache.ibatis.session.Configuration.addResultMap(Configuration.java:556) at org.apache.ibatis.builder.MapperBuilderAssistant.addResultMap(MapperBuilderAssistant.java:217) at org.apache.ibatis.builder.ResultMapResolver.resolve(ResultMapResolver.java:47) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:285) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:252) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElements(XMLMapperBuilder.java:244) at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:116) 检</description>
    </item>
    
    <item>
      <title>消费时offset被重置导致重复消费</title>
      <link>http://localhost:1313/offset-be-reset-when-consuming/</link>
      <pubDate>Mon, 20 Feb 2017 13:23:49 +0000</pubDate>
      
      <guid>http://localhost:1313/offset-be-reset-when-consuming/</guid>
      <description>这是实际使用时遇到的问题：kafka api的版本是0.10，发现有重复消费问题；检查log后发现在commit offset的时候发生超时。 1</description>
    </item>
    
    <item>
      <title>TheadPoolExecutor源码分析</title>
      <link>http://localhost:1313/threadpoolexecutor-sourcecode-analysis/</link>
      <pubDate>Mon, 20 Feb 2017 09:56:07 +0000</pubDate>
      
      <guid>http://localhost:1313/threadpoolexecutor-sourcecode-analysis/</guid>
      <description>TheadPoolExecutor源码分析 ThreadPoolExecutor是多线程中经常用到的类，其使用一个线程池执行提交的任务。 实现 没</description>
    </item>
    
    <item>
      <title>Kafka Java生产者模型</title>
      <link>http://localhost:1313/kafka-java-producer-model/</link>
      <pubDate>Wed, 04 Jan 2017 16:33:02 +0000</pubDate>
      
      <guid>http://localhost:1313/kafka-java-producer-model/</guid>
      <description>Producer初始化 初始化KafkaProducer实例，同时通过Config数据初始化MetaData、NetWorkClient、Ac</description>
    </item>
    
    <item>
      <title>Flume - FileChannel （一）</title>
      <link>http://localhost:1313/flume-filechannel-overview/</link>
      <pubDate>Wed, 23 Nov 2016 09:23:57 +0000</pubDate>
      
      <guid>http://localhost:1313/flume-filechannel-overview/</guid>
      <description>概述 当使用Flume的时候，每个流程都包含了输入源、通道和输出。一个典型的例子是一个web服务器将事件通过RPC（搬入AvroSource）</description>
    </item>
    
    <item>
      <title>探索Rabbitmq的Java客户端</title>
      <link>http://localhost:1313/deep-in-rabbitmq-java-client/</link>
      <pubDate>Sun, 09 Oct 2016 09:20:07 +0000</pubDate>
      
      <guid>http://localhost:1313/deep-in-rabbitmq-java-client/</guid>
      <description>AMQPConnection 实例初始化 创建Connection时会通过FrameHandlerFacotry创建一个SocketFrameHandler，Socket</description>
    </item>
    
    <item>
      <title>Git回车换行</title>
      <link>http://localhost:1313/crlf-in-git/</link>
      <pubDate>Wed, 14 Sep 2016 09:16:10 +0000</pubDate>
      
      <guid>http://localhost:1313/crlf-in-git/</guid>
      <description>最近又个项目，checkout之后，没做任何改动前git status发现已经有modified了，通过git diff发现有两种改动： - warning: CRLF will</description>
    </item>
    
    <item>
      <title>深入剖析HashSet和HashMap实现</title>
      <link>http://localhost:1313/deep-in-implementation-of-hashset/</link>
      <pubDate>Mon, 11 Jul 2016 14:57:16 +0000</pubDate>
      
      <guid>http://localhost:1313/deep-in-implementation-of-hashset/</guid>
      <description>HashSet是一个包含非重复元素的集合，如何实现的，要从底层实现代码看起。 背景 首先非重复元素如何定义，看Set的描述： More formally, sets contain no pair of elements e1 and</description>
    </item>
    
    <item>
      <title>多线程下的单例模式&#43;反汇编</title>
      <link>http://localhost:1313/singleton-in-multi-threads-programming/</link>
      <pubDate>Wed, 06 Jul 2016 16:57:09 +0000</pubDate>
      
      <guid>http://localhost:1313/singleton-in-multi-threads-programming/</guid>
      <description>多线程下的单例模式的实现，顺便做了反汇编。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class MySingleton { private static MySingleton INSTANCE; private MySingleton() { } public static MySingleton getInstance() { if (INSTANCE == null) { synchronized (MySingleton.class) { INSTANCE = new MySingleton(); } } return INSTANCE; }</description>
    </item>
    
    <item>
      <title>使用Kryo替换spring amqp的Java序列化</title>
      <link>http://localhost:1313/use-kryo-in-spring-amqp-serialization/</link>
      <pubDate>Wed, 29 Jun 2016 05:29:14 +0000</pubDate>
      
      <guid>http://localhost:1313/use-kryo-in-spring-amqp-serialization/</guid>
      <description>spring amqp的原生并没有对Kryo加以支持，Kryo的优点就不多说了。 git地址：https://github.com/addozhang/s</description>
    </item>
    
    <item>
      <title>Rabbitmq延迟队列实现</title>
      <link>http://localhost:1313/rabbitmq-delay-queue-implementation/</link>
      <pubDate>Wed, 30 Mar 2016 14:27:02 +0000</pubDate>
      
      <guid>http://localhost:1313/rabbitmq-delay-queue-implementation/</guid>
      <description>工作中很多场景需要用到定时任务、延迟任务，常用的方法用crontab job、Spring的Quartz，然后扫描整张数据库表，判断哪些数据需</description>
    </item>
    
    <item>
      <title>关于SLF4J</title>
      <link>http://localhost:1313/about-slf4j/</link>
      <pubDate>Sat, 18 Apr 2015 11:16:26 +0000</pubDate>
      
      <guid>http://localhost:1313/about-slf4j/</guid>
      <description>Spring的功能越来越强大，同时也越来越臃肿。比如想快速搭建一个基于Spring的项目，解决依赖问题非常耗时。Spring的项目模板的出现</description>
    </item>
    
  </channel>
</rss>