<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>容器 on 乱世浮生</title><link>https://atbug.com/categories/%E5%AE%B9%E5%99%A8/</link><description>Recent content in 容器 on 乱世浮生</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 07 Dec 2021 07:55:16 +0800</lastBuildDate><atom:link href="https://atbug.com/categories/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>沙盒化容器：是容器还是虚拟机</title><link>https://atbug.com/sandboxed-container/</link><pubDate>Tue, 07 Dec 2021 07:55:16 +0800</pubDate><guid>https://atbug.com/sandboxed-container/</guid><description>
&lt;p>随着 IT 技术的发展，AI、区块链和大数据等技术提升了对应用毫秒级扩展的需求，开发人员也面临着的功能快速推出的压力。混合云是新常态，数字化转型是保持竞争力的必要条件，虚拟化成为这些挑战的基本技术。&lt;/p>
&lt;p>在虚拟化的世界，有两个词耳熟能详：虚拟机和容器。前者是对硬件的虚拟化，后者则更像是操作系统的虚拟化。两者都提供了沙箱的能力：虚拟机通过硬件级抽象提供，而容器则使用公共内核提供进程级的隔离。有很多人将容器看成是“轻量化的虚拟机”，通常情况下我们认为容器是安全的，那到底是不是跟我们想象的一样？&lt;/p>
&lt;h2 id="容器轻量化的虚拟机">容器：轻量化的虚拟机？&lt;/h2>
&lt;p>容器是打包、共享和部署应用的现代化方式，帮助企业实现快速、标准、灵活地完成服务交互。容器化是建立在 Linux 的命名空间（namespace）和控制组（cgroup） 的设计之上。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/20211206-at-210354.png" alt="">&lt;/p>
&lt;p>命名空间创建一个几乎隔离的用户空间，并为应用提供专用的系统资源，如文件系统、网络堆栈、进程ID和用户ID。随着用户命名空间的引入，内核版本 3.8 提供了对容器功能的支持：Mount（mnt）、进程 ID（pid）、Network（net）、进程间通信（ipc）、UTS、用户 ID（user）6 个命名空间（如今已达 8 个，后续加入了 cgroup 和 time 命名空间）。&lt;/p>
&lt;p>cgroup 则实施对应用的资源限制、优先级、记账和控制。cgroup可以控制 CPU、内存、设备和网络等资源。&lt;/p>
&lt;p>同时使用 namespace 和 cgroup 使得我们可以在一台主机上安全地运行多个应用，并且每个应用都位于隔离的环境中。&lt;/p>
&lt;h2 id="虚拟机提供更强大的隔离">虚拟机提供更强大的隔离&lt;/h2>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/16387934257868.png" alt="">&lt;/p>
&lt;p>虽然容器很棒，足够轻量级。但通过上面的描述，同一个主机上的多个容器其实是&lt;strong>共享同一个操作系统内核&lt;/strong>，只是做到了操作系统级的虚拟化。虽然命名空间提供了高度的隔离，但仍然有容器可以访问的资源，这些资源并没有提供命名空间。这些资源是主机上所有容器共有的，比如内核 Keyring、/proc、系统时间、内核模块、硬件。&lt;/p>
&lt;p>我们都知道没有 100% 安全的软件，容器化的应用也一样，从应用源码到依赖库到容器 base 镜像，甚至容器引擎本身都可能存在安全漏洞。发生容器逃逸的风险远高于虚拟机，黑客可以利用这些逃逸漏洞，操作容器的外部资源也就是宿主机上的资源。除了漏洞，有时使用的不当也会带来安全风险，比如为容器分配了过高的权限（CAP_SYS_ADMIN 功能、特权权限），都可能导致容器逃逸。&lt;/p>
&lt;p>而虚拟机依靠硬件级的虚拟化，实现的硬件隔离比命名空间隔离提供了更强大的安全边界。与容器相比，虚拟机提供了更高程度的隔离，只因其有&lt;strong>自己的内核&lt;/strong>。&lt;/p>
&lt;p>由此可见，容器并不是真正的“沙盒”，也并&lt;strong>不是轻量化的虚拟机&lt;/strong>。有没有可能为容器增加一个更安全的边界，尽可能的与主机操作系统隔离，做到类似虚拟机的强隔离，使其成为真正的“沙盒”？&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/20211206-at-213818.png" alt="">&lt;/p>
&lt;h2 id="沙盒化容器">沙盒化容器&lt;/h2>
&lt;p>答案是有，就是沙盒容器。这种容器就像虚拟机一样有自己的内核，这层内核成为&lt;strong>用户空间内核&lt;/strong>。这层内核要保持容器的轻量级，使用现代编程技术编写，本身非常轻，仅用于作为容器和主机之间的强隔离层。&lt;/p>
&lt;p>并且还要支持 OCI 和 CRI 规范，可以与 Docker 和 Kubernetes 等容器工具很好的集成。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/16388025771596.jpg" alt="">&lt;/p>
&lt;p>这里简单介绍下 gVisor 和 Kata Containers。&lt;/p>
&lt;h3 id="gvisor">gVisor&lt;/h3>
&lt;p>&lt;a href="https://github.com/google/gvisor">gVisor&lt;/a> 是使用 Go 编写的应用内核，实现了 Linux 操作系统的大部分接口。其包含了一个叫做 &lt;code>runsc&lt;/code> 的 OCI 运行时，提供了应用和宿主机内核间的隔离层。&lt;code>runsc&lt;/code> 也实现了与 Docker 和 Kubernetes 的集成，可以很容易的运行沙盒容器。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/16388038711948.png" alt="">&lt;/p>
&lt;p>gVisor 为每个容器提供了独立的操作系统内核。应用与 gVisor 内核提供的虚拟环境进行交互，不是直接访问宿主机的内核。gVisor 还限制和管理文件和网络操作，确保容器化应用和主机操作系统之间有两个隔离层。通过减少和限制应用与主机内核的交互，尽可能减小攻击者绕过容器隔离机制的攻击面。&lt;/p>
&lt;p>与大部分内核不同，gVisor 不需要固定的物理资源；相反，其利用现有的主机内核功能，并作为一个正常进程运行。换句话说，gVisor 以 Linux 的方式实现了 Linux。&lt;/p>
&lt;p>gVisor 沙盒由多个进程组成，这些进程共同构成了可以运行一个或多个容器的环境。&lt;/p>
&lt;p>每个沙盒都有其独立的实例：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Sentry&lt;/strong>：运行容器的内核，拦截并响应应用的系统调用。&lt;/li>
&lt;/ul>
&lt;p>沙盒中的每个容器都有其独立的实例：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Gofer&lt;/strong>：提供容器文件系统的访问。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/16388054009464.png" alt="">&lt;/p>
&lt;h3 id="kata-containers">Kata Containers&lt;/h3>
&lt;p>&lt;a href="https://katacontainers.io">Kata Containers&lt;/a> 与容器一样轻量级且快，并与容器管理层集成&amp;ndash; 包括 Docker 和 Kubernetes 等流行的容器编排工具 &amp;ndash; 同时还提供了与虚拟机一样的安全。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/16388045850437.png" alt="">&lt;/p>
&lt;p>Kata Containers 与 OCI、容器运行时接口（CRI）和容器网络接口（CNI）完全集成。它支持各种类型的网络模型（例如，passthrough、MacVTap、桥接、tc 镜像）和可配置的访客内核，以便需要特殊网络模型或内核版本的应用都可以在上面运行。上图显示了 Kata VM 中的容器如何与现有编排平台交互。&lt;/p>
&lt;p>Kata 在主机上有一个 kata 运行时来启动和配置新容器。对于 Kata VM 中的每个容器，主机上都有一个相应的 Kata Shim。Kata Shim 接收来自客户端（例如 docker 或 kubectl）的 API 请求，并通过 VSock 将请求转发给 Kata VM 内的代理。Kata 容器进一步进行了几项优化，以减少 VM 启动时间。&lt;/p>
&lt;p>Kata Containers 由两个开源项目合并而来：Intel 的 Clear containers 和 Hyper runV。前者注重性能（引导时间小于 100ms）和安全；而后者通过支持不同的 CPU 架构和管理系统，将技术无关放在首位。Kata Containers 可以说集二者之大成。&lt;/p>
&lt;p>&lt;img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/12/06/16388045324654.jpg" alt="">&lt;/p>
&lt;p>与传统的容器相比，Kata Container 做到了虚拟机的隔离，集虚拟机的安全性和容器的性能于一身。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>与普通容器相比，沙盒容器提供了更强的隔离性，这种强隔离提供了更高的安全性。同时这类容器技术支持 OCI 和 CRI 规范，可以与现有的容器工具以及 Kubernetes 很好的集成。&lt;/p></description></item><item><title>Kubernetes学习 — Macos安装Kubernetes</title><link>https://atbug.com/install-kubernetes-on-macos/</link><pubDate>Thu, 17 Aug 2017 09:44:17 +0000</pubDate><guid>https://atbug.com/install-kubernetes-on-macos/</guid><description>
&lt;h1 id="kubernetes">Kubernetes&lt;/h1>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h2 id="macos">macos&lt;/h2>
&lt;h3 id="检查环境">检查环境&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">sysctl -a &lt;span class="p">|&lt;/span> grep machdep.cpu.features &lt;span class="p">|&lt;/span> grep VMX
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装virtualbox">安装VirtualBox&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">http://download.virtualbox.org/virtualbox/5.1.26/Oracle_VM_VirtualBox_Extension_Pack-5.1.26-117224.vbox-extpack
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装minikube">安装minikube&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.21.0/minikube-darwin-amd64 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod +x minikube &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo mv minikube /usr/local/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建集群">创建集群&lt;/h3>
&lt;p>默认使用virtualbox。&lt;/p>
&lt;p>主机的ip是&lt;code>192.168.31.186&lt;/code>， &lt;code>1087&lt;/code>是proxy的端口。需要将ss的http代理监听地址从&lt;code>127.0.0.1&lt;/code>改为主机的ip。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">#启动&lt;/span>
minikube start
&lt;span class="c1">#使用私有库&lt;/span>
minikube start --insecure-registry&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.34&amp;#34;&lt;/span>
&lt;span class="c1">#使用proxy，用于获取镜像&lt;/span>
minikube start --docker-env &lt;span class="nv">HTTP_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.186:1087&amp;#34;&lt;/span> --docker-env &lt;span class="nv">HTTPS_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.31.186:1087&amp;#34;&lt;/span> --docker-env &lt;span class="nv">NO_PROXY&lt;/span>&lt;span class="o">=&lt;/span>192.168.99.0/24
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装kubectl">安装kubectl&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl -Lo kubectl http://storage.googleapis.com/kubernetes-release/release/v1.7.3/bin/darwin/amd64/kubectl &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod +x kubectl &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo mv kubectl /usr/local/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="oh-my-zsh-tab-completion">oh-my-zsh tab completion&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">vi ~/.zshrc
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>添加到plugin部分&lt;br>
plugins=(git zsh-completions kubectl)&lt;/p>
&lt;/blockquote>
&lt;h2 id="使用">使用&lt;/h2>
&lt;h3 id="minikube">minikube&lt;/h3>
&lt;h4 id="检查版本">检查版本&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube version
&lt;span class="c1">#minikube version: v0.21.0&lt;/span>
kubectl version
&lt;span class="c1">#Client Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;3&amp;#34;, GitVersion:&amp;#34;v1.3.0&amp;#34;, GitCommit:&amp;#34;283137936a498aed572ee22af6774b6fb6e9fd94&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2016-07-01T19:26:38Z&amp;#34;, GoVersion:&amp;#34;go1.6.2&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;darwin/amd64&amp;#34;}&lt;/span>
&lt;span class="c1">#Server Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;7&amp;#34;, GitVersion:&amp;#34;v1.7.0&amp;#34;, GitCommit:&amp;#34;d3ada0119e776222f11ec7945e6d860061339aad&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2017-07-26T00:12:31Z&amp;#34;, GoVersion:&amp;#34;go1.8.3&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;linux/amd64&amp;#34;}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="获取集群地址">获取集群地址&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube ip
192.168.99.100
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取服务列表">获取服务列表&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube service list
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="打开dashboard">打开dashboard&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">minikube dashboard
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kubectl">kubectl&lt;/h2>
&lt;h4 id="部署dashboard-ui">部署Dashboard UI&lt;/h4>
&lt;p>默认minikube会自动部署dashboard&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="启动proxy">启动proxy&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl proxy
&lt;span class="c1">#Starting to serve on 127.0.0.1:8001&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="获取pod信息">获取pod信息&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl get pods --namespace kube-system
NAME READY STATUS RESTARTS AGE
kube-addon-manager-minikube 0/1 Running &lt;span class="m">0&lt;/span> 1h
kubernetes-dashboard-3313488171-90s64 0/1 Running &lt;span class="m">0&lt;/span> 20m
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果STATUS一直处于&lt;strong>ContainerCreating&lt;/strong>状态，应该是pull image失败。默认是去gcr.io拉镜像，被墙了。需要在启动minikube的时候设置docker使用的代理。&lt;/p>
&lt;h4 id="获取pod详细信息">获取pod详细信息&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">kubectl describe pod kubernetes-dashboard-3313488171-90s64 --namespace kube-system
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="查看log">查看log&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">kubectl logs -f kubernetes-dashboard-3313488171-90s64
&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>