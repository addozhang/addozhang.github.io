<!DOCTYPE html>
<html>
<head>
    <title>Kubernetes — 持久卷 // 乱世浮生</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    <meta name="description" content="知我者谓我何忧 不知我者谓我何求.">
    <meta name="keywords" content="Java,Spring Cloud,Architecture,">

        <meta property="og:title" content="Kubernetes — 持久卷" />
    <meta property="og:description" content="知我者谓我何忧 不知我者谓我何求." />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="zh-cn" />
    <meta property="og:url" content="https://atbug.com/kubernetes-persistent-volumes/" />
    

    <link rel="shortcut icon" href="../favicon.ico">

    <link href="https://atbug.com/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="https://atbug.com/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="https://atbug.com/css/style.css">
    

    <meta name="generator" content="Hugo 0.82.0" />
</head>


<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="https://atbug.com/">乱世浮生</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="../">Home</a>
                
                <a class="main-nav-link" href="../post/">Archives</a>
                
                <a class="main-nav-link" href="../tags/">Tags</a>
                
                <a class="main-nav-link" href="../categories/">Categories</a>
                
                <a class="main-nav-link" href="../about/">About</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        <article class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            <h1 class="article-title" itemprop="name">Kubernetes — 持久卷</h1>
        </header>
        
        <div class="article-meta">
            <a href="../kubernetes-persistent-volumes/" class="article-date">
                <time datetime='2017-08-20T22:25:40.000&#43;00:00' itemprop="datePublished">2017-08-20</time>
            </a>
            
            
            <div class="post-categories">
                <div class="article-category">
                    
                    
                    <a class="article-category-link" href="https://atbug.com//categories/%E5%AD%A6%E4%B9%A0">学习</a>
                    
                </div>
            </div>
            
            
            <div class="article-comment-link-wrap">
                <a href="../kubernetes-persistent-volumes/#disqus_thread" class="article-comment-link">Comments</a>
            </div>
            
        </div>
        <div class="article-entry" itemprop="articleBody">
            <h1 id="persistent-volume">Persistent Volume</h1>
<p>译自<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volumes</a></p>
<h2 id="介绍">介绍</h2>
<p>管理存储是管理计算的独特问题。 PersistentVolume子系统为用户和管理员提供了一个API，其中提供了如何从如何使用存储提供存储的详细信息。为此，我们介绍两种新的API资源：PersistentVolume和PersistentVolumeClaim。</p>
<p>PersistentVolume（PV）是由管理员配置的集群中的一段存储。它是集群中的一种资源就像一个节点是一个集群的资源。 PV是类似Volumes的卷插件，但是具有独立于使用PV的任何单个pod的生命周期。该API对象捕获存储的实现细节，即NFS，iSCSI或云提供商特定的存储系统。</p>
<p>PersistentVolumeClaim（PVC）是用户存储的请求。它类似于pod。 Pod消耗节点资源，PVC消耗PV资源。Pods可以请求特定级别的资源（CPU和内存）。声明可以请求特定的大小和访问模式（例如，一次读写或者多次只读）。</p>
<p>虽然PersistentVolumeClaims允许用户使用抽象存储资源，但是常见的是，用户需要具有不同属性（如性能）的PersistentVolumes，用于不同的问题。 集群管理员需要能够提供多种彼此不同的PersistentVolumes，而不仅仅是大小和访问模式，而不会使用户了解这些卷的实现细节。 对于这些需求，有一个StorageClass资源。</p>
<p>StorageClass为管理员提供了一种描述他们提供的存储的“类”的方法。 不同的类可能映射到服务质量级别，或备份策略，或者由群集管理员确定的任意策略。 Kubernetes本身对于什么类别代表是不言而喻的。 这个概念有时在其他存储系统中称为“配置文件”。</p>
<p>请参阅<a href="https://kubernetes.io/docs/user-guide/persistent-volumes/walkthrough/">详细演练与工作示例</a>。</p>
<h2 id="存储和声明的生命周期">存储和声明的生命周期</h2>
<p>PVs是集群中的资源；PVCs是对这种资源的声明，同时也扮演者对资源声明的检查。PVs和PVCs之前的交互遵循生命周期：供应、绑定、使用中、重新申请。</p>
<p>集群管理员创建多个PV。它们携带可供集群用户使用的真实存储的详细信息。它们存在于Kubernetes API中，可用于消费。</p>
<h3 id="供应provisioning">供应(Provisioning)</h3>
<p>PVs会以两种方式供应：静态和动态。</p>
<h4 id="静态">静态</h4>
<p>集群管理员创建多个PV。 它们携带可供集群用户使用的真实存储的详细信息。 它们存在于Kubernetes API中，可被使用。</p>
<h4 id="动态">动态</h4>
<p>当管理员创建的静态PV都不匹配用户的PersistentVolumeClaim时，集群可能会尝试为PVC指定动态配置卷。 此配置基于StorageClasses：PVC必须指定一个类，并且管理员必须已创建并配置该类才能进行动态配置。 要求该类的声明有效地为自己禁用动态配置。</p>
<h3 id="绑定binding">绑定(Binding)</h3>
<p>当用户创建、或已经创建了一个PersistenVolumenClaim并指定大小和访问类型。Master中的控制循环会检测新的PVC，找到一个匹配的PV（如果可能的话），并将它们绑定在一起。如果一个PV被动态地供应某个PVC，循环将总是把这个PV和该PVC绑定。否则，用户总是至少得到他们要求的内容，但是卷可能超出了要求。一旦绑定，PersistentVolumeClaim绑定是排他的，不管用于绑定它们的模式。</p>
<p>如果匹配的卷不存在，请求将无限期地保持。 随着匹配卷变得可用，请求将被绑定。 例如，提供许多50Gi PV的集群将不匹配要求100Gi的PVC。 当集群中添加100Gi PV时，可以绑定PVC。</p>
<h3 id="使用使用">使用(使用)</h3>
<p>PODs把PVC当做volume使用。集群检查声明以找到绑定的卷并为POD挂载该卷。 对于支持多种访问模式的卷，用户在将其声明用作pod中的卷时指定所需的模式。</p>
<p>一旦用户有声明并且该声明被绑定，绑定的PV属于用户，只要他们需要它。 用户通过在其Pod的卷块中包含persistentVolumeClaim来安排Pods并访问其声明的PV。 请参阅下面的语法详细信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypod</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">myfrontend</span><span class="w">
</span><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">dockerfile/nginx</span><span class="w">
</span><span class="w">      </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/var/www/html&#34;</span><span class="w">
</span><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypd</span><span class="w">
</span><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypd</span><span class="w">
</span><span class="w">      </span><span class="nt">persistentVolumeClaim</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">claimName</span><span class="p">:</span><span class="w"> </span><span class="l">myclaim</span><span class="w">
</span></code></pre></div><h3 id="回收reclaiming">回收(Reclaiming)</h3>
<p>当用户使用完volume，可以通过请求允许回收资源的API来删除该PVC对象。PersistentVolume的回收策略告诉集群如何处理当声明释放PV后。目前，卷可以被保留，回收或删除。</p>
<h4 id="保留retaining">保留(Retaining)</h4>
<p>保留回收策略允许手动回收资源。 当PersistentVolumeClaim被删除时，PersistentVolume仍然存在，并且该卷被认为是“释放的”。 但是，由于上一个声明者的数据仍保留在卷上，因此尚不可用于其他声明。 管理员可以通过以下步骤手动回收卷。</p>
<ul>
<li>删除PersistentVolume。 删除PV后，外部基础设施（如AWS EBS，GCE PD，Azure Disk或Cinder卷）中的关联存储资产仍然存在。</li>
<li>相应地手动清理相关存储资产上的数据。</li>
<li>手动删除关联的存储资产，或者如果要重用相同的存储资产，请使用存储资产定义创建一个新的PersistentVolume。</li>
</ul>
<h4 id="回收recycling">回收(Recycling)</h4>
<p>如果受相应的卷插件支持，回收将对卷执行基本的擦除（rm -rf / thevolume / *），并使其再次可用于新的声明。
但是，管理员可以使用Kubernetes控制器管理器命令行参数来配置自定义的回收器pod模板，如<a href="https://kubernetes.io/docs/admin/kube-controller-manager/">这里</a>所述。 定制回收站模板必须包含卷规范，如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pv-recycler-</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">restartPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Never</span><span class="w">
</span><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">vol</span><span class="w">
</span><span class="w">    </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/any/path/it/will/be/replaced</span><span class="w">
</span><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pv-recycler</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gcr.io/google_containers/busybox&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;/bin/sh&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;-c&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">vol</span><span class="w">
</span><span class="w">      </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/scrub</span><span class="w">
</span></code></pre></div><p>但是，卷部分中的自定义回收器pod模板中指定的特定路径将替换为正在回收的卷的特定路径。</p>
<h4 id="删除deleting">删除(Deleting)</h4>
<p>对于支持“删除回收”策略的卷插件，删除将从Kubernetes中删除PersistentVolume对象，并删除外部基础架构（如AWS EBS，GCE PD，Azure Disk或Cinder卷）中关联的存储资产。 动态配置的卷始终被删除。 如果不希望这样做，目前唯一的选择是在创建PV之后编辑或修补PV。 请参阅<a href="https://kubernetes.io/docs/tasks/administer-cluster/change-pv-reclaim-policy/">更改PersistentVolume的回收策略</a>。</p>
<h3 id="persistent-volume的类型">Persistent Volume的类型</h3>
<ul>
<li>GCEPersistentDisk</li>
<li>AWSElasticBlockStore</li>
<li>AzureFile</li>
<li>AzureDisk</li>
<li>FC (Fibre Channel)</li>
<li>FlexVolume</li>
<li>Flocker</li>
<li>NFS</li>
<li>iSCSI</li>
<li>RBD (Ceph Block Device)</li>
<li>CephFS</li>
<li>Cinder (OpenStack block storage)</li>
<li>Glusterfs</li>
<li>VsphereVolume</li>
<li>Quobyte Volumes</li>
<li>HostPath (single node testing only – local storage is not supported in any way and WILL NOT WORK in a multi-node cluster)</li>
<li>VMware Photon</li>
<li>Portworx Volumes</li>
<li>ScaleIO Volumes</li>
<li>StorageOS</li>
</ul>
<h2 id="persistent-volumes">Persistent Volumes</h2>
<p>每个PV都包含规格和状态，这是规格和状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="w">  </span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w">  </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PersistentVolume</span><span class="w">
</span><span class="w">  </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pv0003</span><span class="w">
</span><span class="w">  </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">capacity</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">storage</span><span class="p">:</span><span class="w"> </span><span class="l">5Gi</span><span class="w">
</span><span class="w">    </span><span class="nt">accessModes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">ReadWriteOnce</span><span class="w">
</span><span class="w">    </span><span class="nt">persistentVolumeReclaimPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Recycle</span><span class="w">
</span><span class="w">    </span><span class="nt">storageClassName</span><span class="p">:</span><span class="w"> </span><span class="l">slow</span><span class="w">
</span><span class="w">    </span><span class="nt">nfs</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/tmp</span><span class="w">
</span><span class="w">      </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="m">172.17.0.2</span><span class="w">
</span></code></pre></div><h3 id="容量">容量</h3>
<p>通常，PV将具有特定的存储容量。这是使用PV的<code>capacity</code>属性设置的。看到Kubernetes的<a href="https://git.k8s.io/community/contributors/design-proposals/resources.md">资源模型</a>，以了解容量使用的单位。</p>
<p>目前，存储大小是唯一可以设置或请求的资源。未来的属性可能包括IOPS，吞吐量等。</p>
<h3 id="访问模式">访问模式</h3>
<p>PersistentVolume可以以资源提供者支持的任何方式安装在主机上。 如下表所示，提供者将具有不同的特性，每个PV的访问模式都被设置为该特定卷支持的特定模式。 例如，NFS可以支持多个读/写客户端，但是特定的NFS PV可能会以只读方式在服务器上导出。 每个PV都有自己的一组访问模式来描述具体的PV功能。</p>
<p>访问模式：</p>
<ul>
<li>ReadWriteOnce - 卷可以由单个节点作为读写装载</li>
<li>ReadOnlyMany - 许多节点可以只读容量</li>
<li>ReadWriteMany - 卷可以通过许多节点的读写装载</li>
</ul>
<p>在CLI中，访问模式缩写为：</p>
<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
</ul>
<p>重要！一个卷只能一次使用一种访问模式进行挂载，即使它支持很多。例如，GCEPersistentDisk可以由单个节点挂载为ReadWriteOnce或多个节点挂载为ReadOnlyMany，但不能同时使用两种。</p>
<table>
<thead>
<tr>
<th>Volume插件</th>
<th>单节点读写</th>
<th>多个节点只读</th>
<th>多个节点读写</th>
</tr>
</thead>
<tbody>
<tr>
<td>AWSElasticBlockStore</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>AzureFile</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>AzureDisk</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>CephFS</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Cinder</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>FC</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>FlexVolume</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Flocker</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>GCEPersistentDisk</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Glusterfs</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>HostPath</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>iSCSI</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>PhotonPersistentDisk</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Quobyte</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>NFS</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>RBD</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>VsphereVolume</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>PortworxVolume</td>
<td>✓</td>
<td>-</td>
<td>✓</td>
</tr>
<tr>
<td>ScaleIO</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>StorageOS</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="类型">类型</h3>
<p>PV可以有一个类型，通过将storageClassName属性设置为StorageClass的名称来指定。 特定类型的PV只能绑定到请求该类型的PVC。 没有storageClassName的PV没有类型，只能绑定到不需要特定类型的PVC。
在过去，使用了注释volume.beta.kubernetes.io/storage-class而不是storageClassName属性。 该注释仍然可以工作，但将来Kubernetes版本将不再适用。</p>
<h3 id="回收策略">回收策略</h3>
<p>目前的回收策略是：</p>
<ul>
<li>Retain - 手动回收</li>
<li>Recycle - 基本擦洗（“rm -rf / thevolume / *”）</li>
<li>Delete - 相关联的存储资产，如AWS EBS，GCE PD，Azure Disk或OpenStack Cinder卷被删除</li>
</ul>
<p>目前，只有NFS和HostPath支持回收。 AWS EBS，GCE PD，Azure Disk和Cinder卷支持删除。</p>
<h3 id="阶段">阶段</h3>
<p>卷将处于以下阶段之一：</p>
<ul>
<li>Available 可用 - 一个尚未绑定到索赔的免费资源</li>
<li>Bound 绑定 - 音量必须是声明</li>
<li>Released 释放 - 声明已被删除，但资源尚未被集群回收</li>
<li>Failed 失败 - 卷自动回收失败</li>
</ul>
<p>CLI将显示绑定到PV的PVC的名称。</p>
<h3 id="挂载选项">挂载选项</h3>
<p>Kubernetes管理员可以指定在一个节点上挂载一个持久卷时的其他挂载选项。</p>
<p>您可以通过使用持久卷上的注释volume.beta.kubernetes.io/mount-options来指定安装选项。</p>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;v1&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;PersistentVolume&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">gce-disk-1</span><span class="w">
</span><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">volume.beta.kubernetes.io/mount-options</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;discard&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">capacity</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">storage</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;10Gi&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">accessModes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="s2">&#34;ReadWriteOnce&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">gcePersistentDisk</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">fsType</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;ext4&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">pdName</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gce-disk-1&#34;</span><span class="w">
</span></code></pre></div><p>安装选项是一个字符串，在将卷安装到磁盘时将被累积地连接和使用。</p>
<p>请注意，并非所有Persistent卷类型都支持挂载选项。 在Kubernetes 1.6版中，以下卷类型支持挂载选项。</p>
<ul>
<li>GCEPersistentDisk</li>
<li>AWSElasticBlockStore</li>
<li>AzureFile</li>
<li>AzureDisk</li>
<li>NFS</li>
<li>iSCSI</li>
<li>RBD (Ceph Block Device)</li>
<li>CephFS</li>
<li>Cinder (OpenStack block storage)</li>
<li>Glusterfs</li>
<li>VsphereVolume</li>
<li>Quobyte Volumes</li>
<li>VMware Photon</li>
</ul>
<h2 id="persistentvolumeclaims">PersistentVolumeClaims</h2>
<p>每个PVC包含规格和状态，这是声明的规范和状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PersistentVolumeClaim</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">myclaim</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">accessModes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">ReadWriteOnce</span><span class="w">
</span><span class="w">  </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">storage</span><span class="p">:</span><span class="w"> </span><span class="l">8Gi</span><span class="w">
</span><span class="w">  </span><span class="nt">storageClassName</span><span class="p">:</span><span class="w"> </span><span class="l">slow</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">release</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;stable&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- {<span class="nt">key: environment, operator: In, values</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="l">dev]}</span><span class="w">
</span></code></pre></div><h3 id="访问模式-1">访问模式</h3>
<p>当请求具有特定访问模式的存储时，声明使用与卷相同的约定。</p>
<h3 id="资源">资源</h3>
<p>声明（就像pods）可以请求特定数量的资源。 在这种情况下，请求用于存储。 相同的资源模型适用于卷和声明。</p>
<h3 id="选择器">选择器</h3>
<p>声明可以指定标签选择器以进一步过滤Volumes集。 只有标签与选择器匹配的卷才能绑定到声明。 选择器可以由两个字段组成：</p>
<ul>
<li>matchLabels - 卷必须具有带此值的标签</li>
<li>matchExpressions - 通过指定关键字和值的关键字，值列表和运算符所做的要求列表。 有效运算符包括In，NotIn，Exists和DoesNotExist。</li>
</ul>
<p>所有来自matchLabels和matchExpressions的要求是组合在一起的，所有这些要求都必须满足才能匹配。</p>
<h3 id="类型-1">类型</h3>
<p>声明可以通过使用属性storageClassName指定StorageClass的名称来请求特定的类型。只有所请求的类型的PV，与PVC相同的storageClassName的PV可以绑定到PVC。</p>
<p>PVC不一定要求一个类型。 它的storageClassName设置为等于“”的PVC总是被解释为请求没有类型的PV，因此它只能绑定到没有类型的PV（没有注释或一个等于“”）。 没有storageClassName的PVC不完全相同，并且根据是否启用了DefaultStorageClass admission插件，集群的处理方式不同。</p>
<ul>
<li>如果admission插件已打开，则管理员可以指定默认的StorageClass。 没有storageClassName的所有PVC只能绑定到该默认的PV。 通过将StorageClass对象中的注解storageclass.kubernetes.io/is-default-class设置为“true”来指定默认的StorageClass。 如果管理员没有指定默认值，则集群会对PVC创建做出响应，就像admission插件被关闭一样。 如果指定了多个默认值，则admission插件禁止创建所有PVC。</li>
<li>如果admission插件已关闭，则不存在默认StorageClass的概念。 没有<code>storageClassName</code>的所有PVC只能绑定到没有类的PV。 在这种情况下，没有<code>storageClassName</code>的PVC的处理方式与将其<code>storageClassName</code>设置为“”的PVC相同。</li>
</ul>
<p>根据挂载方法，挂载过程中可以通过addon manager在Kubernetes群集中部署默认的<code>StorageClass</code>。</p>
<p>当PVC指定一个选择器，除了请求一个<code>StorageClass</code>之外，这些要求被AND组合在一起：只有所请求的类和所请求的标签的PV可能被绑定到PVC。 请注意，当前，具有非空选择器的PVC不能为其动态配置PV。</p>
<p>在过去，使用了注解<code>volume.beta.kubernetes.io/storage-class</code>，而不是<code>storageClassName</code>属性。 该注解仍然可以工作，但在未来的Kubernetes版本中它将不被支持。</p>
<h2 id="claims-vs-volumes">Claims VS Volumes</h2>
<p>Pods通过将声明用作卷来访问存储。 声明必须存在于与使用声明的pod相同的命名空间中。 集群在pod的命名空间中查找声明，并使用它来获取支持声明的<code>PersistentVolume</code>。 然后将卷挂载到主机并进入pod。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypod</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">myfrontend</span><span class="w">
</span><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">dockerfile/nginx</span><span class="w">
</span><span class="w">      </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/var/www/html&#34;</span><span class="w">
</span><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypd</span><span class="w">
</span><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypd</span><span class="w">
</span><span class="w">      </span><span class="nt">persistentVolumeClaim</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">claimName</span><span class="p">:</span><span class="w"> </span><span class="l">myclaim</span><span class="w">
</span></code></pre></div><h3 id="关于命名空间的注意">关于命名空间的注意</h3>
<p><code>PersistentVolumes</code>绑定是独占的，并且由于<code>PersistentVolumeClaims</code>是命名空间对象，因此只能在一个命名空间内挂载“many”模式（ROX，RWX）的声明。</p>
<h2 id="storageclasses">StorageClasses</h2>
<p>每个<code>StorageClass</code>包含字段<code>provisioninger</code>和<code>parameter</code>，当属于类型的<code>PersistentVolume</code>需要动态配置时使用。</p>
<p><code>StorageClass</code>对象的名称很重要，用户可以如何请求特定的类。 管理员在首次创建<code>StorageClass</code>对象时设置类的名称和其他参数，并且在创建对象后无法更新对象。</p>
<p>管理员可以仅为不要求任何特定类绑定的PVC指定默认的StorageClass：有关详细信息，请参阅<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaim</a>部分。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StorageClass</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">storage.k8s.io/v1</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">standard</span><span class="w">
</span><span class="w"></span><span class="nt">provisioner</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes.io/aws-ebs</span><span class="w">
</span><span class="w"></span><span class="nt">parameters</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">gp2</span><span class="w">
</span></code></pre></div><h3 id="供应者provisioner">供应者(Provisioner)</h3>
<p>存储类有一个供应者，它确定用于配置PV的卷插件。必须指定此字段。</p>
<table>
<thead>
<tr>
<th>Volume Plugin</th>
<th>Internal Provisioner</th>
<th>Config Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>AWSElasticBlockStore</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#aws">AWS</a></td>
</tr>
<tr>
<td>AzureFile</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#azure-file">Azure File</a></td>
</tr>
<tr>
<td>AzureDisk</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#azure-disk">Azure Disk</a></td>
</tr>
<tr>
<td>CephFS</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Cinder</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#openstack-cinder">OpenStack Cinder</a></td>
</tr>
<tr>
<td>FC</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>FlexVolume</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Flocker</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>GCEPersistentDisk</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#gce">GCE</a></td>
</tr>
<tr>
<td>Glusterfs</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#glusterfs">Glusterfs</a></td>
</tr>
<tr>
<td>iSCSI</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>PhotonPersistentDisk</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Quobyte</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#quobyte">Quobyte</a></td>
</tr>
<tr>
<td>NFS</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>RBD</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#ceph-rbd">Ceph RBD</a></td>
</tr>
<tr>
<td>VsphereVolume</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#vsphere">vSphere</a></td>
</tr>
<tr>
<td>PortworxVolume</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#portworx-volume">Portworx Volume</a></td>
</tr>
<tr>
<td>ScaleIO</td>
<td>✓</td>
<td><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#scaleio">ScaleIO</a></td>
</tr>
</tbody>
</table>
<p>你不限于指定此处列出的“internal”供应者（其名称前缀为“kubernetes.io”并与Kubernetes一起发送）。 你还可以运行和指定外部提供程序，它们是遵循Kubernetes定义的规范的独立程序。 外部提供者的作者对代码的生命周期，供应商的运输状况，运行状况以及使用的卷插件（包括Flex）等都有充分的自主权。存储库kubernetes-incubator /外部存储库包含一个库 用于编写实施大部分规范的外部提供者以及各种社区维护的外部提供者。</p>
<p>例如，NFS不提供内部提供程序，但可以使用外部提供程序。 一些外部提供者列在存储库kubernetes-incubator/external-storage中。 还有第三方存储供应商提供自己的外部供应商的情况。</p>
<h3 id="回收策略-1">回收策略</h3>
<p>由存储类动态创建的持久卷将具有<code>delete</code>的回收策略。 如果不希望这样做，唯一的当前选项是在创建PV之后编辑PV。</p>
<p>通过存储类手动创建和管理的持久卷将具有在创建时分配的任何回收策略。</p>
<h3 id="参数">参数</h3>
<p>存储类型具有描述属于存储类型的卷的参数。 取决于供应者，可以接受不同的参数。 例如，参数类型的值io1和参数iopsPerGB特定于EBS。 当省略参数时，使用一些默认值。</p>

        </div>

        
        
        <div class="article-toc" >
            <h3></h3>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#存储和声明的生命周期">存储和声明的生命周期</a>
      <ul>
        <li><a href="#供应provisioning">供应(Provisioning)</a></li>
        <li><a href="#绑定binding">绑定(Binding)</a></li>
        <li><a href="#使用使用">使用(使用)</a></li>
        <li><a href="#回收reclaiming">回收(Reclaiming)</a></li>
        <li><a href="#persistent-volume的类型">Persistent Volume的类型</a></li>
      </ul>
    </li>
    <li><a href="#persistent-volumes">Persistent Volumes</a>
      <ul>
        <li><a href="#容量">容量</a></li>
        <li><a href="#访问模式">访问模式</a></li>
        <li><a href="#类型">类型</a></li>
        <li><a href="#回收策略">回收策略</a></li>
        <li><a href="#阶段">阶段</a></li>
        <li><a href="#挂载选项">挂载选项</a></li>
      </ul>
    </li>
    <li><a href="#persistentvolumeclaims">PersistentVolumeClaims</a>
      <ul>
        <li><a href="#访问模式-1">访问模式</a></li>
        <li><a href="#资源">资源</a></li>
        <li><a href="#选择器">选择器</a></li>
        <li><a href="#类型-1">类型</a></li>
      </ul>
    </li>
    <li><a href="#claims-vs-volumes">Claims VS Volumes</a>
      <ul>
        <li><a href="#关于命名空间的注意">关于命名空间的注意</a></li>
      </ul>
    </li>
    <li><a href="#storageclasses">StorageClasses</a>
      <ul>
        <li><a href="#供应者provisioner">供应者(Provisioner)</a></li>
        <li><a href="#回收策略-1">回收策略</a></li>
        <li><a href="#参数">参数</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
        
        

        


        
        <footer class="article-footer">
            <ul class="article-tag-list">
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="https://atbug.com//tags/kubernetes">Kubernetes
                    </a>
                </li>
                
            </ul>
        </footer>
        <div class="article-entry">
            <hr>
            <p>文章同步更新在公众号：云编码 (微信号：sevenfeet)，扫码关注第一时间获取文章更新。</p>
            <p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2020/05/23/qrcode.jpg" alt="qrcode"></p>
        </div>
        
    </div>
    
<nav id="article-nav">
    
    <a href="../how-to-use-hostpath-in-openshift/" id="article-nav-newer" class="article-nav-link-wrap">
        <div class="article-nav-title"><span>&lt;</span>&nbsp;
            如何在Openshift中使用hostPath
        </div>
    </a>
    
    
    <a href="../install-kubernetes-on-macos/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">Kubernetes学习 — Macos安装Kubernetes&nbsp;<span>&gt;</span></div>
    </a>
    
</nav>


</article>

        
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "addozhang" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2021 Addo Zhang
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-47966140-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css" integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>
